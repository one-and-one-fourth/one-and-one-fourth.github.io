<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高数基础知识（下）</title>
    <link href="/2025/07/01/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8B/"/>
    <url>/2025/07/01/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="四、不定积分"><a href="#四、不定积分" class="headerlink" title="四、不定积分"></a>四、不定积分</h1><h2 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h2><p>若 $F(x)$ 为 $f(x)$ 在某区间内的原函数，则 $F(x) + C$（$C$ 为任意常数）也为 $f(x)$ 在该区间内的原函数。</p><p>若 $F(x), G(x)$ 都是 $f(x)$ 在某区间内的原函数，则 $F(x) - G(x) &#x3D; C$（$C$ 为某个确定常数）。</p><p><strong>不定积分</strong></p><p>定义 $f(x)$ 的原函数的全体称为 $f(x)$ 的不定积分，记为 $\int f(x) dx$。</p><p>如果 $F(x)$ 为 $f(x)$ 的一个原函数，则有<br>$$\int f(x) dx &#x3D; F(x) + C, \text{ 其中 } C \text{ 为任意常数。}$$</p><p><strong>不定积分的几何意义</strong></p><p>设 $F(x)$ 为 $f(x)$ 的一个原函数，则从几何上看，$F(x)$ 表示平面上的一条曲线，称为 $f(x)$ 的积分曲线。因此，不定积分 $$\int f(x) dx &#x3D; F(x) + C$$ 在几何上表示一簇积分曲线。这簇分曲线对应于横坐标 $x$ 处的切线都相互平行。</p><p><strong>原函数存在定理</strong></p><p>定理  若 $f(x)$ 在区间 $I$ 上连续，则 $f(x)$ 在区间 $I$ 上一定存在原函数。<br>定理  若 $f(x)$ 在区间 $I$ 上有第一类间断点，则 $f(x)$ 在区间 $I$ 上没有原函数。</p><hr><h2 id="4-2-不定积分性质和公式"><a href="#4-2-不定积分性质和公式" class="headerlink" title="4.2 不定积分性质和公式"></a>4.2 不定积分性质和公式</h2><p><strong>（1）不定积分的性质</strong></p><p>(1) $\left( \int f(x) dx \right)’ &#x3D; f(x), \quad d \int f(x) dx &#x3D; f(x) dx.$</p><p>(2) $\int f’(x) dx &#x3D; f(x) + C, \quad \int df(x) &#x3D; f(x) + C.$</p><p>(3) $\int [f(x) \pm g(x)] dx &#x3D; \int f(x) dx \pm \int g(x) dx.$</p><p>(4) $\int kf(x) dx &#x3D; k \int f(x) dx \quad (k \text{ 为常数}).$</p><p><strong>（2）不定积分基本公式</strong></p><p>(1) $\int 0 dx &#x3D; C.$</p><p>(2) $\int x^a dx &#x3D; \frac{1}{a+1} x^{a+1} + C \quad (a \neq -1).$</p><p>(3) $\int \frac{1}{x} dx &#x3D; \ln |x| + C.$</p><p>(4) $\int a^x dx &#x3D; \frac{a^x}{\ln a} + C \quad (a &gt; 0, a \neq 1).$</p><p>(5) $\int e^x dx &#x3D; e^x + C.$</p><p>(6) $\int \sin x dx &#x3D; -\cos x + C.$</p><p>(7) $\int \cos x dx &#x3D; \sin x + C.$</p><p>(8) $\int \sec^2 x dx &#x3D; \tan x + C.$</p><p>(9) $\int \csc^2 x dx &#x3D; -\cot x + C.$</p><p>(10) $\int \sec x \tan x dx &#x3D; \sec x + C.$</p><p>(11) $\int \csc x \cot x dx &#x3D; -\csc x + C.$</p><p>(12) $\int \frac{1}{\sqrt{1-x^2}} dx &#x3D; \arcsin x + C.$</p><p>(13) $\int \frac{1}{1+x^2} dx &#x3D; \arctan x + C.$</p><p>(14) $\int \frac{dx}{\sqrt{a^2-x^2}} &#x3D; \arcsin \frac{x}{a} + C.$</p><p>(15) $\int \frac{dx}{a^2+x^2} &#x3D; \frac{1}{a} \arctan \frac{x}{a} + C.$</p><p>(16) $\int \frac{dx}{x^2-a^2} &#x3D; \frac{1}{2a} \ln \left| \frac{x-a}{x+a} \right| + C.$</p><p>(17) $\int \frac{dx}{\sqrt{x^2+a^2}} &#x3D; \ln(x+\sqrt{x^2+a^2}) + C$ </p><p>(18) $\int \frac{dx}{\sqrt{x^2-a^2}} &#x3D; \ln |x+\sqrt{x^2-a^2}| + C$</p><p>(19) $\int \sec x dx &#x3D; \ln |\sec x + \tan x| + C$ </p><p>(20) $\int \csc x dx &#x3D; -\ln |\csc x + \cot x| + C$</p><hr><h2 id="4-3-三种主要积分法"><a href="#4-3-三种主要积分法" class="headerlink" title="4.3 三种主要积分法"></a>4.3 三种主要积分法</h2><h3 id="4-3-1-第一换元积分法"><a href="#4-3-1-第一换元积分法" class="headerlink" title="4.3.1 第一换元积分法"></a>4.3.1 第一换元积分法</h3><p>定理  设 $$\int f(u) du &#x3D; F(u) + C, \quad u &#x3D; \varphi(x)$$ 存在连续导数，则<br>$$\int [f(\varphi(x))] \varphi’(x) dx &#x3D; \int f[\varphi(x)] d\varphi(x) &#x3D; F[\varphi(x)] + C.$$</p><p>常见的凑微分形式：<br>(1) $\int f(ax + b) dx &#x3D; \frac{1}{a} \int f(ax + b) d(ax + b)$</p><p>(2) $\int x^m f(ax^{m+1} + b) dx &#x3D; \frac{1}{(m+1)a} \int f(ax^{m+1} + b) d(ax^{m+1} + b) \quad (m \ne -1)$</p><p>(3) $\int f(\sqrt{x}) \frac{dx}{\sqrt{x}} &#x3D; 2 \int f(\sqrt{x}) d(\sqrt{x})$</p><p>(4) $\int f(e^x) e^x dx &#x3D; \int f(e^x) d(e^x)$</p><p>(5) $\int f(\ln x) \frac{1}{x} dx &#x3D; \int f(\ln x) d(\ln x)$</p><p>(6) $\int f(\sin x) \cos x dx &#x3D; \int f(\sin x) d(\sin x)$</p><p>(7) $\int f(\cos x) \sin x dx &#x3D; -\int f(\cos x) d(\cos x)$</p><p>(8) $\int f(\tan x) \frac{1}{\cos^2 x} dx &#x3D; \int f(\tan x) d(\tan x)$</p><p>(9) $\int f(\arcsin x) \frac{1}{\sqrt{1-x^2}} dx &#x3D; \int f(\arcsin x) d(\arcsin x)$</p><p>(10) $\int f(\arctan x) \frac{1}{1+x^2} dx &#x3D; \int f(\arctan x) d(\arctan x)$</p><div class="note note-success">            <p>求不定积分 $\int \sec^4 x dx$,</p><p>解 (1) $\int \sec^4 x dx &#x3D; \int \sec^2 x d(\tan x) &#x3D; \int (\tan^2 x + 1) d(\tan x)$<br>$&#x3D; \frac{1}{3} \tan^3 x + \tan x + C$</p>          </div><hr><h3 id="4-3-2-第二换元积分法"><a href="#4-3-2-第二换元积分法" class="headerlink" title="4.3.2 第二换元积分法"></a>4.3.2 第二换元积分法</h3><p><strong>定理</strong>  设 $x &#x3D; \varphi(t)$ 是单调的、可导的函数，并且 $\varphi’(t) \neq 0$。又<br>$$\int f[\varphi(t)]\varphi’(t)dt &#x3D; F(t) + C$$则<br>$$<br>\begin{align*}<br>\int f(x)dx &amp;&#x3D; \int f[\varphi(t)]\varphi’(t)dt \\&amp;&#x3D; F(t) + C\\<br>&amp;&#x3D; F[\varphi^{-1}(x)] + C<br>\end{align*}<br>$$<br>其中 $\varphi^{-1}(x)$ 是 $x &#x3D; \varphi(t)$ 的反函数。</p><p>常用的三种变量代换：<br>(1) 被积函数含有 $\sqrt{a^2 - x^2}$，令 $x &#x3D; a \sin t$（或 $a \cos t$）<br>(2) 被积函数含有 $\sqrt{a^2 + x^2}$，令 $x &#x3D; a \tan t$<br>(3) 被积函数含有 $\sqrt{x^2 - a^2}$，令 $x &#x3D; a \sec t$</p><h3 id="4-3-3-分部积分法"><a href="#4-3-3-分部积分法" class="headerlink" title="4.3.3 分部积分法"></a>4.3.3 分部积分法</h3><p><strong>(1) 分部积分法所适用的函数类</strong><br>$$<br>\int u d v&#x3D;uv-\int v d u<br>$$</p><p><strong>(2) 分部积分法所适用的函数类</strong></p><p>分部积分法比较适用于两类不同函数相乘。如下列积分，这里 $ p_n(x) $ 为 $ x $ 的 $ n $ 次多项式。</p><p>$$<br>\int p_n(x) e^{ax} dx, \quad \int p_n(x) \sin ax dx,\int p_n(x) \cos ax dx,\quad \int e^{ax} \sin ax dx,<br>$$</p><p>$$<br>\int e^{ax} \cos ax dx, \quad \int p_n(x) \ln x dx,\int p_n(x) \arctan x dx, \quad \int p_n(x) \arcsin x dx.<br>$$</p><p><strong>(3) 分部积分法中 ( u,v ) 的选取</strong></p><p>分部积分法在使用时的关键是 ( u,v ) 的选取，换句话说就是把哪个数凑到微分号里去。</p><ol><li>$\int p_n(x) e^{ax} dx, \int p_n(x) \sin ax dx, \int p_n(x) \cos ax dx$，这3种积分都应多项式以外的函数凑进微分号。</li><li>$\int e^{ax} \sin ax dx, \int e^{ax} \cos ax dx$，这2种积分把指数函数或三角函数凑进微分号都可以，但把指数凑进去更简单，连续两次将指数函数凑进去分部积分还原便可求解。</li><li>$\int p_n(x) \ln x dx, \int p_n(x) \arctan x dx, \int p_n(x) \arcsin x dx$，这3种积分都应多项式函数凑进微分号。</li></ol><hr><h3 id="4-3-4-常见可积函数积分"><a href="#4-3-4-常见可积函数积分" class="headerlink" title="4.3.4 常见可积函数积分"></a>4.3.4 常见可积函数积分</h3><h4 id="4-3-4-1-三角有理式积分"><a href="#4-3-4-1-三角有理式积分" class="headerlink" title="4.3.4.1 三角有理式积分"></a>4.3.4.1 三角有理式积分</h4><p>$$<br>\int R(\sin x, \cos x) dx<br>$$</p><p><strong>(1) 一般方法（万能代换）</strong></p><p>令 $\tan \frac{x}{2} &#x3D; t$，</p><p>$$<br>\int R(\sin x, \cos x) dx &#x3D; \int R\left( \frac{2t}{1+t^2}, \frac{1-t^2}{1+t^2} \right) \frac{2}{1+t^2} dt<br>$$</p><p><strong>(2) 特殊方法（三角变形，换元，分部）</strong></p><p>几种常用的换元法：</p><ol><li><p>若 $R(-\sin x, \cos x) &#x3D; -R(\sin x, \cos x)$，则令 $u &#x3D; \cos x$，或凑 $d \cos x$。</p></li><li><p>若 $R(\sin x, -\cos x) &#x3D; -R(\sin x, \cos x)$，则令 $u &#x3D; \sin x$，或凑 $d \sin x$。</p></li><li><p>若 $R(-\sin x, -\cos x) &#x3D; R(\sin x, \cos x)$，则令 $u &#x3D; \tan x$，或凑 $d \tan x$。</p></li></ol><hr><h4 id="4-3-4-2-有理函数积分"><a href="#4-3-4-2-有理函数积分" class="headerlink" title="4.3.4.2 有理函数积分"></a>4.3.4.2 有理函数积分</h4><p><strong>（1）一般方法（部分分式法）</strong></p><p><strong>（2）特殊方法（加减拆项或凑微分降幂）</strong></p><p>对可积函数积分  $\int \frac{A x + b y x}{(x - 1)^p (x^2 + x + 1)^q} dx$</p><p>有<br>$\frac{A}{x - 1} + \frac{B}{(x - 1)^2} + \cdots + \frac{B}{ (x - 1)^p} + \frac{C_1 x + D_1}{x^2 + x + 1} + ··· +\frac{C_2 x + D_2}{(x^2 + x + 1)^q}$</p><ul><li>其中 $A x + b$ 只是一种形式，对拆分无影响。</li><li>分母中自变量系数与常量对拆分无影响。</li></ul><div class="note note-success">            <p>学基础篇</p><p>【例12】（2019，数二）求不定积分 $\int \frac{3x+6}{(x-1)^2(x^2+x+1)} dx$</p><p>令 $\frac{3x+6}{(x-1)^2(x^2+x+1)} &#x3D; \frac{A}{x-1} + \frac{B}{(x-1)^2} + \frac{Dx+E}{x^2+x+1}$，则<br>$3x+6 &#x3D; A(x-1)(x^2+x+1) + B(x^2+x+1) + (Dx+E)(x-1)^2$</p><p>所以<br>$$<br>\begin{cases}<br>A + D &#x3D; 0\\<br>B - 2D + E &#x3D; 0\\<br>B + D - 2E &#x3D; 3 \\<br>-A + B + E &#x3D; 6<br>\end{cases}<br>$$</p><p>解得<br>$$<br>\begin{cases}<br>A &#x3D; -2 \\<br>B &#x3D; 3\\<br>D &#x3D; 2 \\<br>E &#x3D; 1<br>\end{cases}<br>$$<br>则<br>$$<br>\begin{align*}<br>\int \frac{3x+6}{(x-1)^2(x^2+x+1)} dx &amp;&#x3D; \int \frac{-2}{x-1} dx + \int \frac{3}{(x-1)^2} dx + \int \frac{2x+1}{x^2+x+1} dx\\<br>&amp;&#x3D; -2 \ln |x-1| - \frac{3}{x-1} + \ln (x^2+x+1) + C<br>\end{align*}<br>$$</p>          </div><hr><h4 id="4-3-4-3-无理函数积分"><a href="#4-3-4-3-无理函数积分" class="headerlink" title="4.3.4.3 无理函数积分"></a>4.3.4.3 无理函数积分</h4><p>简单无理函数积分 $\int R\left( x, \sqrt{\frac{ax+b}{cx+d}} \right) dx$</p><p>令 $\sqrt{\frac{ax+b}{cx+d}}&#x3D;t$，将其化为有理函数积分进行计算。</p><div class="note note-success">            <p>计算 $\int \frac{1}{x} \sqrt{\frac{x+1}{x}} dx$。</p><p>解 【方法1】</p><p>令 $\sqrt{\frac{x+1}{x}}&#x3D;t$，则 $x&#x3D;\frac{1}{t^2-1}$，$dx&#x3D;-\frac{2t}{(t^2-1)^2} dt$，</p><p>$\int \frac{1}{x} \sqrt{\frac{x+1}{x}} dx $</p><p>$&#x3D; \int (t^2-1) t \frac{-2t}{(t^2-1)^2} dt$</p><p>$ &#x3D; -2 \int \left( 1+\frac{1}{t^2-1} \right) dt$</p><p>$&#x3D; -2 \left( t + \frac{1}{2} \ln \left| \frac{t-1}{t+1} \right| \right) + C$</p><p>$&#x3D; -2 \sqrt{1+\frac{1}{x}} - \ln \left| 2x + 1 - 2x \sqrt{1+\frac{1}{x}} \right| + C$</p><hr><p>【方法2】分子有理化。</p><p>$\int \frac{1}{x} \sqrt{\frac{x+1}{x}} dx$</p><p>$ &#x3D; \int \frac{x+1}{x \sqrt{x^2+x}} dx$</p><p>$&#x3D; \int \frac{d \left( x + \frac{1}{2} \right)}{\sqrt{\left( x + \frac{1}{2} \right)^2 - \frac{1}{4}}} + \int \frac{dx}{x^2 \sqrt{1+\frac{1}{x}}}$</p><p>$&#x3D; \ln \left| x + \frac{1}{2} + \sqrt{\left( x + \frac{1}{2} \right)^2 - \frac{1}{4}} \right| - \int \frac{d \left( 1 + \frac{1}{x} \right)}{\sqrt{1+\frac{1}{x}}}$</p><p>$&#x3D; \ln \left| x + \frac{1}{2} + \sqrt{x^2 + x} \right| - 2 \sqrt{1 + \frac{1}{x}} + C$</p>          </div><hr><h1 id="五、定积分"><a href="#五、定积分" class="headerlink" title="五、定积分"></a>五、定积分</h1><h2 id="5-1-定积分的几何意义"><a href="#5-1-定积分的几何意义" class="headerlink" title="5.1 定积分的几何意义"></a>5.1 定积分的几何意义</h2><p>(1) 设 $\int_a^b f(x) dx$ 存在，若在 $[a,b]$ 上 $f(x) \geq 0$，则 $\int_a^b f(x) dx$ 的值等于以曲线 $y &#x3D; f(x)$、$x &#x3D; a$、$x &#x3D; b$ 及 $x$ 轴所围成的曲边梯形的面积。</p><p>(2) 若在 $[a,b]$ 上 $f(x) \leq 0$，则 $\int_a^b f(x) dx$ 的值等于以曲线 $y &#x3D; f(x)$、$x &#x3D; a$、$x &#x3D; b$ 及 $x$ 轴所围成的曲边梯形面积的负值。</p><p>(3) 若在 $[a,b]$ 上 $f(x)$ 的值有正也有负，则 $\int_a^b f(x) dx$ 的值等于 $x$ 轴上方的面积减去 $x$ 轴下方的面积所得之差。</p><hr><h2 id="5-2-定积分的性质"><a href="#5-2-定积分的性质" class="headerlink" title="5.2 定积分的性质"></a>5.2 定积分的性质</h2><p><strong>1. 不等式性质</strong></p><p>(1) 若在区间 $[a,b]$ 上 $f(x) \leq g(x)$，则 $\int_{a}^{b} f(x) dx \leq \int_{a}^{b} g(x) dx$</p><p>(2) 若 $M$ 及 $m$ 分别是 $f(x)$ 在 $[a,b]$ 上的最大值和最小值，则  $$m(b-a) \leq \int_{a}^{b} f(x) dx \leq M(b-a)$$</p><p>(3) $\left| \int_{a}^{b} f(x) dx \right| \leq \int_{a}^{b} |f(x)| dx$</p><p><strong>2. 中值定理</strong></p><p><strong>(1)</strong> 若 $f(x)$ 在 $[a,b]$ 上连续，则 </p><p>$$\int_{a}^{b} f(x) dx &#x3D; f(\xi)(b-a) \quad (a &lt; \xi &lt; b)$$</p><p>常称 $\frac{1}{b-a} \int_{a}^{b} f(x) dx$ 为函数 $y &#x3D; f(x)$ 在区间 $[a,b]$ 上的<strong>平均值</strong></p><p><strong>(2)</strong> 若 $f(x), g(x)$ 在 $[a,b]$ 上连续，$g(x)$ 不变号，则 </p><p>$$\int_{a}^{b} f(x) g(x) dx &#x3D; f(\xi) \int_{a}^{b} g(x) dx \quad (a \leq \xi \leq b)$$</p><p><strong>定理</strong> 设$f(x)$在 $[-L,L]$ 上连续，则 </p><p>如果$f(x)$为奇函数，那么  $\int_{0}^{x} f(t) dt$为偶函数</p><p>如果 $f(x)$ 为偶函数，那么 $\int_{0}^{x} f(t) dt$ 必为奇函数。</p><h2 id="5-3-积分上限的函数"><a href="#5-3-积分上限的函数" class="headerlink" title="5.3 积分上限的函数"></a>5.3 积分上限的函数</h2><p>变上限的积分 $\int_{a}^{x} f(t) dt$ 是其上限 $x$ 的函数，常称之为积分上限函数。</p><p><strong>定理</strong> 如果 $f(x)$ 在区间 $[a,b]$ 上连续，则 $\Phi(x) &#x3D; \int_{a}^{x} f(t) dt$ 在 $[a,b]$ 上可导，且 $\frac{d\Phi(x)}{dx} &#x3D; f(x)$</p><p>&emsp;&emsp;由原函数的概念可知，如果 $f(x)$ 在区间 $[a,b]$ 上连续，则 $\Phi(x) &#x3D; \int_{a}^{x} f(t) dt$ 为 $f(x)$ 在区间 $[a,b]$ 上的一个原函数。由此可知，连续函数必有原函数。</p><p><strong>【注】</strong> 如果 $f(x)$ 为 $[a,b]$ 上的连续函数，$\varphi_1(x), \varphi_2(x)$ 为可导函数，则 （积分求导）<br>$$\left( \int_{\varphi_1(x)}^{\varphi_2(x)} f(t) dt \right)’ &#x3D; f[\varphi_2(x)] \cdot \varphi_2’(x) - f[\varphi_1(x)] \cdot \varphi_1’(x)$$</p><hr><h2 id="5-4-定积分的积分方法"><a href="#5-4-定积分的积分方法" class="headerlink" title="5.4 定积分的积分方法"></a>5.4 定积分的积分方法</h2><p>定积分的计算主要有以下五种方法：</p><h3 id="5-4-1-牛顿—莱布尼茨公式"><a href="#5-4-1-牛顿—莱布尼茨公式" class="headerlink" title="5.4.1 牛顿—莱布尼茨公式"></a>5.4.1 牛顿—莱布尼茨公式</h3><p>设 $f(x)$ 在区间 $[a,b]$ 上连续，$F(x)$ 为 $f(x)$ 在 $[a,b]$ 上的一个原函数，则有<br>$$<br>\int_a^b f(x) dx &#x3D; F(x) \bigg|_a^b &#x3D; F(b) - F(a)。<br>$$</p><h3 id="5-4-2-换元积分法"><a href="#5-4-2-换元积分法" class="headerlink" title="5.4.2 换元积分法"></a>5.4.2 换元积分法</h3><p>设 $f(x)$ 在区间 $I$ 上连续，函数 $x &#x3D; \varphi(t)$ 满足以下条件：  </p><ol><li>$\varphi(\alpha) &#x3D; a, \varphi(\beta) &#x3D; b$。  </li><li>$\varphi(t)$ 在 $[\alpha,\beta]$（或 $[\beta,a]$）上有连续导数，且 $R_\varphi \subseteq I$，则</li></ol><p>$$<br>\int_a^b f(x) dx &#x3D; \int_\alpha^\beta f[\varphi(t)] \varphi’(t) dt。<br>$$</p><h3 id="5-4-3-分部积分法"><a href="#5-4-3-分部积分法" class="headerlink" title="5.4.3 分部积分法"></a>5.4.3 分部积分法</h3><p>$$<br>\int_a^b u dv &#x3D; uv \bigg|_a^b - \int_a^b v du。<br>$$</p><h3 id="5-4-4-利用奇偶性和周期性"><a href="#5-4-4-利用奇偶性和周期性" class="headerlink" title="5.4.4 利用奇偶性和周期性"></a>5.4.4 利用奇偶性和周期性</h3><p>(1) 设 $f(x)$ 为 $[-a,a]$ 上的连续函数 ($a&gt;0$)，则<br>$$<br>\int_{-a}^{a} f(x) dx &#x3D;<br>\begin{cases}<br>0, &amp; f(x) \text{为奇函数时}, \\<br>2 \int_{0}^{a} f(x) dx, &amp; f(x) \text{为偶函数时}.<br>\end{cases}<br>$$</p><p>(2) 设 $f(x)$ 是以 $T$ 为周期的连续函数，则对任给数 $a$，总有<br>$$<br>\int_{a}^{a+T} f(x) dx &#x3D; \int_{0}^{T} f(x) dx.<br>$$</p><h3 id="5-4-5-利用已有公式"><a href="#5-4-5-利用已有公式" class="headerlink" title="5.4.5 利用已有公式"></a>5.4.5 利用已有公式</h3><p>(1)<br>$$<br>\int_{0}^{\frac{\pi}{2}} \sin^n x dx &#x3D; \int_{0}^{\frac{\pi}{2}} \cos^n x dx &#x3D;<br>\begin{cases}<br>\frac{n-1}{n} \cdot \frac{n-3}{n-2} \cdots \frac{1}{2} \cdot \frac{\pi}{2}, &amp; n \text{为正偶数}\\<br>\frac{n-1}{n} \cdot \frac{n-3}{n-2} \cdots \frac{2}{3}, &amp; n \text{为大于1的奇数}<br>\end{cases}<br>$$</p><p>(2)<br>$$<br>\int_{0}^{\pi} x f(\sin x) dx &#x3D; \frac{\pi}{2} \int_{0}^{\pi} f(\sin x) dx \quad (\text{其中} f(x) \text{连续}).<br>$$</p><hr><h1 id="六、反常积分"><a href="#六、反常积分" class="headerlink" title="六、反常积分"></a>六、反常积分</h1><h3 id="6-1-无穷区间上的反常积分"><a href="#6-1-无穷区间上的反常积分" class="headerlink" title="6.1 无穷区间上的反常积分"></a>6.1 无穷区间上的反常积分</h3><p><strong>定义</strong>  </p><p>(1) 设 $f(x)$ 为 $[a, +\infty)$ 上的连续函数，如果极限 $\lim\limits_{x \to +\infty} \int_a^x f(x) dx$ 存在，则称原函数 $f(x)$ 在无穷区间 $[a, +\infty)$ 上的<strong>反常积分</strong>，记作 $\int_a^{+\infty} f(x) dx$<br>$$\int_a^{+\infty} f(x) dx &#x3D; \lim\limits_{x \to +\infty} \int_a^x f(x) dx$$<br>这时也称反常积分 $\int_a^{+\infty} f(x) dx$ 收敛。如果上述极限不存在，则称反常积分 $\int_a^{+\infty} f(x) dx$ 发散。</p><p>(2) 设 $f(x)$ 为 $(-\infty, b]$ 上的连续函数，则可类似的定义函数 $f(x)$ 在无穷区间 $(-\infty, b]$ 上的反常积分<br>$$\int_{-\infty}^b f(x) dx &#x3D; \lim\limits_{x \to -\infty} \int_b^x f(x) dx$$</p><p>(3) 设 $f(x)$ 为 $(-\infty, +\infty)$ 上的连续函数，如果反常积分<br>$$\int_{-\infty}^0 f(x) dx$ 和 $\int_0^{+\infty} f(x) dx$$<br>都收敛，则称反常积分 $\int_{-\infty}^{+\infty} f(x) dx$ <strong>收敛</strong>，且<br>$$\int_{-\infty}^{+\infty} f(x) dx &#x3D; \int_{-\infty}^0 f(x) dx + \int_0^{+\infty} f(x) dx$$<br>如果 $\int_{-\infty}^0 f(x) dx$ 与 $\int_0^{+\infty} f(x) dx$ 至少有一个发散，则称 $\int_{-\infty}^{+\infty} f(x) dx$ <strong>发散</strong>。</p><hr><p><strong>定理 1（比较判别法）</strong></p><p>设 $f(x), g(x)$ 在 $[a, +\infty)$ 上连续，且 $0 \leq f(x) \leq g(x)$，则  </p><p>(1) 当 $\int_a^{+\infty} g(x) dx$ 收敛时，$\int_a^{+\infty} f(x) dx$ 收敛。</p><p>(2) 当 $\int_a^{+\infty} f(x) dx$ 发散时，$\int_a^{+\infty} g(x) dx$ 发散。</p><hr><p><strong>定理 2（比较判别法的极限形式）</strong></p><p>设 $f(x), g(x)$ 在 $[a, +\infty)$ 上非负连续，且 $\lim\limits_{x \to +\infty} \frac{f(x)}{g(x)} &#x3D; \lambda$（有限或无穷），则  </p><p>(1) 当 $\lambda \neq 0$ 时，$\int_a^{+\infty} f(x) dx$ 与 $\int_a^{+\infty} g(x) dx$ 同敛散。</p><p>(2) 当 $\lambda &#x3D; 0$ 时，若 $\int_a^{+\infty} g(x) dx$ 收敛，则 $\int_a^{+\infty} f(x) dx$ 也收敛。</p><p>(3) 当 $\lambda &#x3D; +\infty$ 时，若 $\int_{a}^{+\infty} g(x) dx$ 发散，则 $\int_{a}^{+\infty} f(x) dx$ 也发散。</p><p>常用结论：<br>$$<br>\int_{a}^{+\infty} \frac{1}{x^p} dx<br>\begin{cases}<br>p &gt; 1，收敛\\ p \leq 1$，发散<br>\end{cases}<br>\quad (a &gt; 0)<br>$$</p><hr><h3 id="6-2-无界函数的反常积分"><a href="#6-2-无界函数的反常积分" class="headerlink" title="6.2 无界函数的反常积分"></a>6.2 无界函数的反常积分</h3><p>&emsp;如果函数 $f(x)$ 在点 $a$ 的任一邻域内都无界，那么点 $a$ 称为函数 $f(x)$ 的<strong>瑕点</strong>（也称为<strong>无界点</strong>）。无界函数的反常积分也称为瑕积分。</p><p><strong>定义</strong><br>(1) 设函数 $f(x)$ 在 $[a,b]$ 上连续，点 $a$ 为函数 $f(x)$ 的瑕点。如果极限<br>$$\lim\limits_{t \to a^+} \int_t^b f(x) dx$$<br>存在，则称此极限为函数 $f(x)$ 在区间 $[a,b]$ 上的反常积分，记作<br>$\int_a^b f(x) dx$，即<br>$$\int_a^b f(x) dx &#x3D; \lim\limits_{t \to a^+} \int_t^b f(x) dx$$<br>这时也称反常积分 $\int_a^b f(x) dx$ 收敛。如果上述极限不存在，则称反常积分 $\int_a^b f(x) dx$ 发散。</p><p>(2) 设函数 $f(x)$ 在 $[a,b]$ 上连续，点 $b$ 为函数 $f(x)$ 的瑕点。则可类似的定义函数 $f(x)$ 在区间 $[a,b]$ 上的反常积分<br>$$\int_a^b f(x) dx &#x3D; \lim\limits_{t \to b^-} \int_a^t f(x) dx$$</p><p>(3) 设函数 $f(x)$ 在 $[a,b]$ 上除点 $c(a &lt; c &lt; b)$ 外连续，点 $c$ 为函数 $f(x)$ 的瑕点。如果反常积分<br>$$\int_a^c f(x) dx   和 \int_c^b f(x) dx$$<br>都收敛，则称反常积分 $\int_a^b f(x) dx$ 收敛，且<br>$$\int_a^b f(x) dx &#x3D; \int_a^c f(x) dx + \int_c^b f(x) dx$$<br>如果 $\int_a^c f(x) dx$ 与 $\int_c^b f(x) dx$ 至少有一个发散，则称 $\int_a^b f(x) dx$ 发散。</p><hr><p><strong>定理 1（比较判别法）</strong></p><p>设 $f(x), g(x)$ 在 $[a,b]$ 上连续，且 $0 \leq f(x) \leq g(x)$，$x &#x3D; a$ 为 $f(x)$ 和 $g(x)$ 的瑕点，则  </p><p>(1) 当 $\int_a^b g(x) dx$ 收敛时，$\int_a^b f(x) dx$ 收敛。</p><p>(2) 当 $\int_a^b f(x) dx$ 发散时，$\int_a^b g(x) dx$ 发散。</p><hr><p><strong>定理 2（比较判别法的极限形式）</strong></p><p>设 $f(x), g(x)$ 在 $[a,b]$ 上非负连续，且 $\lim\limits_{x \to a^+} \frac{f(x)}{g(x)} &#x3D; \lambda$（有限或无穷），则  </p><p>(1) 当 $\lambda \neq 0$ 时，$\int_a^b f(x) dx$ 与 $\int_a^b g(x) dx$ 同敛散。</p><p>(2) 当 $\lambda &#x3D; 0$ 时，若 $\int_a^b g(x) dx$ 收敛，则 $\int_a^b f(x) dx$ 也收敛。</p><p>(3) 当 $\lambda &#x3D; +\infty$ 时，若 $\int_a^b g(x) dx$ 发散，则 $\int_a^b f(x) dx$ 也发散。</p><hr><p>常用结论：<br>$$<br>\int_a^b \frac{1}{(x-a)^p} dx<br>\begin{cases}<br>p&lt;1, \text{收敛}\\<br>p\geq 1, \text{发散}<br>\end{cases}<br>$$</p><p>$$<br>\int_a^b \frac{1}{(b-x)^p}dx<br>\begin{cases}<br>p&lt;1, \text{收敛}\\<br>p\geq 1, \text{发散}<br>\end{cases}<br>$$</p><hr><a href="/2025/06/28/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/" title="高数基础知识（上）">高数基础知识（上）</a>]]></content>
    
    
    <categories>
      
      <category>上岸</category>
      
      <category>高数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring、springboot、springCloud</title>
    <link href="/2025/06/28/java/spring%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    <url>/2025/06/28/java/spring%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>Spring、Spring Boot 和 Spring Cloud 是 Spring 生态系统中三个关键的技术栈，它们各自有不同的定位，但又紧密关联。以下是它们之间的关系和区别：</p><hr><h3 id="1-Spring（核心框架）"><a href="#1-Spring（核心框架）" class="headerlink" title="1. Spring（核心框架）"></a><strong>1. Spring（核心框架）</strong></h3><p><strong>定位</strong>：Spring 是一个轻量级的 Java 开发框架，最初的核心功能是 <strong>IoC（控制反转）</strong> 和 <strong>AOP（面向切面编程）</strong>，用于解耦和管理 Java 对象（Bean）的生命周期。<br><strong>扩展功能</strong>：Spring 后续发展出 <strong>Spring MVC（Web 开发）</strong>、<strong>Spring Data（数据访问）</strong>、<strong>Spring Security（安全）</strong> 等模块，覆盖企业级开发的各个方面。<br><strong>特点</strong>：</p><ul><li>提供灵活的配置方式（XML &#x2F; 注解）。</li><li>需要手动配置大量 Bean 和依赖管理。</li></ul><hr><h3 id="2-Spring-Boot（简化-Spring-开发）"><a href="#2-Spring-Boot（简化-Spring-开发）" class="headerlink" title="2. Spring Boot（简化 Spring 开发）"></a><strong>2. Spring Boot（简化 Spring 开发）</strong></h3><p><strong>定位</strong>：Spring Boot 是 <strong>Spring 的扩展</strong>，旨在简化 Spring 应用的初始搭建和开发过程，减少样板代码和配置。<br><strong>核心特性</strong>：</p><ul><li><strong>自动配置</strong>（Auto Configuration）：根据依赖自动配置 Spring 应用（如引入 <code>spring-boot-starter-web</code> 自动配置 Tomcat + Spring MVC）。</li><li><strong>内嵌服务器</strong>（如 Tomcat、Jetty），无需部署到外部容器，直接打包成可执行 JAR 运行。</li><li><strong>起步依赖（Starters）</strong>：预定义的依赖组合（如 <code>spring-boot-starter-data-jpa</code> 自动引入 Hibernate + JPA 相关库）。</li><li><strong>Actuator</strong>：提供应用监控和管理端点（如健康检查、性能指标）。</li></ul><p><strong>与 Spring 的关系</strong>：</p><ul><li>Spring Boot <strong>基于 Spring</strong>，但通过约定优于配置（Convention over Configuration）大幅减少手动配置。</li><li><strong>不替代 Spring</strong>，而是让 Spring 更易用。</li></ul><hr><h3 id="3-Spring-Cloud（分布式微服务解决方案）"><a href="#3-Spring-Cloud（分布式微服务解决方案）" class="headerlink" title="3. Spring Cloud（分布式微服务解决方案）"></a><strong>3. Spring Cloud（分布式微服务解决方案）</strong></h3><p><strong>定位</strong>：Spring Cloud <strong>基于 Spring Boot</strong>，提供一套完整的 <strong>微服务架构工具集</strong>，用于构建和管理分布式系统。<br><strong>核心功能</strong>：</p><ul><li><strong>服务注册与发现</strong>（Eureka、Consul、Nacos）。</li><li><strong>负载均衡</strong>（Ribbon）。</li><li><strong>熔断器</strong>（Hystrix &#x2F; Resilience4j）。</li><li><strong>分布式配置中心</strong>（Spring Cloud Config）。</li><li><strong>API 网关</strong>（Spring Cloud Gateway &#x2F; Zuul）。</li></ul><p><strong>与 Spring Boot 的关系</strong>：</p><ul><li><strong>依赖关系</strong>：Spring Cloud <strong>必须基于 Spring Boot</strong>，利用其自动配置和快速启动能力。</li><li><strong>互补关系</strong>：<ul><li>Spring Boot 用于 <strong>快速开发单个微服务</strong>。</li><li>Spring Cloud 用于 <strong>协调和管理多个微服务</strong>（如服务调用、容错、配置同步）。</li></ul></li></ul><hr><h3 id="4-三者的层级关系"><a href="#4-三者的层级关系" class="headerlink" title="4. 三者的层级关系"></a><strong>4. 三者的层级关系</strong></h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">Spring (IoC/AOP) → Spring Boot (简化开发) → Spring Cloud (分布式扩展)<br></code></pre></td></tr></table></figure><ol><li><strong>Spring</strong> 提供最基础的 Bean 管理和企业级开发能力。</li><li><strong>Spring Boot</strong> 在 Spring 基础上提供快速开发支持（自动配置、内嵌服务器）。</li><li><strong>Spring Cloud</strong> 在 Spring Boot 基础上扩展，提供 <strong>微服务治理</strong>（服务发现、熔断、配置管理等）。</li></ol><hr><h3 id="5-实际应用场景"><a href="#5-实际应用场景" class="headerlink" title="5. 实际应用场景"></a><strong>5. 实际应用场景</strong></h3><ul><li><strong>单体应用</strong>：仅需 <strong>Spring Boot</strong>（如后台管理系统、小型 REST API）。</li><li><strong>微服务架构</strong>：<strong>Spring Boot + Spring Cloud</strong>（如电商系统，拆分为用户服务、订单服务、支付服务等）。</li><li><strong>传统企业应用</strong>：可能仅使用 <strong>Spring</strong>（如旧系统逐步迁移到 Spring Boot）。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table><thead><tr><th>技术</th><th>核心目标</th><th>依赖关系</th><th>典型应用场景</th></tr></thead><tbody><tr><td><strong>Spring</strong></td><td>提供企业级 Java 开发框架</td><td>无</td><td>传统 Java EE 应用</td></tr><tr><td><strong>Spring Boot</strong></td><td>简化 Spring 开发</td><td>基于 Spring</td><td>快速开发单体&#x2F;微服务</td></tr><tr><td><strong>Spring Cloud</strong></td><td>微服务治理</td><td>基于 Spring Boot</td><td>分布式系统架构</td></tr></tbody></table><p>三者共同构成了 Spring 生态的完整解决方案，适用于从传统应用到现代云原生架构的不同需求。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高数基础知识（上）</title>
    <link href="/2025/06/28/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/"/>
    <url>/2025/06/28/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="一、极限"><a href="#一、极限" class="headerlink" title="一、极限"></a>一、极限</h1><h2 id="1-1-常见左右极限问题"><a href="#1-1-常见左右极限问题" class="headerlink" title="1.1 常见左右极限问题"></a>1.1 常见左右极限问题</h2><p><strong>定义</strong> <strong>左极限：</strong>若对任意给定的 $\varepsilon &gt; 0$，总存在 $\delta &gt; 0$，使得当 $x_0 - \delta &lt; x &lt; x_0$ 时，恒有 $|f(x) - A| &lt; \varepsilon$，则称 $A$ 为 $f(x)$ 在 $x \to x_0^-$ 时的左极限，记为<br>$$<br>\lim\limits_{x \to x_0^-} f(x) &#x3D; A, \quad \text{或} \quad f(x_0^-) &#x3D; A.<br>$$</p><p><strong>右极限</strong> 若对任意给定的 $\varepsilon &gt; 0$，总存在 $\delta &gt; 0$，使得当 $x_0 &lt; x &lt; x_0 + \delta$ 时，恒有 $|f(x) - A| &lt; \varepsilon$，则称 $A$ 为 $f(x)$ 在 $x \to x_0^+$ 时的右极限，记为<br>$$<br>\lim\limits_{x \to x_0^+} f(x) &#x3D; A, \quad \text{或} \quad f(x_0^+) &#x3D; A.<br>$$</p><p><strong>定理</strong> 极限 $\lim\limits_{x \to x_0} f(x)$ 存在的充要条件是：<br> 左极限 $\lim\limits_{x \to x_0^-} f(x)$ 与右极限 $\lim\limits_{x \to x_0^+} f(x)$ <strong>存在且相等</strong>。</p><hr><p><strong>注：需分左右极限的情形</strong> 以下三类问题需分别计算左、右极限：</p><ol><li><strong>分段函数</strong>在分界点处的极限（如 $\lim\limits_{x \to 0} \frac{|x|}{x}$）；</li><li><strong>$e^\infty$ 型极限</strong>：<ul><li>$\lim\limits_{x \to 0^-} e^{1&#x2F;x} &#x3D; 0$，$\lim\limits_{x \to 0^+} e^{1&#x2F;x} &#x3D; +\infty$；</li><li>$\lim\limits_{x \to -\infty} e^x &#x3D; 0$，$\lim\limits_{x \to +\infty} e^x &#x3D; +\infty$；</li></ul></li><li><strong>$\arctan \infty$ 型极限</strong>：<ul><li>$\lim\limits_{x \to 0^-} \arctan \frac{1}{x} &#x3D; -\frac{\pi}{2}$，$\lim\limits_{x \to 0^+} \arctan \frac{1}{x} &#x3D; \frac{\pi}{2}$；</li><li>$\lim\limits_{x \to -\infty} \arctan x &#x3D; -\frac{\pi}{2}$，$\lim\limits_{x \to +\infty} \arctan x &#x3D; \frac{\pi}{2}$。</li></ul></li></ol><hr><div class="note note-success">            <p>例题</p><p>（1992年，数一&#x2F;二&#x2F;三）当 $x \to 1$ 时，函数 $\frac{x^2-1}{x-1} e^{1&#x2F;(x-1)}$ 的极限<br>(A) 等于 2 (B) 等于 0 (C) 为 $\infty$ (D) 不存在但不为 $\infty$  </p><p><strong>解析</strong></p><ol><li><strong>左极限</strong>：<br>$$<br>\lim\limits_{x \to 1^-} \frac{x^2-1}{x-1} e^{1&#x2F;(x-1)} &#x3D; \lim\limits_{x \to 1^-} (x+1) e^{1&#x2F;(x-1)} &#x3D; 2 \cdot 0 &#x3D; 0.<br>$$</li><li><strong>右极限</strong>：<br>$$<br>\lim\limits_{x \to 1^+} \frac{x^2-1}{x-1} e^{1&#x2F;(x-1)} &#x3D; \lim\limits_{x \to 1^+} (x+1) e^{1&#x2F;(x-1)} &#x3D; 2 \cdot +\infty &#x3D; +\infty.<br>$$<br><strong>结论</strong>：左右极限不相等，且一侧为无穷，故极限不存在且不为 $\infty$。正确答案为 <strong>D</strong>。</li></ol>          </div><h2 id="1-2-无穷小量"><a href="#1-2-无穷小量" class="headerlink" title="1.2 无穷小量"></a>1.2 无穷小量</h2><h4 id="1-2-1-无穷小量的概念"><a href="#1-2-1-无穷小量的概念" class="headerlink" title="1.2.1 无穷小量的概念"></a>1.2.1 无穷小量的概念</h4><p>若函数 $f(x)$ 当 $x \to x_0$（或 $x \to \infty$）时的极限为零，则称 $f(x)$ 为 $x \to x_0$（或 $x \to \infty$）的<strong>无穷小量</strong>。</p><h4 id="1-2-2-无穷小的比较"><a href="#1-2-2-无穷小的比较" class="headerlink" title="1.2.2 无穷小的比较"></a>1.2.2 无穷小的比较</h4><p>设 $\lim \alpha(x) &#x3D; 0$，$\lim \beta(x) &#x3D; 0$，且 $\beta(x) \neq 0$。  </p><ol><li><strong>高阶</strong>：若 $\lim \frac{\alpha(x)}{\beta(x)} &#x3D; 0$，记为 $\alpha(x) &#x3D; o(\beta(x))$。  </li><li><strong>低阶</strong>：若 $\lim \frac{\alpha(x)}{\beta(x)} &#x3D; \infty$。  </li><li><strong>同阶</strong>：若 $\lim \frac{\alpha(x)}{\beta(x)} &#x3D; C \neq 0$。  </li><li><strong>等价</strong>：若 $\lim \frac{\alpha(x)}{\beta(x)} &#x3D; 1$，记为 $\alpha(x) \sim \beta(x)$。  </li><li><strong>无穷小的阶</strong>：若 $\lim \frac{\alpha(x)}{[\beta(x)]^k} &#x3D; C \neq 0$，则称 $\alpha(x)$ 是 $\beta(x)$ 的 $k$ 阶无穷小。</li></ol><hr><div class="note note-success">            <p>（2013, 数二）设 $\cos x - 1 &#x3D; x \sin \alpha(x)$，其中 $|\alpha(x)| &lt; \frac{\pi}{2}$，则当 $x \to 0$ 时，$\alpha(x)$ 是<br>(A) 比 $x$ 高阶的无穷小量。<br>(B) 比 $x$ 低阶的无穷小量。<br>(C) 与 $x$ 同阶但不等价的无穷小量。<br>(D) 与 $x$ 等价的无穷小量。</p><p><strong>解析</strong>：  </p><ol><li><p>已知当 $x \to 0$ 时，$\cos x - 1 \sim -\frac{1}{2}x^2$，因此：<br>$$<br>-\frac{1}{2}x^2 &#x3D; x \sin \alpha(x) \implies \sin \alpha(x) &#x3D; -\frac{1}{2}x.<br>$$</p></li><li><p>由 $|\alpha(x)| &lt; \frac{\pi}{2}$ 及 $\sin \alpha(x) \sim \alpha(x)$（当 $x \to 0$），得：<br>$$<br>\alpha(x) \sim -\frac{1}{2}x.<br>$$</p></li><li><p>故 $\alpha(x)$ 与 $x$ 同阶但不等价（系数为 $-\frac{1}{2} \neq 1$）。</p><p><strong>选择C</strong></p></li></ol>          </div><hr><h2 id="1-3-无穷大量"><a href="#1-3-无穷大量" class="headerlink" title="1.3 无穷大量"></a>1.3 无穷大量</h2><h3 id="1-3-1-无穷大量的性质"><a href="#1-3-1-无穷大量的性质" class="headerlink" title="1.3.1 无穷大量的性质"></a>1.3.1 无穷大量的性质</h3><ol><li>两个无穷大量的积仍为无穷大量。  </li><li>无穷大量与有界变量之和仍为无穷大量。</li></ol><h3 id="1-3-2-无穷大量与无界变量的关系"><a href="#1-3-2-无穷大量与无界变量的关系" class="headerlink" title="1.3.2 无穷大量与无界变量的关系"></a>1.3.2 无穷大量与无界变量的关系</h3><p>以数列为例说明两者的关系：  </p><ul><li><strong>无穷大量</strong>的定义：<br>对任意 $M &gt; 0$，存在 $N &gt; 0$，当 $n &gt; N$ 时，恒有 $|x_n| &gt; M$。  </li><li><strong>无界变量</strong>的定义：<br>对任意 $M &gt; 0$，存在某个 $N$，使得 $|x_N| &gt; M$。</li></ul><p><strong>结论</strong>：  </p><ul><li>无穷大量必为无界变量。  </li><li>无界变量不一定是无穷大量。</li></ul><hr><div class="note note-success">            <p>证明数列<br>$$<br>x_n &#x3D; \begin{cases} n, &amp; n \text{为奇数}, \\ 0, &amp; n \text{为偶数}\end{cases}<br>$$<br>是无界变量但不是无穷大量。  </p><p><strong>证明</strong>：  </p><ol><li><strong>无界性</strong>：<br>对任意 $M &gt; 0$，取奇数 $n &gt; M$，则 $x_n &#x3D; n &gt; M$，故数列无界。  </li><li><strong>非无穷大量</strong>：<br>对任意 $N &gt; 0$，总存在偶数 $n &gt; N$（如 $n &#x3D; N+1$ 或 $N+2$），使得 $x_n &#x3D; 0$，不满足 $|x_n| &gt; M$ 对所有 $n &gt; N$ 成立。因此数列不是无穷大量。</li></ol>          </div><hr><h2 id="1-4-常用的求极限方法（8种）"><a href="#1-4-常用的求极限方法（8种）" class="headerlink" title="1.4 常用的求极限方法（8种）"></a>1.4 常用的求极限方法（8种）</h2><h3 id="1-4-1-利用基本极限求极限"><a href="#1-4-1-利用基本极限求极限" class="headerlink" title="1.4.1 利用基本极限求极限"></a>1.4.1 利用基本极限求极限</h3><p><strong>(1) 常用的基本极限</strong>  </p><ul><li>$\lim\limits_{x \to 0} \frac{\sin x}{x} &#x3D; 1$  </li><li>$\lim\limits_{x \to 0} (1 + x)^{\frac{1}{x}} &#x3D; e$  </li><li>$\lim\limits_{x \to \infty} \left(1 + \frac{1}{x}\right)^x &#x3D; e$  </li><li>$\lim\limits_{x \to 0} \frac{a^x - 1}{x} &#x3D; \ln a$  </li><li>$\lim\limits_{n \to \infty} \sqrt[n]{n} &#x3D; 1$  </li><li>$\lim\limits_{n \to \infty} \sqrt[n]{a} &#x3D; 1 \quad (a &gt; 0)$</li></ul><p><strong>有理分式极限</strong>：<br>$$<br>\lim_{x \to \infty} \frac{a_n x^n + \cdots + a_0}{b_m x^m + \cdots + b_0} &#x3D;<br>\begin{cases}<br>\frac{a_n}{b_m}, &amp; n &#x3D; m, \\<br>0, &amp; n &lt; m, \\<br>\infty, &amp; n &gt; m.<br>\end{cases}<br>$$</p><p><strong>幂函数极限</strong>：<br>$$<br>\lim_{n \to \infty} x^n &#x3D;<br>\begin{cases}<br>0, &amp; |x| &lt; 1, \\<br>\infty, &amp; |x| &gt; 1, \\<br>1, &amp; x &#x3D; 1, \\<br>\text{不存在}, &amp; x &#x3D; -1.<br>\end{cases}<br>$$</p><p><strong>指数函数极限</strong>：<br>$$<br>\lim_{n \to \infty} e^{nx} &#x3D;<br>\begin{cases}<br>0, &amp; x &lt; 0, \\<br>+\infty, &amp; x &gt; 0, \\<br>1, &amp; x &#x3D; 0.<br>\end{cases}<br>$$</p><p><strong>(2) “$1^\infty$”型极限常用结论</strong>  </p><p>若 $\lim \alpha(x) &#x3D; 0$，$\lim \beta(x) &#x3D; \infty$，且 $\lim \alpha(x) \beta(x) &#x3D; A$，则<br>$$<br>\lim [1 + \alpha(x)]^{\beta(x)} &#x3D; e^A.<br>$$</p><div class="note note-primary">            <p><strong>解题步骤</strong>：  </p><ol><li>写标准形式：原式 $&#x3D; \lim [1 + \alpha(x)]^{\beta(x)}$。  </li><li>求极限：$\lim \alpha(x) \beta(x) &#x3D; A$。  </li><li>写结果：原式 $&#x3D; e^A$。</li></ol>          </div><hr><h3 id="1-4-2-利用等价无穷小代换求极限"><a href="#1-4-2-利用等价无穷小代换求极限" class="headerlink" title="1.4.2 利用等价无穷小代换求极限"></a>1.4.2 利用等价无穷小代换求极限</h3><p><strong>(1) 代换原则</strong></p><ol><li><p><strong>乘除关系可以换</strong>：<br>若 $\alpha \sim \alpha_1$, $\beta \sim \beta_1$，则<br>$$\lim \frac{\alpha}{\beta} &#x3D; \lim \frac{\alpha_1}{\beta} &#x3D; \lim \frac{\alpha}{\beta_1} &#x3D; \lim \frac{\alpha_1}{\beta_1}.$$</p></li><li><p><strong>加减关系在一定条件下可以换</strong>：  </p><ul><li>若 $\alpha \sim \alpha_1$, $\beta \sim \beta_1$，且 $\lim \frac{\alpha_1}{\beta_1} &#x3D; A \neq 1$，则 $\alpha - \beta \sim \alpha_1 - \beta_1$。  </li><li>若 $\alpha \sim \alpha_1$, $\beta \sim \beta_1$，且 $\lim \frac{\alpha_1}{\beta_1} &#x3D; A \neq -1$，则 $\alpha + \beta \sim \alpha_1 + \beta_1$。</li></ul></li></ol><ul><li><strong>等价无穷小代换需验证条件（如 $\alpha(x)\beta(x) \to 0$）。</strong>  </li><li><strong>乘除运算可直接代换，加减运算需谨慎（需满足系数不等条件）。</strong></li></ul><p><strong>(2) 常用的等价无穷小（当 $x \to 0$ 时）</strong></p><ul><li><p><strong>基本等价</strong>：<br>$$x \sim \sin x \sim \tan x \sim \arcsin x \sim \arctan x \sim \ln(1+x) \sim e^x - 1,$$<br>$$(1+x)^\alpha - 1 \sim \alpha x \ (\alpha \neq 0), \quad 1 - \cos x \sim \frac{1}{2}x^2, \quad a^x - 1 \sim x \ln a.$$  </p></li><li><p><strong>高阶等价</strong>：<br>$$x - \sin x \sim \frac{1}{6}x^3, \quad \tan x - x \sim \frac{1}{3}x^3, \quad x - \ln(1+x) \sim \frac{1}{2}x^2,$$<br>$$\arcsin x - x \sim \frac{1}{6}x^3, \quad x - \arctan x \sim \frac{1}{3}x^3.$$</p></li></ul><hr><div class="note note-success">            <p>（2016，数三）已知函数 $f(x)$ 满足<br>$$\lim\limits_{x \to 0} \frac{\sqrt{1 + f(x)} \sin 2x - 1}{e^{3x} - 1} &#x3D; 2,$$<br>则求 $\lim\limits_{x \to 0} f(x)$。  </p><p><strong>解析</strong>：  </p><ol><li>由 $\lim\limits_{x \to 0} (e^{3x} - 1) &#x3D; 0$ 及极限存在，得分子极限必为 0：<br>$$\lim\limits_{x \to 0} \left(\sqrt{1 + f(x)} \sin 2x - 1\right) &#x3D; 0.$$  </li><li>利用等价无穷小代换：  <ul><li>$e^{3x} - 1 \sim 3x$，  </li><li>$\sqrt{1 + f(x)} \sin 2x - 1 \sim \frac{1}{2} f(x) \sin 2x$（当 $f(x) \to 0$ 时）。</li></ul></li><li>代入极限式：<br>$$\lim\limits_{x \to 0} \frac{\frac{1}{2} f(x) \sin 2x}{3x} &#x3D; 2 \implies \lim\limits_{x \to 0} \frac{f(x) \cdot 2x}{6x} &#x3D; 2 \implies \lim\limits_{x \to 0} f(x) &#x3D; 6.$$<br><strong>结论</strong>：$\lim\limits_{x \to 0} f(x) &#x3D; 6$。</li></ol>          </div><hr><div class="note note-success">            <p><strong>极限计算示例</strong></p><p>计算极限：<br>$$<br>\lim\limits_{x \to 0} \frac{x (\cos x - 1)}{3}<br>$$</p><p><strong>解题过程</strong>：</p><ol><li><p>利用等价无穷小代换（当 $x \to 0$ 时）：</p><ul><li>$\cos x - 1 \sim -\frac{1}{2}x^2$</li></ul></li><li><p>代入化简：<br>$$<br>\lim\limits_{x \to 0} \frac{x (\cos x - 1)}{3} &#x3D; \lim\limits_{x \to 0} \frac{-\frac{1}{2}x^3}{3} &#x3D; \lim\limits_{x \to 0} \left(-\frac{x^3}{6}\right) &#x3D; 0.<br>$$<br><strong>注</strong>：上述步骤有误，正确过程如下：</p></li><li><p>重新计算：<br>$$<br>\lim\limits_{x \to 0} \frac{x (\cos x - 1)}{3} &#x3D; \frac{1}{3} \lim\limits_{x \to 0} x (\cos x - 1) &#x3D; \frac{1}{3} \cdot 0 &#x3D; 0.<br>$$</p></li></ol>          </div><hr><div class="note note-info">            <p><strong>推广结论</strong></p><p>当 $x \to 0$ 时，$(1 + x)^a - 1 \sim a x$。<br>进一步推广：若 $\alpha(x) \to 0$ 且 $\alpha(x)\beta(x) \to 0$，则<br>$$<br>[1 + \alpha(x)]^{\beta(x)} - 1 \sim \alpha(x)\beta(x).<br>$$</p><p><strong>应用示例</strong>：<br>$$<br>\left(1 + \frac{\cos x - 1}{3}\right)^x - 1 \sim \frac{x (\cos x - 1)}{3}.<br>$$</p><p><strong>验证</strong>：<br>由 $\cos x - 1 \sim -\frac{1}{2}x^2$，得<br>$$<br>\frac{x (\cos x - 1)}{3} \sim -\frac{x^3}{6} \to 0 \quad (x \to 0).<br>$$</p>          </div><hr><h3 id="1-4-3-利用有理运算法则求极限"><a href="#1-4-3-利用有理运算法则求极限" class="headerlink" title="1.4.3 利用有理运算法则求极限"></a>1.4.3 利用有理运算法则求极限</h3><p><strong>有理运算法则</strong><br>设 $\lim f(x) &#x3D; A$，$\lim g(x) &#x3D; B$，则：  </p><ol><li>$\lim [f(x) \pm g(x)] &#x3D; A \pm B$  </li><li>$\lim [f(x)g(x)] &#x3D; AB$  </li><li>$\lim \left[ \frac{f(x)}{g(x)} \right] &#x3D; \frac{A}{B} \quad (B \neq 0)$</li></ol><p><strong>【注】</strong>  </p><ul><li>(1) 存在 ± 不存在 &#x3D; 不存在  </li><li>(2) 不存在 ± 不存在 &#x3D; 不一定  </li><li>(3) 存在 ×(÷) 不存在 &#x3D; 不一定  </li><li>(4) 不存在 ×(÷) 不存在 &#x3D; 不一定</li></ul><p><strong>常用结论</strong>  </p><ol><li>若 $\lim f(x) &#x3D; A \neq 0$，则 $\lim f(x)g(x) &#x3D; A \lim g(x)$。（极限非零因子可先计算）  </li><li>若 $\lim \frac{f(x)}{g(x)}$ 存在且 $\lim g(x) &#x3D; 0$，则 $\lim f(x) &#x3D; 0$。  </li><li>若 $\lim \frac{f(x)}{g(x)} &#x3D; A \neq 0$ 且 $\lim f(x) &#x3D; 0$，则 $\lim g(x) &#x3D; 0$。</li></ol><hr><div class="note note-success">            <p>（2010，数三）<br>若 $\lim\limits_{x \to 0} \left[ \frac{1}{x} - \left( \frac{1}{x} - a \right) e^x \right] &#x3D; 1$，则 $a$ 等于<br>(A) 0 (B) 1 (C) 2 (D) 3  </p><p><strong>解析</strong>：  </p><ol><li>化简极限式：<br>$$<br>\lim\limits_{x \to 0} \left[ \frac{1 - e^x}{x} + a e^x \right] &#x3D; 1.<br>$$</li><li>计算各部分极限：  <ul><li>$\lim\limits_{x \to 0} \frac{1 - e^x}{x} &#x3D; -1$（等价代换 $e^x - 1 \sim x$），  </li><li>$\lim\limits_{x \to 0} a e^x &#x3D; a$。</li></ul></li><li>由极限运算法则得：$-1 + a &#x3D; 1 \implies a &#x3D; 2$。<br><strong>答案：C</strong></li></ol><hr><p><strong>总结</strong>  </p><ul><li>有理运算法则要求各部分极限存在，且分母极限非零。  </li><li>处理复杂极限时，可先拆分或化简，再逐项求极限。</li></ul>          </div><hr><h3 id="1-4-4-利用洛必达法则求极限"><a href="#1-4-4-利用洛必达法则求极限" class="headerlink" title="1.4.4 利用洛必达法则求极限"></a>1.4.4 利用洛必达法则求极限</h3><p><strong>洛必达法则</strong> 若满足以下条件：  </p><ol><li>$\lim\limits_{x \to x_0} f(x) &#x3D; \lim\limits_{x \to x_0} g(x) &#x3D; 0$ 或 $\infty$；  </li><li>$f(x)$ 和 $g(x)$ 在 $x_0$ 的去心邻域内可导，且 $g’(x) \neq 0$；  </li><li>$\lim\limits_{x \to x_0} \frac{f’(x)}{g’(x)}$ 存在（或为 $\infty$），</li></ol><p>则：<br>$$<br>\lim\limits_{x \to x_0} \frac{f(x)}{g(x)} &#x3D; \lim\limits_{x \to x_0} \frac{f’(x)}{g’(x)}.<br>$$</p><hr><p><strong>【注】</strong>  </p><ol><li><p><strong>适用类型</strong>：<br>洛必达法则适用于七种未定式极限：  </p><ul><li>直接应用：$\frac{0}{0}$、$\frac{\infty}{\infty}$；  </li><li>需转化后应用：  <ul><li>$0 \cdot \infty$（化为 $\frac{0}{1&#x2F;\infty}$ 或 $\frac{\infty}{1&#x2F;0}$），  </li><li>$\infty - \infty$（通分或提因式），  </li><li>$1^\infty$、$\infty^0$、$0^0$（取对数化为 $\frac{0}{0}$ 或 $\frac{\infty}{\infty}$）。</li></ul></li></ul></li><li><p><strong>注意事项</strong>：  </p><ul><li>使用前需验证条件（如是否为 $\frac{0}{0}$ 或 $\frac{\infty}{\infty}$ 型）；  </li><li>若应用后仍为未定式，可重复使用；  </li><li>极限非零的因子可单独计算，简化运算；  </li><li>结合等价无穷小代换或恒等变形（如 $\ln(1+x) \sim x$）可大幅简化过程。</li></ul></li></ol><hr><div class="note note-success">            <p><strong>示例说明</strong><br>对于未定式 $\frac{0}{0}$ 或 $\frac{\infty}{\infty}$：  </p><ol><li><strong>直接应用</strong>：<br>$$<br>\lim\limits_{x \to 0} \frac{\sin x}{x} \xrightarrow{\text{洛必达}} \lim\limits_{x \to 0} \frac{\cos x}{1} &#x3D; 1.<br>$$</li><li><strong>需转化类型</strong>：  <ul><li>$1^\infty$ 型：$\lim\limits_{x \to \infty} \left(1 + \frac{1}{x}\right)^x \xrightarrow{\text{取对数}} e^{\lim\limits_{x \to \infty} x \ln(1+1&#x2F;x)} &#x3D; e^1 &#x3D; e$。</li></ul></li></ol><hr><p><strong>总结</strong>  </p><ul><li>洛必达法则是解决未定式极限的有力工具，但需严格验证条件。  </li><li>灵活结合其他方法（如等价代换、因子分离）可提高计算效率。</li></ul>          </div><hr><h3 id="1-4-5-利用泰勒公式求极限"><a href="#1-4-5-利用泰勒公式求极限" class="headerlink" title="1.4.5 利用泰勒公式求极限"></a>1.4.5 利用泰勒公式求极限</h3><p><strong>定理</strong>（带皮亚诺余项的泰勒公式）<br>设 $f(x)$ 在 $x &#x3D; x_0$ 处 $n$ 阶可导，则<br>$$<br>f(x) &#x3D; f(x_0) + f’(x_0)(x - x_0) + \frac{f’’(x_0)}{2!}(x - x_0)^2 + \cdots + \frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + o[(x - x_0)^n].<br>$$<br>特别地，当 $x_0 &#x3D; 0$ 时（麦克劳林公式）：<br>$$<br>f(x) &#x3D; f(0) + f’(0)x + \frac{f’’(0)}{2!}x^2 + \cdots + \frac{f^{(n)}(0)}{n!}x^n + o(x^n).<br>$$</p><hr><p><strong>常用泰勒展开（$x \to 0$ 时）</strong>  </p><ol><li><strong>指数函数</strong>：<br>$$e^x &#x3D; 1 + x + \frac{x^2}{2!} + \cdots + \frac{x^n}{n!} + o(x^n).$$  </li><li><strong>三角函数</strong>：<br>$$\sin x &#x3D; x - \frac{x^3}{3!} + \cdots + (-1)^{n-1}\frac{x^{2n-1}}{(2n-1)!} + o(x^{2n}),$$<br>$$\cos x &#x3D; 1 - \frac{x^2}{2!} + \cdots + (-1)^n\frac{x^{2n}}{(2n)!} + o(x^{2n}).$$  </li><li><strong>对数函数</strong>：<br>$$\ln(1+x) &#x3D; x - \frac{x^2}{2} + \cdots + (-1)^{n-1}\frac{x^n}{n} + o(x^n).$$  </li><li><strong>幂函数</strong>：<br>$$(1+x)^\alpha &#x3D; 1 + \alpha x + \frac{\alpha(\alpha-1)}{2!}x^2 + \cdots + \frac{\alpha(\alpha-1)\cdots(\alpha-n+1)}{n!}x^n + o(x^n).$$</li></ol><a href="/2025/02/26/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/" title="泰勒公式">更多泰勒公式</a><hr><div class="note note-success">            <p>求极限<br>$$<br>\lim\limits_{x \to 0} \frac{\cos x - e^{-\frac{x^2}{2}}}{x^4}.<br>$$</p><p><strong>解法1：泰勒展开</strong>  </p><ol><li>将 $\cos x$ 和 $e^{-\frac{x^2}{2}}$ 展开到 $x^4$ 项：  <ul><li>$\cos x &#x3D; 1 - \frac{x^2}{2!} + \frac{x^4}{4!} + o(x^4) &#x3D; 1 - \frac{x^2}{2} + \frac{x^4}{24} + o(x^4)$，  </li><li>$e^{-\frac{x^2}{2}} &#x3D; 1 - \frac{x^2}{2} + \frac{(\frac{x^2}{2})^2}{2!} + o(x^4) &#x3D; 1 - \frac{x^2}{2} + \frac{x^4}{8} + o(x^4)$。</li></ul></li><li>代入极限式：<br>$$<br>\cos x - e^{-\frac{x^2}{2}} &#x3D; \left( \frac{1}{24} - \frac{1}{8} \right)x^4 + o(x^4) &#x3D; -\frac{1}{12}x^4 + o(x^4).<br>$$</li><li>因此：<br>$$<br>\lim\limits_{x \to 0} \frac{-\frac{1}{12}x^4 + o(x^4)}{x^4} &#x3D; -\frac{1}{12}.<br>$$</li></ol><p><strong>答案</strong>：$-\dfrac{1}{12}$  </p><hr><p><strong>总结</strong>  </p><ul><li>泰勒公式适用于复杂函数的极限计算，尤其是含高阶无穷小的题目。  </li><li>展开时需根据分母的阶数确定展开的精度（如本题需展开到 $x^4$）。  </li><li>皮亚诺余项 $o(x^n)$ 表示比 $x^n$ 更高阶的无穷小。</li></ul>          </div><hr><h3 id="1-4-5-利用夹逼准则求极限"><a href="#1-4-5-利用夹逼准则求极限" class="headerlink" title="1.4.5 利用夹逼准则求极限"></a>1.4.5 利用夹逼准则求极限</h3><p><strong>常用结论</strong></p><p>$\lim\limits_{n \to \infty} \sqrt[n]{a_1^n+a_2^n+···+a_m^n} &#x3D; a$</p><hr><h3 id="1-4-6-利用单调有界准则求极限"><a href="#1-4-6-利用单调有界准则求极限" class="headerlink" title="1.4.6 利用单调有界准则求极限"></a>1.4.6 利用单调有界准则求极限</h3><p><strong>单调有界定理</strong><br>若数列 ${x_n}$ 单调递增且有上界（或单调递减且有下界），则 ${x_n}$ 收敛。</p><hr><div class="note note-success">            <p>设 $x_1 &gt; 0$，$x_{n+1} &#x3D; \frac{1}{2} \left( x_n + \frac{1}{x_n} \right)$，求 $\lim\limits_{n \to \infty} x_n$。</p><p><strong>解题步骤</strong>：  </p><ol><li><strong>证明数列有下界</strong>：<br>由均值不等式，$x_{n+1} \geq \sqrt{x_n \cdot \frac{1}{x_n}} &#x3D; 1$，故 $x_n \geq 1$（$n \geq 2$）。  </li><li><strong>证明数列单调递减</strong>：  <ul><li>当 $x_n \geq 1$ 时，$x_{n+1} - x_n &#x3D; \frac{1 - x_n^2}{2x_n} \leq 0$。  </li><li>或通过比值：$\frac{x_{n+1}}{x_n} &#x3D; \frac{1}{2} \left( 1 + \frac{1}{x_n^2} \right) \leq 1$（因 $x_n \geq 1$）。</li></ul></li><li><strong>求极限</strong>：<br>设 $\lim\limits_{n \to \infty} x_n &#x3D; a$，对递推式取极限得：<br>$$a &#x3D; \frac{1}{2} \left( a + \frac{1}{a} \right) \implies a^2 &#x3D; 1 \implies a &#x3D; 1 \quad (\text{舍去 } a &#x3D; -1).$$</li></ol><p><strong>结论</strong>：$\lim\limits_{n \to \infty} x_n &#x3D; 1$。</p>          </div><hr><h3 id="1-4-7-利用定积分定义求极限"><a href="#1-4-7-利用定积分定义求极限" class="headerlink" title="1.4.7 利用定积分定义求极限"></a>1.4.7 利用定积分定义求极限</h3><p><strong>定积分定义</strong> 若 $f(x)$ 在 $[a, b]$ 上可积，则：<br>$$\lim\limits_{n \to \infty} \frac{1}{n} \sum_{k&#x3D;1}^n f\left( a + \frac{k(b-a)}{n} \right) &#x3D; \int_a^b f(x) dx.$$</p><hr><div class="note note-success">            <p>求极限：<br>$$\lim\limits_{n \to \infty} \left( \frac{1}{n+1} + \frac{1}{n+2} + \cdots + \frac{1}{n+n} \right).$$</p><p><strong>解题步骤</strong>：  </p><ol><li>改写为求和形式：<br>$$\lim\limits_{n \to \infty} \sum_{k&#x3D;1}^n \frac{1}{n+k} &#x3D; \lim\limits_{n \to \infty} \frac{1}{n} \sum_{k&#x3D;1}^n \frac{1}{1 + \frac{k}{n}}.$$  </li><li>识别定积分形式：<br>取 $f(x) &#x3D; \frac{1}{1+x}$，区间 $[0, 1]$，则：<br>$$\lim\limits_{n \to \infty} \frac{1}{n} \sum_{k&#x3D;1}^n f\left( \frac{k}{n} \right) &#x3D; \int_0^1 \frac{1}{1+x} dx &#x3D; \ln(1+x) \Big|_0^1 &#x3D; \ln 2.$$</li></ol><p><strong>结论</strong>：极限值为 $\ln 2$。</p>          </div><p><strong>利用定积分定义求极限的一般方法是先提可爱因子$\frac{1}{n}$，然后再确定被积函数和积分区间</strong></p><h1 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h1><h2 id="2-1-间断点及其分类"><a href="#2-1-间断点及其分类" class="headerlink" title="2.1 间断点及其分类"></a>2.1 间断点及其分类</h2><p><strong>1. 间断点的定义</strong></p><p><strong>定义</strong> 若 ( f(x) ) 在 ( x_0 ) 的某去心邻域内有定义，但在 ( x_0 ) 处不连续，则称 ( x_0 ) 为 ( f(x) ) 的<strong>间断点</strong>。</p><p><strong>2. 间断点的分类</strong></p><ol><li><p><strong>第一类间断点</strong>：左、右极限都存在。</p><ul><li><strong>可去间断点</strong>：左、右极限存在且相等$(\lim\limits_{x \to x_0^-} f(x) &#x3D; \lim\limits_{x \to x_0^+} f(x) \neq f(x_0)) 或 ( f(x_0) )$ 无定义）。</li><li><strong>跳跃间断点</strong>：左、右极限存在但不相等$(\lim\limits_{x \to x_0^-} f(x) \neq \lim\limits_{x \to x_0^+} f(x))$。</li></ul></li><li><p><strong>第二类间断点</strong>：左、右极限至少有一个不存在。</p><ul><li><strong>无穷间断点</strong>：$(\lim\limits_{x \to x_0} f(x) &#x3D; \infty)$ 或单侧极限为 $(\infty)$。</li><li><strong>振荡间断点</strong>：极限振荡不存在（如$ ( \sin \frac{1}{x} ) 在 ( x&#x3D;0 ) 处$）。</li></ul></li></ol><p><strong>示例</strong>：</p><ul><li>函数$ ( y &#x3D; \sin \frac{1}{x} )$ 在 $( x&#x3D;0 ) $处无定义，且左、右极限均不存在（无限振荡），故$ ( x&#x3D;0 ) $为<strong>振荡间断点</strong>。</li></ul><hr><h2 id="2-2-连续性的运算与性质"><a href="#2-2-连续性的运算与性质" class="headerlink" title="2.2 连续性的运算与性质"></a>2.2 连续性的运算与性质</h2><p><strong>定理</strong>  </p><ol><li><p><strong>四则运算连续性</strong>：<br>若 $f(x)$ 和 $g(x)$ 在 $x_0$ 处连续，则以下函数在 $x_0$ 处也连续：  </p><ul><li>$f(x) \pm g(x)$  </li><li>$f(x) \cdot g(x)$  </li><li>$\frac{f(x)}{g(x)}$（$g(x_0) \neq 0$）</li></ul></li><li><p><strong>复合函数连续性</strong>：<br>若 $u &#x3D; \varphi(x)$ 在 $x_0$ 处连续且 $\varphi(x_0) &#x3D; u_0$，$y &#x3D; f(u)$ 在 $u_0$ 处连续，则复合函数 $y &#x3D; f[\varphi(x)]$ 在 $x_0$ 处连续。  </p></li><li><p><strong>初等函数连续性</strong>：  </p><ul><li>基本初等函数在其定义域内连续。  </li><li>初等函数在其定义区间内连续（定义区间是定义域内的区间）。</li></ul></li></ol><hr><h2 id="2-3-闭区间上连续函数的性质"><a href="#2-3-闭区间上连续函数的性质" class="headerlink" title="2.3 闭区间上连续函数的性质"></a>2.3 闭区间上连续函数的性质</h2><p><strong>定理</strong>  </p><ol><li><p><strong>最值定理</strong>：<br>闭区间 $[a, b]$ 上的连续函数 $f(x)$ 必有最大值 $M$ 和最小值 $m$。  </p></li><li><p><strong>有界性定理</strong>：<br>$[a, b]$ 上的连续函数 $f(x)$ 必有界（即存在 $K &gt; 0$，使得 $|f(x)| \leq K$）。  </p></li><li><p><strong>介值定理</strong>：<br>若 $f(x)$ 在 $[a, b]$ 上连续，且 $f(a) \neq f(b)$，则对任意 $C$ 介于 $f(a)$ 和 $f(b)$ 之间，存在 $\xi \in (a, b)$ 使得 $f(\xi) &#x3D; C$。  </p></li><li><p><strong>零点定理</strong>：<br>若 $f(x)$ 在 $[a, b]$ 上连续，且 $f(a) \cdot f(b) &lt; 0$，则存在 $\xi \in (a, b)$ 使得 $f(\xi) &#x3D; 0$。</p></li></ol><p><strong>推论</strong>：<br>闭区间上的连续函数可取到最小值 $m$ 和最大值 $M$ 之间的所有值。  </p><hr><p><strong>注</strong>  </p><ul><li>零点定理常用于证明方程根的存在性（如 $f(x) &#x3D; 0$ 在 $(a, b)$ 内有解）。  </li><li>定义区间需严格属于定义域（如 $\sqrt{x}$ 的定义区间为 $[0, +\infty)$）。</li></ul><hr><div class="note note-success">            <p><strong>示例应用</strong><br>证明方程 $x^3 - 3x + 1 &#x3D; 0$ 在 $(1, 2)$ 内有根：  </p><ol><li>设 $f(x) &#x3D; x^3 - 3x + 1$，则 $f(1) &#x3D; -1$，$f(2) &#x3D; 3$。  </li><li>由零点定理，存在 $\xi \in (1, 2)$ 使得 $f(\xi) &#x3D; 0$。</li></ol>          </div><hr><h1 id="三、导数与微分"><a href="#三、导数与微分" class="headerlink" title="三、导数与微分"></a>三、导数与微分</h1><h3 id="3-1-导数的定义"><a href="#3-1-导数的定义" class="headerlink" title="3.1 导数的定义"></a>3.1 导数的定义</h3><p><strong>定义1（导数）</strong><br>设函数 $y&#x3D;f(x)$ 在点 $x_0$ 的某邻域内有定义，若极限<br>$$<br>f’(x_0) &#x3D; \lim\limits_{\Delta x \to 0} \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x}<br>$$<br>存在，则称 $f(x)$ 在 $x_0$ 处<strong>可导</strong>，并称此极限为 $f(x)$ 在 $x_0$ 处的<strong>导数</strong>，记作 $f’(x_0)$ 或 $\left.\frac{dy}{dx}\right|_{x&#x3D;x_0}$。</p><p><strong>定义2（单侧导数）</strong>  </p><ul><li><strong>右导数</strong>：$f’_ +(x_0) &#x3D; \lim\limits_{\Delta x \to 0^+} \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x}$  </li><li><strong>左导数</strong>：$f’_ -(x_0) &#x3D; \lim\limits_{\Delta x \to 0^-} \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x}$</li></ul><p><strong>定理</strong>：$f(x)$ 在 $x_0$ 处可导 $\Leftrightarrow$ $f’_ +(x_0) &#x3D; f’_ -(x_0)$。</p><hr><h3 id="3-2-微分的定义"><a href="#3-2-微分的定义" class="headerlink" title="3.2 微分的定义"></a>3.2 微分的定义</h3><p><strong>定义（微分）</strong><br>若函数 $y&#x3D;f(x)$ 在 $x_0$ 处的增量 $\Delta y$ 可表示为<br>$$<br>\Delta y &#x3D; A \Delta x + o(\Delta x) \quad (\Delta x \to 0),<br>$$<br>其中 $A$ 与 $\Delta x$ 无关，则称 $f(x)$ 在 $x_0$ 处<strong>可微</strong>，并称 $A \Delta x$ 为<strong>微分</strong>，记作 $dy &#x3D; A \Delta x$ 或 $df(x_0) &#x3D; A \Delta x$。</p><p><strong>定理</strong>：$f(x)$ 在 $x_0$ 处可微 $\Leftrightarrow$ $f(x)$ 在 $x_0$ 处可导，且 $dy &#x3D; f’(x_0) \Delta x$。<br>通常记 $\Delta x &#x3D; dx$，故 $dy &#x3D; f’(x_0) dx$。</p><hr><h4 id="3-2-1-导数与微分的几何意义"><a href="#3-2-1-导数与微分的几何意义" class="headerlink" title="3.2.1 导数与微分的几何意义"></a>3.2.1 导数与微分的几何意义</h4><p><strong>(1) 导数的几何意义</strong></p><ul><li><p><strong>切线斜率</strong>：导数 $ f’(x_0) $ 表示曲线 $y &#x3D; f(x) $ 在点$(x_0, f(x_0)) $ 处切线的斜率。</p></li><li><p><strong>切线方程</strong>：$y - f(x_0) &#x3D; f’(x_0)(x - x_0)$</p><ul><li>若 $ f’(x_0) \neq 0 $，法线方程为：$y - f(x_0) &#x3D; -\frac{1}{f’(x_0)}(x - x_0)$</li><li>若 $ f’(x_0) &#x3D; 0 $，切线为水平线 $ y &#x3D; f(x_0) $。</li></ul></li><li><p><strong>注</strong>：可导必存在切线，但存在切线未必可导（如 $ y &#x3D; x^{1&#x2F;3} $ 在 $ x&#x3D;0 $ 处有垂直切线但不可导）。</p></li></ul><p><strong>(2) 微分的几何意义</strong></p><ul><li><strong>微分 ( dy )</strong>：表示切线上纵坐标的增量，即：$dy &#x3D; f’(x_0) dx$</li><li>实际增量 $\Delta y$：表示曲线上纵坐标的真实增量：$\Delta y &#x3D; f(x_0 + \Delta x) - f(x_0)$</li><li><strong>关系</strong>：当 $ \Delta x \to 0 $ 时，$\Delta y \approx dy $，误差为高阶无穷小 $ o(\Delta x) $。</li></ul><hr><h3 id="3-3-基本求导法则"><a href="#3-3-基本求导法则" class="headerlink" title="3.3 基本求导法则"></a>3.3 基本求导法则</h3><p><strong>(1) 高阶导数</strong></p><p>$n$ 阶导数记作：<br>$$<br>f^{(n)}(x) &#x3D; \frac{d^n y}{dx^n}<br>$$</p><p><strong>常见高阶导数公式</strong>：</p><ul><li>$(e^x)^{(n)} &#x3D; e^x$</li><li>$(\sin x)^{(n)} &#x3D; \sin\left(x + \frac{n\pi}{2}\right)$</li><li>$(\cos x)^{(n)} &#x3D; \cos\left(x + \frac{n\pi}{2}\right)$</li><li>$\left(\frac{1}{1+x}\right)^{(n)} &#x3D; (-1)^n \frac{n!}{(1+x)^{n+1}}$</li></ul><hr><p><strong>（2）基本初等函数导数公式</strong></p><ol><li>$(C)’ &#x3D; 0$  </li><li>$(x^\alpha)’ &#x3D; \alpha x^{\alpha-1}$  </li><li>$(a^x)’ &#x3D; a^x \ln a$  </li><li>$(e^x)’ &#x3D; e^x$  </li><li>$(\log_a x)’ &#x3D; \frac{1}{x \ln a}$  </li><li>$(\ln |x|)’ &#x3D; \frac{1}{x}$  </li><li>$(\sin x)’ &#x3D; \cos x$  </li><li>$(\cos x)’ &#x3D; -\sin x$  </li><li>$(\tan x)’ &#x3D; \sec^2 x$  </li><li>$(\cot x)’ &#x3D; -\csc^2 x$  </li><li>$(\sec x)’ &#x3D; \sec x \tan x$  </li><li>$(\csc x)’ &#x3D; -\csc x \cot x$  </li><li>$(\arcsin x)’ &#x3D; \frac{1}{\sqrt{1-x^2}}$  </li><li>$(\arccos x)’ &#x3D; -\frac{1}{\sqrt{1-x^2}}$  </li><li>$(\arctan x)’ &#x3D; \frac{1}{1+x^2}$  </li><li>$(\operatorname{arccot} x)’ &#x3D; -\frac{1}{1+x^2}$</li></ol><hr><p><strong>（3） 求导法则</strong></p><h4 id="3-3-1-有理运算法则："><a href="#3-3-1-有理运算法则：" class="headerlink" title="3.3.1 有理运算法则："></a>3.3.1 有理运算法则：</h4><ul><li>$(u \pm v)’ &#x3D; u’ \pm v’$  </li><li>$(uv)’ &#x3D; u’v + uv’$  </li><li>$\left(\frac{u}{v}\right)’ &#x3D; \frac{u’v - uv’}{v^2} \quad (v \neq 0)$</li></ul><h4 id="3-3-2-复合函数求导（链式法则）："><a href="#3-3-2-复合函数求导（链式法则）：" class="headerlink" title="3.3.2 复合函数求导（链式法则）："></a>3.3.2 复合函数求导（链式法则）：</h4><p>设 $u &#x3D; \varphi(x)$ 可导，$y &#x3D; f(u)$ 可导，则<br>$$<br>\frac{dy}{dx} &#x3D; \frac{dy}{du} \cdot \frac{du}{dx} &#x3D; f’(u) \varphi’(x)<br>$$</p><h4 id="3-3-3-反函数求导"><a href="#3-3-3-反函数求导" class="headerlink" title="3.3.3 反函数求导"></a>3.3.3 反函数求导</h4><p>若 $y&#x3D;f(x)$ 可导且 $f’(x) \neq 0$，则反函数 $x&#x3D;f^{-1}(y)$ 的导数为<br>$\frac{dx}{dy} &#x3D; \frac{1}{f’(x)}$。</p><hr><h4 id="3-3-4-隐函数求导"><a href="#3-3-4-隐函数求导" class="headerlink" title="3.3.4 隐函数求导"></a>3.3.4 隐函数求导</h4><p>设函数 $y &#x3D; y(x)$ 由方程 $F(x, y) &#x3D; 0$ 确定，求导步骤如下：</p><ol><li>方程两边对 $x$ 求导：<br>将 $F(x, y) &#x3D; 0$ 视为关于 $x$ 的恒等式，对 $x$ 求导（注意 $y$ 是 $x$ 的函数，需使用链式法则）。</li><li>解出 $y’$：<br>整理导数方程，解出 $\frac{dy}{dx}$。</li></ol><p><strong>或者：</strong></p><p>若 $F(x, y)$ 可微且 $\frac{\partial F}{\partial y} \neq 0$，则：<br>$$<br>\frac{dy}{dx} &#x3D; -\frac{\frac{\partial F}{\partial x}}{\frac{\partial F}{\partial y}}<br>$$</p><hr><div class="note note-success">            <p>（1993，数三） 函数 $y &#x3D; y(x)$ 由方程 $\sin(x^2 + y^2) + e^x - xy^2 &#x3D; 0$ 确定，求 $\frac{dy}{dx}$。</p><p><strong>解题步骤</strong>：</p><ol><li><p><strong>对原方程两边求导</strong>：<br>$$<br>\begin{align*}<br>\frac{d}{dx}\left[\sin(x^2 + y^2) + e^x - xy^2\right] &amp;&#x3D; 0 \\<br>\cos(x^2 + y^2) \cdot (2x + 2y\frac{dy}{dx}) + e^x - \left(y^+ 2xy\frac{dy}{dx}\right) &amp;&#x3D; 0<br>\end{align*}<br>$$</p></li><li><p><strong>整理关于 $\frac{dy}{dx}$ 的方程</strong>：<br>$$<br>\begin{align*}<br>2x\cos(x^2 + y^2) + 2y\cos(x^2 + y^2)\frac{dy}{dx} + e^x - y^2 - 2xy\frac{dy}{dx} &amp;&#x3D; 0 \\<br>\left[2y\cos(x^2 + y^2) - 2xy\right]\frac{dy}{dx} &amp;&#x3D; y^2 - e^x - 2x\cos(x^2 + y^2)<br>\end{align*}<br>$$</p></li><li><p><strong>解出导数</strong>：<br>$$<br>\frac{dy}{dx} &#x3D; \frac{y^2 - e^x - 2x\cos(x^2 + y^2)}{2y\cos(x^2 + y^2) - 2xy}<br>$$</p></li></ol><p><strong>关键点</strong>：</p><ul><li>对 $\sin(x^2 + y^2)$ 求导需用链式法则。</li><li>方程中 $y$ 视为 $x$ 的函数，故 $xy^2$ 的导数为 $y^2 + 2xy y’$。</li></ul><hr><p><strong>注</strong>：  </p><ul><li>实际计算时，也可直接对原方程两边求导（无需引入 $F$），再解出 $y’$。</li></ul>          </div><hr><h4 id="3-3-5-参数方程求导"><a href="#3-3-5-参数方程求导" class="headerlink" title="3.3.5 参数方程求导"></a>3.3.5 参数方程求导</h4><p>设函数 $y &#x3D; y(x)$ 由参数方程<br>$$<br>\begin{cases}<br>x &#x3D; \varphi(t), \\<br>y &#x3D; \psi(t)<br>\end{cases} \quad (a &lt; t &lt; \beta)<br>$$<br>确定，则：</p><p><strong>一阶导数</strong> 若 $\varphi(t)$ 和 $\psi(t)$ 可导，且 $\varphi’(t) \neq 0$，则：<br>$$<br>\begin{align*}<br>\frac{dy}{dx} &amp;&#x3D; \frac{\psi’(t)}{\varphi’(t)}\\<br>&amp;&#x3D;\frac{y’}{x’}<br>\end{align*}<br>$$</p><p><strong>二阶导数</strong> 若 $\varphi(t)$ 和 $\psi(t)$ 二阶可导，且 $\varphi’(t) \neq 0$，则：<br>$$<br>\frac{d^2 y}{dx^2} &#x3D; \frac{d}{dt} \left( \frac{\psi’(t)}{\varphi’(t)} \right) \cdot \frac{1}{\varphi’(t)} &#x3D; \frac{\psi’’(t)\varphi’(t) - \varphi’’(t)\psi’(t)}{[\varphi’(t)]^3}<br>$$</p><hr><p><strong>推导说明</strong>：</p><ol><li><p>一阶导数直接由链式法则得到：$\frac{dy}{dx} &#x3D; \frac{dy&#x2F;dt}{dx&#x2F;dt}$。</p></li><li><p>二阶导数为：<br>$$<br>\begin{align*}<br>\frac{d^2y}{dx^2} &amp;&#x3D; \frac{d}{dx}\left(\frac{dy}{dx}\right)\\<br>&amp;&#x3D; \frac{d}{dt}\left(\frac{\psi’(t)}{\varphi’(t)}\right) \cdot \frac{dt}{dx} \\<br>&amp;&#x3D; \frac{\psi’’(t)\varphi’(t) - \psi’(t)\varphi’’(t)}{[\varphi’(t)]^2} \cdot \frac{1}{\varphi’(t)}<br>\end{align*}<br>$$</p></li></ol><div class="note note-success">            <p><strong>示例</strong>：<br>设参数方程：<br>$$<br>\begin{cases}<br>x &#x3D; t^2, \\<br>y &#x3D; t^3<br>\end{cases}<br>$$<br>则：</p><ul><li>一阶导：$\frac{dy}{dx} &#x3D; \frac{3t^2}{2t} &#x3D; \frac{3t}{2}$</li><li>二阶导：$\frac{d^2y}{dx^2} &#x3D; \frac{6t \cdot 2t - 2 \cdot 3t^2}{(2t)^3} &#x3D; \frac{6t^2}{8t^3} &#x3D; \frac{3}{4t}$</li></ul>          </div><hr><h4 id="3-3-6-对数求导"><a href="#3-3-6-对数求导" class="headerlink" title="3.3.6 对数求导"></a>3.3.6 对数求导</h4><hr><h3 id="3-5-微分中值定理"><a href="#3-5-微分中值定理" class="headerlink" title="3.5 微分中值定理"></a>3.5 微分中值定理</h3><ol><li><p><strong>费马定理</strong>：<br>若 $f(x)$ 在 $x_0$ 处可导且取得极值，则 $f’(x_0) &#x3D; 0$。  </p></li><li><p><strong>罗尔定理</strong>：<br>若 $f(x)$ 在 $[a,b]$ 上连续，在 $(a,b)$ 内可导，且 $f(a)&#x3D;f(b)$，则存在 $\xi \in (a,b)$ 使得 $f’(\xi)&#x3D;0$。  </p></li><li><p><strong>拉格朗日中值定理</strong>：<br>若 $f(x)$ 在 $[a,b]$ 上连续，在 $(a,b)$ 内可导，则存在 $\xi \in (a,b)$ 使得<br>$$<br>f(b) - f(a) &#x3D; f’(\xi)(b-a).<br>$$</p></li><li><p><strong>柯西中值定理</strong>：<br>若 $f(x), g(x)$ 在 $[a,b]$ 上连续，在 $(a,b)$ 内可导，且 $g’(x) \neq 0$，则存在 $\xi \in (a,b)$ 使得<br>$$<br>\frac{f(b)-f(a)}{g(b)-g(a)} &#x3D; \frac{f’(\xi)}{g’(\xi)}.<br>$$</p></li></ol><hr><h3 id="3-6-泰勒公式"><a href="#3-6-泰勒公式" class="headerlink" title="3.6 泰勒公式"></a>3.6 泰勒公式</h3><h4 id="3-6-1-带佩亚诺余项的泰勒公式"><a href="#3-6-1-带佩亚诺余项的泰勒公式" class="headerlink" title="3.6.1 带佩亚诺余项的泰勒公式"></a>3.6.1 带佩亚诺余项的泰勒公式</h4><p>若 $f(x)$ 在 $x_0$ 处 $n$ 阶可导，则<br>$$<br>f(x) &#x3D; f(x_0) + f’(x_0)(x-x_0) + \cdots + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + o((x-x_0)^n).<br>$$<br>特别地，当 $x_0&#x3D;0$ 时（麦克劳林公式）：<br>$$<br>f(x) &#x3D; f(0) + f’(0)x + \cdots + \frac{f^{(n)}(0)}{n!}x^n + o(x^n).<br>$$</p><hr><h4 id="3-6-2-拉格朗日型余项泰勒公式"><a href="#3-6-2-拉格朗日型余项泰勒公式" class="headerlink" title="3.6.2 拉格朗日型余项泰勒公式"></a>3.6.2 拉格朗日型余项泰勒公式</h4><p><strong>定理</strong> 设函数 $ f(x) $ 在包含 $ x_0 $ 的开区间 $ (a, b) $内有直到 $ n+1 $ 阶的导数，则对任意 $ x \in (a, b) $ 有：<br>$$<br>f(x) &#x3D; f(x_0) + f’(x_0)(x - x_0) + \frac{ f’’(x_0)}{2!}(x - x_0)^2 + \cdots + \frac{f^{(n)}(x_0)}{n!} (x - x_0)^n + R_n(x)<br>$$<br>其中拉格朗日型余项：<br>$$<br>R_n(x) &#x3D; \frac{f^{(n+1)}(\xi)}{(n+1)!} (x - x_0)^{n+1}, \quad \xi \text{ 介于 } x_0 \text{ 与 } x \text{ 之间}<br>$$</p><a href="/2025/02/26/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/" title="泰勒公式">更多泰勒公式</a><hr><p><strong>注</strong>：  </p><ul><li>导数反映函数变化的瞬时速率，微分描述局部线性近似。  </li><li>微分中值定理是连接函数与导数的桥梁，泰勒公式提供了函数的多项式逼近。</li><li>皮亚诺余项描述局部逼近精度，拉格朗日余项提供全局误差估计</li></ul><hr><h3 id="3-7-导数应用"><a href="#3-7-导数应用" class="headerlink" title="3.7 导数应用"></a>3.7 导数应用</h3><h4 id="3-7-1-函数的单调性"><a href="#3-7-1-函数的单调性" class="headerlink" title="3.7.1 函数的单调性"></a>3.7.1 函数的单调性</h4><p><strong>定理</strong> 设 $f(x)$ 在 $[a,b]$ 上连续，在 $(a,b)$ 内可导：</p><ol><li>若在 $(a,b)$ 内 $f’(x) &gt; 0$，则 $f(x)$ 在 $[a,b]$ 上<strong>单调增</strong>。</li><li>若在 $(a,b)$ 内 $f’(x) &lt; 0$，则 $f(x)$ 在 $[a,b]$ 上<strong>单调减</strong>。</li></ol><hr><h4 id="3-7-2-函数的极值"><a href="#3-7-2-函数的极值" class="headerlink" title="3.7.2 函数的极值"></a>3.7.2 函数的极值</h4><p><strong>定义</strong>  </p><ul><li><strong>极值点</strong>：若 $x_0$ 的某邻域内恒有 $f(x) \leq f(x_0)$（或 $f(x) \geq f(x_0)$），则称 $x_0$ 为<strong>极大值点</strong>（或<strong>极小值点</strong>）。</li><li><strong>驻点</strong>：导数为零的点（$f’(x_0) &#x3D; 0$）。</li></ul><p><strong>定理（极值的必要条件）</strong> 若 $f(x)$ 在 $x_0$ 处可导且 $x_0$ 为极值点，则 $f’(x_0) &#x3D; 0$。</p><p><strong>定理（极值的第一充分条件）</strong><br>设 $f(x)$ 在 $x_0$ 的去心邻域内可导且 $f’(x_0) &#x3D; 0$（或 $f(x)$ 在 $x_0$ 处连续）：</p><ol><li>若 $f’(x)$ 在 $x_0$ 左侧为正、右侧为负，则 $x_0$ 为<strong>极大值点</strong>。</li><li>若 $f’(x)$ 在 $x_0$ 左侧为负、右侧为正，则 $x_0$ 为<strong>极小值点</strong>。</li><li>若 $f’(x)$ 在 $x_0$ 两侧同号，则 $x_0$ 不是极值点。</li></ol><p><strong>定理（极值的第二充分条件）</strong><br>设 $f(x)$ 在 $x_0$ 处二阶可导且 $f’(x_0) &#x3D; 0$：</p><ol><li>若 $f’’(x_0) &lt; 0$，则 $x_0$ 为<strong>极大值点</strong>。</li><li>若 $f’’(x_0) &gt; 0$，则 $x_0$ 为<strong>极小值点</strong>。</li><li>若 $f’’(x_0) &#x3D; 0$，无法判定。</li></ol><hr><h4 id="3-7-3-函数的最大值与最小值"><a href="#3-7-3-函数的最大值与最小值" class="headerlink" title="3.7.3 函数的最大值与最小值"></a>3.7.3 函数的最大值与最小值</h4><p><strong>定义</strong><br>若对任意 $x \in [a,b]$ 有 $f(x) \leq f(x_0)$（或 $f(x) \geq f(x_0)$），则称 $f(x_0)$ 为 $f(x)$ 在 $[a,b]$ 上的<strong>最大值</strong>（或<strong>最小值</strong>）,称$x_0$为 $f(x)$在 $[a,b]$上的<strong>最大值点</strong>（或<strong>最小值点</strong>）</p><p><strong>求连续函数 $f(x)$ 在闭区间 $[a,b]$ 上最值的步骤</strong>：</p><ol><li>求 $(a,b)$ 内的<strong>驻点</strong>（$f’(x)&#x3D;0$）和<strong>不可导点</strong> $x_1,x_2,\cdots,x_n$。</li><li>计算这些点及端点处的函数值：<br>$$f(x_1), f(x_2), \cdots, f(x_n), f(a), f(b)$$</li><li>比较所有函数值，最大者为<strong>最大值</strong>，最小者为<strong>最小值</strong>。</li></ol><p><strong>注</strong>：若 $f(x)$ 在 $[a,b]$ 内仅有<strong>唯一极值点</strong>，则该极值即为最值。</p><hr><h4 id="3-7-4-函数的最值与凹凸性"><a href="#3-7-4-函数的最值与凹凸性" class="headerlink" title="3.7.4 函数的最值与凹凸性"></a>3.7.4 函数的最值与凹凸性</h4><p><strong>定义（凹凸性）</strong><br>设 $f(x)$ 在区间 $I$ 上连续：</p><ul><li><p><strong>凹</strong>：对任意 $x_1,x_2 \in I$，有  </p><p>$$f\left(\frac{x_1+x_2}{2}\right) &lt; \frac{f(x_1)+f(x_2)}{2}$$</p></li><li><p><strong>凸</strong>：对任意 $x_1,x_2 \in I$，有<br>$$f\left(\frac{x_1+x_2}{2}\right) &gt; \frac{f(x_1)+f(x_2)}{2}$$</p></li></ul><p><strong>判别定理</strong><br>若 $f(x)$ 在 $[a,b]$ 上连续，在 $(a,b)$ 内二阶可导：</p><ul><li>$f’’(x)&gt;0$：曲线为<strong>凹</strong>。</li><li>$f’’(x)&lt;0$：曲线为<strong>凸</strong>。</li></ul><p><strong>拐点定义</strong> 连续曲线凹凸性的分界点称为<strong>拐点</strong>。</p><p><strong>拐点判定定理</strong>  </p><ol><li><strong>必要条件</strong>：若 $(x_0,f(x_0))$ 为拐点且 $f’’(x_0)$ 存在，则 $f’’(x_0)&#x3D;0$。</li><li><strong>第一充分条件</strong>：  <ul><li>若 $f’’(x)$ 在 $x_0$ 左右异号，则 $(x_0,f(x_0))$ 为拐点。</li><li>若同号，则不为拐点。</li></ul></li><li><strong>第二充分条件</strong>：<br>若 $f’’(x_0)&#x3D;0$ 且 $f’’’(x_0)\neq 0$，则 $(x_0,f(x_0))$ 为拐点。</li></ol><p><strong>注</strong>：</p><ul><li>最值需比较所有临界点和端点的函数值。</li><li>拐点需同时验证二阶导数为零和凹凸性变化。</li></ul><hr><h4 id="3-7-5-曲线的渐近线"><a href="#3-7-5-曲线的渐近线" class="headerlink" title="3.7.5 曲线的渐近线"></a>3.7.5 曲线的渐近线</h4><p><strong>定义</strong> 若曲线 $y &#x3D; f(x)$ 上的点 $M$ 无限远离原点时与直线 $L$ 的距离趋近于零，则称 $L$ 为 $y &#x3D; f(x)$ 的<strong>渐近线</strong>：</p><ul><li><strong>水平渐近线</strong>：$L$ 平行于 $x$ 轴</li><li><strong>铅直渐近线</strong>：$L$ 垂直于 $x$ 轴</li><li><strong>斜渐近线</strong>：$L$ 既不平行也不垂直于 $x$ 轴</li></ul><p><strong>求法</strong>：</p><ol><li><strong>水平渐近线</strong>：<br>若 $\lim\limits_{x \to \infty} f(x) &#x3D; A$（或 $x \to +\infty$、$x \to -\infty$），则 $y &#x3D; A$ 为水平渐近线。</li><li><strong>铅直渐近线</strong>：<br>若 $\lim\limits_{x \to x_0} f(x) &#x3D; \infty$（单侧极限亦可），则 $x &#x3D; x_0$ 为铅直渐近线。</li><li><strong>斜渐近线</strong>：<br>若 $\lim\limits_{x \to \infty} \frac{f(x)}{x} &#x3D; a$ 且 $\lim\limits_{x \to \infty} [f(x) - ax] &#x3D; b$，则 $y &#x3D; ax + b$ 为斜渐近线。</li></ol><hr><h4 id="3-7-6-函数的作图"><a href="#3-7-6-函数的作图" class="headerlink" title="3.7.6 函数的作图"></a>3.7.6 函数的作图</h4><p>利用函数的以下性质绘制曲线：</p><ul><li>单调性与极值</li><li>凹凸性与拐点</li><li>渐近线</li></ul><hr><h4 id="3-7-7-曲线的弧微分与曲率"><a href="#3-7-7-曲线的弧微分与曲率" class="headerlink" title="3.7.7 曲线的弧微分与曲率"></a>3.7.7 曲线的弧微分与曲率</h4><p><strong>弧微分</strong>：若 $y &#x3D; f(x)$ 在 $(a,b)$ 内有连续导数，则<br>$$<br>ds &#x3D; \sqrt{1 + y’^2} dx<br>$$</p><p><strong>曲率</strong>：若 $y &#x3D; f(x)$ 有二阶导数，则<br>$$<br>K &#x3D; \frac{|y’’|}{(1 + y’^2)^{3&#x2F;2}}<br>$$<br><strong>曲率半径</strong>：$\rho &#x3D; \frac{1}{K}$。</p><p><strong>曲率圆</strong>：在点 $M(x,y)$ 处，以曲率中心 $D$ 为圆心、$\rho$ 为半径的圆称为曲率圆。</p><p><strong>注：</strong></p><ul><li>斜渐近线需同时计算斜率 $a$ 和截距 $b$。</li><li>铅直渐近线通常出现在函数无定义点（如分母为零）。</li></ul><hr><h3 id="3-8-常见题型"><a href="#3-8-常见题型" class="headerlink" title="3.8 常见题型"></a>3.8 常见题型</h3><h4 id="（1）求函数的极值和最值及确定曲线的凹向和拐点"><a href="#（1）求函数的极值和最值及确定曲线的凹向和拐点" class="headerlink" title="（1）求函数的极值和最值及确定曲线的凹向和拐点"></a>（1）求函数的极值和最值及确定曲线的凹向和拐点</h4><h4 id="（2）求渐近线（只有三种）"><a href="#（2）求渐近线（只有三种）" class="headerlink" title="（2）求渐近线（只有三种）"></a>（2）求渐近线（只有三种）</h4><h4 id="（3）方程的根"><a href="#（3）方程的根" class="headerlink" title="（3）方程的根"></a>（3）方程的根</h4><h4 id="（4）函数不等式"><a href="#（4）函数不等式" class="headerlink" title="（4）函数不等式"></a>（4）函数不等式</h4><h4 id="（5）中值定理证明"><a href="#（5）中值定理证明" class="headerlink" title="（5）中值定理证明"></a>（5）中值定理证明</h4><h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><p><img src="/../../img/%E9%AB%98%E6%95%B0/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%85%AC%E5%BC%8F.jpg"></p><p><img src="/../../img/%E9%AB%98%E6%95%B0/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.jpg"></p><a href="/2025/07/01/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8B/" title="高数基础知识（下）">高数基础知识下</a>]]></content>
    
    
    <categories>
      
      <category>上岸</category>
      
      <category>高数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线代一轮复习</title>
    <link href="/2025/06/10/%E7%BA%BF%E4%BB%A3/%E7%BA%BF%E4%BB%A3%E4%B8%80%E8%BD%AE%E5%A4%8D%E4%B9%A0/"/>
    <url>/2025/06/10/%E7%BA%BF%E4%BB%A3/%E7%BA%BF%E4%BB%A3%E4%B8%80%E8%BD%AE%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1、行列式"><a href="#1、行列式" class="headerlink" title="1、行列式"></a>1、行列式</h1><p><img src="/../../img/%E7%BA%BF%E4%BB%A3/1.jpg"></p><hr><h2 id="1-1-性质"><a href="#1-1-性质" class="headerlink" title="1.1 性质"></a>1.1 性质</h2><ol><li><p><strong>转置性质</strong><br>行列式转置后值不变：<br>$$|A^T| &#x3D; |A|$$</p></li><li><p><strong>行&#x2F;列互换</strong><br>两行（或列）互换，行列式变号。若两行（或列）相同，行列式为0。</p></li><li><p><strong>公因子提取</strong><br>某行（或列）有公因子$k$，可提出：  </p><ul><li>推论1：某行（或列）全为0，行列式为0。  </li><li>推论2：两行（或列）成比例，行列式为0。</li></ul></li><li><p><strong>行列式拆分</strong><br>若某行（或列）为两元素之和，可拆分为两个行列式之和：<br>$$<br>\begin{vmatrix}a_1+b_1 &amp; \cdots \\ \vdots &amp; \ddots\end{vmatrix} &#x3D; \begin{vmatrix}a_1 &amp; \cdots \\ \vdots &amp; \ddots\end{vmatrix} + \begin{vmatrix}b_1 &amp; \cdots \\ \vdots &amp; \ddots\end{vmatrix}<br>$$</p></li><li><p><strong>倍加性质</strong><br>某行（或列）的$k$倍加到另一行（或列），行列式值不变。</p></li></ol><h2 id="1-2-行列式展开公式"><a href="#1-2-行列式展开公式" class="headerlink" title="1.2 行列式展开公式"></a>1.2 行列式展开公式</h2><ol><li><p><strong>余子式与代数余子式</strong>  </p><ul><li>余子式$M_{ij}$：划去$a_{ij}$所在行、列得到的$(n-1)$阶行列式。  </li><li>代数余子式$A_{ij} &#x3D; (-1)^{i+j}M_{ij}$。</li></ul></li><li><p><strong>展开定理</strong>  </p><ul><li><p><strong>定理1.1</strong>：行列式可按任意行（列）展开：<br>$$<br>|A| &#x3D; \sum_{k&#x3D;1}^n a_{ik}A_{ik} \quad \text{（按第$i$行展开）}<br>$$</p><p>$$<br>|A| &#x3D; \sum_{k&#x3D;1}^n a_{kj}A_{kj} \quad \text{（按第$j$列展开）}<br>$$</p></li><li><p><strong>定理1.2</strong>：不同行（列）的代数余子式乘积和为0：<br>$$<br>\sum_{k&#x3D;1}^n a_{ik}A_{jk} &#x3D; 0 \quad (i \ne j)<br>$$</p></li></ul></li></ol><h2 id="1-3-特殊行列式"><a href="#1-3-特殊行列式" class="headerlink" title="1.3 特殊行列式"></a>1.3 特殊行列式</h2><ol><li><p><strong>三角形行列式</strong><br> 上（下）三角行列式等于主对角线元素乘积：<br>$$<br>  \begin{vmatrix}a_{11} &amp; \cdots &amp; a_{1n} \\ &amp; \ddots &amp; \vdots \\ 0 &amp; &amp; a_{nn}\end{vmatrix} &#x3D; a_{11}a_{22}\cdots a_{nn}<br>$$</p></li><li><p><strong>副对角线行列式</strong><br>$$<br>  \begin{vmatrix}0 &amp; \cdots &amp; a_{1n} \\ \vdots &amp; \ddots &amp; \vdots \\ a_{n1} &amp; \cdots &amp; 0\end{vmatrix} &#x3D; (-1)^{\frac{n(n-1)}{2}} a_{1n}a_{2,n-1}\cdots a_{n1}<br>$$</p></li><li><p><strong>分块行列式（拉普拉斯展开）</strong></p></li></ol><ul><li><p>若$A$为$m$阶，$B$为$n$阶矩阵：<br>$$<br>\begin{vmatrix}A &amp; * \\ O &amp; B\end{vmatrix} &#x3D; |A|\cdot|B|<br>$$</p><p>$$<br>\begin{vmatrix}O &amp; A \\ B &amp; *\end{vmatrix} &#x3D; (-1)^{mn}|A|\cdot|B|<br>$$</p></li></ul><ol start="4"><li><strong>范德蒙行列式</strong><br>$$<br>  \begin{vmatrix}1 &amp; \cdots &amp; 1 \\ x_1 &amp; \cdots &amp; x_n \\ \vdots &amp; \ddots &amp; \vdots \\ x_1^{n-1} &amp; \cdots &amp; x_n^{n-1}\end{vmatrix} &#x3D; \prod_{1 \leq j &lt; i \leq n} (x_i - x_j)<br>$$<br>  注：</li></ol><h2 id="1-4-克拉默法则"><a href="#1-4-克拉默法则" class="headerlink" title="1.4 克拉默法则"></a>1.4 克拉默法则</h2><p><strong>定理1.3（克拉默法则）</strong></p><p>对于由 ( n ) 个方程、( n ) 个未知量构成的非齐次线性方程组：<br>$$<br>\begin{cases}<br>a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n &#x3D; b_1, \\<br>a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n &#x3D; b_2, \\<br>\vdots \\<br>a_{n1}x_1 + a_{n2}x_2 + \cdots + a_{nn}x_n &#x3D; b_n<br>\end{cases}<br>$$<br>若其系数行列式 ( $|A| \neq 0 $)，则方程组有唯一解：<br>$$<br>x_i &#x3D; \frac{|A_i|}{|A|}, \quad i &#x3D; 1, 2, \cdots, n<br>$$<br>其中 ($ |A_i| $) 是将 $( |A| $) 的第 ($ i $) 列替换为常数项 ( $b_1, b_2, \cdots, b_n $) 所得的行列式。</p><p><strong>注：</strong></p><ol><li><strong>唯一解条件</strong>：仅当 ($ |A| \neq 0 $) 时适用。  </li><li><strong>特殊情况</strong>：  <ul><li>若 ( $|A| &#x3D; 0 $)，方程组可能无解或有无穷多解，但<strong>不可能有唯一解</strong>。</li></ul></li></ol><p><strong>推论（齐次线性方程组）</strong></p><p>对于齐次线性方程组（常数项全为0）：  </p><ul><li>若 ( $|A| \neq 0 $)，方程组仅有零解 ($ x_1 &#x3D; x_2 &#x3D; \cdots &#x3D; x_n &#x3D; 0 $)。  </li><li>若 ($ |A| &#x3D; 0 $)，方程组存在非零解（无穷多解）。</li></ul><h1 id="2、矩阵"><a href="#2、矩阵" class="headerlink" title="2、矩阵"></a>2、矩阵</h1><h2 id="2-1-矩阵多项式"><a href="#2-1-矩阵多项式" class="headerlink" title="2.1 矩阵多项式"></a>2.1 矩阵多项式</h2><h2 id="2-2-运算法则"><a href="#2-2-运算法则" class="headerlink" title="2.2 运算法则"></a>2.2 运算法则</h2><h3 id="1-加法"><a href="#1-加法" class="headerlink" title="(1) 加法"></a>(1) 加法</h3><p>设 $A$, $B$, $C$ 为同型矩阵，则：  </p><ul><li><strong>交换律</strong>：$A + B &#x3D; B + A$  </li><li><strong>结合律</strong>：$(A + B) + C &#x3D; A + (B + C)$  </li><li><strong>零矩阵</strong>：$A + O &#x3D; A$（$O$ 为同型零矩阵）  </li><li><strong>负矩阵</strong>：$A + (-A) &#x3D; O$</li></ul><h3 id="2-数乘矩阵"><a href="#2-数乘矩阵" class="headerlink" title="(2) 数乘矩阵"></a>(2) 数乘矩阵</h3><p>设 $k$, $m$ 为标量，则：  </p><ul><li><strong>结合性</strong>：$k(mA) &#x3D; (km)A &#x3D; m(kA)$  </li><li><strong>分配律</strong>：$(k + m)A &#x3D; kA + mA$  </li><li><strong>线性性</strong>：$k(A + B) &#x3D; kA + kB$  </li><li><strong>单位数乘</strong>：$1A &#x3D; A$, $0A &#x3D; O$</li></ul><h3 id="3-乘法"><a href="#3-乘法" class="headerlink" title="(3) 乘法"></a>(3) 乘法</h3><p>若矩阵 $A$, $B$, $C$ 满足乘法条件，则：  </p><ul><li><strong>结合律</strong>：$(AB)C &#x3D; A(BC)$  </li><li><strong>左分配律</strong>：$A(B + C) &#x3D; AB + AC$  </li><li><strong>右分配律</strong>：$(B + C)A &#x3D; BA + CA$</li></ul><h3 id="4-转置"><a href="#4-转置" class="headerlink" title="(4) 转置"></a>(4) 转置</h3><ul><li><strong>和的转置</strong>：$(A + B)^T &#x3D; A^T + B^T$  </li><li><strong>数乘转置</strong>：$(kA)^T &#x3D; kA^T$  </li><li><strong>积的转置</strong>：$(AB)^T &#x3D; B^T A^T$ </li><li><strong>转置的转置</strong>：$(A^T)^T &#x3D; A$</li></ul><hr><p><strong>注</strong>：矩阵乘法一般不满足交换律（即 $AB \neq BA$）。  </p><h2 id="2-3-对角矩阵的性质与运算"><a href="#2-3-对角矩阵的性质与运算" class="headerlink" title="2.3 对角矩阵的性质与运算"></a>2.3 对角矩阵的性质与运算</h2><p>对角矩阵乘法</p><p>两个对角矩阵相乘结果仍为对角矩阵，且元素为对应位置相乘:<br>$$<br>\begin{bmatrix}<br>a_1 &amp; 0 &amp; 0 \\<br>0 &amp; a_2 &amp; 0 \\<br>0 &amp; 0 &amp; a_3<br>\end{bmatrix}<br>\begin{bmatrix}<br>b_1 &amp; 0 &amp; 0 \\<br>0 &amp; b_2 &amp; 0 \\<br>0 &amp; 0 &amp; b_3<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix}<br>a_1 b_1 &amp; 0 &amp; 0 \\<br>0 &amp; a_2 b_2 &amp; 0 \\<br>0 &amp; 0 &amp; a_3 b_3<br>\end{bmatrix}<br>$$</p><p><strong>性质</strong></p><ol><li><p><strong>交换律</strong><br>对角矩阵乘法可交换：$\Lambda_1 \Lambda_2 &#x3D; \Lambda_2 \Lambda_1$。</p></li><li><p><strong>逆矩阵</strong><br>若对角元素均非零（$a_i \neq 0$），其逆矩阵为元素取倒数：</p></li></ol><p>$$<br>\begin{bmatrix}<br>a_1 &amp; 0 &amp; 0 \\<br>0 &amp; a_2 &amp; 0 \\<br>0 &amp; 0 &amp; a_3<br>\end{bmatrix}^{-1} &#x3D; \begin{bmatrix}<br>\frac{1}{a_1} &amp; 0 &amp; 0 \\<br>0 &amp; \frac{1}{a_2} &amp; 0 \\<br>0 &amp; 0 &amp; \frac{1}{a_3}<br>\end{bmatrix}<br>$$</p><hr><h2 id="2-4-伴随矩阵"><a href="#2-4-伴随矩阵" class="headerlink" title="2.4 伴随矩阵"></a>2.4 伴随矩阵</h2><p>设 $A$ 是一个 $n$ 阶方阵（$n \geq 2$），其伴随矩阵 $A^*$（或记作 $\text{adj}(A)$）定义为：<br>$$<br>A^* &#x3D; \begin{bmatrix}<br>A_{11} &amp; A_{21} &amp; \cdots &amp; A_{n1} \\<br>A_{12} &amp; A_{22} &amp; \cdots &amp; A_{n2} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>A_{1n} &amp; A_{2n} &amp; \cdots &amp; A_{nn}<br>\end{bmatrix}<br>$$<br>其中 $A_{ij}$ 是矩阵 $A$ 的元素 $a_{ij}$ 的<strong>代数余子式</strong>（Cofactor），即：<br>$$<br>A_{ij} &#x3D; (-1)^{i+j} M_{ij},<br>$$<br>$M_{ij}$ 是 $A$ 删去第 $i$ 行第 $j$ 列后得到的 $(n-1)$ 阶子矩阵的行列式。</p><hr><p><strong>伴随矩阵的公式：</strong></p><p>$AA^* &#x3D; A^*A &#x3D; |A|E$</p><p>$(A^*)^{-1} &#x3D; (A^{-1})^* &#x3D; \frac{1}{|A|}A$ ($|A|\neq 0$)</p><p>$(kA)^* &#x3D; k^{n-1}A^*$</p><p>$(A^*)^{\top} &#x3D; (A^{\top})^*$</p><p>$|A^*| &#x3D; |A|^{n-1}$</p><p>$(A^*)^* &#x3D; |A|^{n-2}A$ ($n \geq 2$)</p><hr><h2 id="2-4-可逆矩阵的概念与定理"><a href="#2-4-可逆矩阵的概念与定理" class="headerlink" title="2.4 可逆矩阵的概念与定理"></a>2.4 可逆矩阵的概念与定理</h2><p><strong>定义</strong> 设 $A$ 是 $n$ 阶矩阵，如果存在 $n$ 阶矩阵 $B$ 使得</p><p>$AB &#x3D; BA &#x3D; E$（单位矩阵）</p><p>成立，则称 $A$ 是<strong>可逆矩阵</strong>或<strong>非奇异矩阵</strong>，$B$ 是 $A$ 的逆矩阵，记成 $A^{-1} &#x3D; B$。</p><p><strong>定理 2.1</strong> 若 $A$ 可逆，则 $A$ 的逆矩阵唯一。</p><p><strong>定理 2.2</strong> $A$ 可逆 $\Leftrightarrow$ $|A| \neq 0$。</p><p><strong>定理 2.3</strong> 设 $A$ 和 $B$ 是 $n$ 阶矩阵且 $AB &#x3D; E$，则 $BA &#x3D; E$。</p><hr><p><strong>3. $n$ 阶矩阵 $A$ 可逆的充分必要条件</strong></p><ol><li>存在 $n$ 阶矩阵 $B$，使 $AB &#x3D; E$（或 $BA &#x3D; E$）</li><li>$|A| \neq 0$，或秩 $r(A) &#x3D; n$，或 $A$ 的列（行）向量线性无关</li><li>齐次方程组 $Ax &#x3D; 0$ 只有零解</li><li>$\forall b$，非齐次线性方程组 $Ax &#x3D; b$ 总有唯一解</li><li>矩阵 $A$ 的特征值全不为 0</li></ol><hr><p><strong>4. 逆矩阵的运算性质</strong></p><p>若 $k \neq 0$, $A$ 可逆，则 $(kA)^{-1} &#x3D; \frac{1}{k}A^{-1}$。</p><p>若 $A, B$ 可逆，则 $(AB)^{-1} &#x3D; B^{-1}A^{-1}$，特别地 $(A^2)^{-1} &#x3D; (A^{-1})^2$。</p><p>若 $A^{\top}$ 可逆，则 $(A^{\top})^{-1} &#x3D; (A^{-1})^{\top}$；$(A^{-1})^{-1} &#x3D; A$；$|A^{-1}| &#x3D; \frac{1}{|A|}$。</p><p><strong>注意</strong> 即使 $A, B$ 和 $A + B$ 都可逆，一般地 $(A + B)^{-1} \neq A^{-1} + B^{-1}$。</p><hr><p><strong>5. 求逆矩阵的方法</strong></p><p><strong>方法一</strong> 用公式，若 $|A|\neq0$，则 $A^{-1}&#x3D;\frac{1}{|A|}A^*$。</p><p><strong>方法二</strong> 初等变换法。$(A:E) \xrightarrow{\text{初等行变换}} (E:A^{-1})$。</p><p><strong>方法三</strong> 用定义求 $B$，使 $AB&#x3D;E$ 或 $BA&#x3D;E$，则 $A$ 可逆，且 $A^{-1}&#x3D;B$。</p><p><strong>方法四</strong> 用分块矩阵。</p><p>设 $B,C$ 都是可逆矩阵，则<br>$$<br>\begin{bmatrix}<br>B &amp; O \\<br>O &amp; C<br>\end{bmatrix}^{-1} &#x3D;<br>\begin{bmatrix}<br>B^{-1} &amp; O \\<br>O &amp; C^{-1}<br>\end{bmatrix},<br>\begin{bmatrix}<br>O &amp; B \\<br>C &amp; O<br>\end{bmatrix}^{-1} &#x3D;<br>\begin{bmatrix}<br>O &amp; C^{-1} \\<br>B^{-1} &amp; O<br>\end{bmatrix}<br>$$</p><hr><h1 id="3、向量"><a href="#3、向量" class="headerlink" title="3、向量"></a>3、向量</h1><h2 id="3-1线性组合和线性表示"><a href="#3-1线性组合和线性表示" class="headerlink" title="3.1线性组合和线性表示"></a>3.1线性组合和线性表示</h2><ol><li>给定向量组 $A：a_1,a_2,a_3,…,a_m$，对于任何一组实数$k_1,k_2,k_3,…,k_m$，表达式 $k_1a_1+k_2a_2+k_3a_3+···+k_ma_m$ 称为向量组 <strong>A</strong> 的一个<strong>线性组合</strong>，$k_1,k_2,k_3,…,K_m$称为这个线性组合的系数</li><li>给定向量组 $A：a_1,a_2,a_3,…,a_m$，向量 $b$ ，如果存在一组数$λ_1,λ_2,λ_3,···,λ_m$，使 $b&#x3D;λ_1a_1+λ_2a_2+λ_3a_3+···+λ_ma_m$ ，则向量 <strong>b</strong> 是向量组 <strong>A</strong> 的线性组合，这时称<strong>向量 b 能由向量组 A 线性表示</strong></li></ol><p><strong>定理：</strong></p><ul><li>向量 $b$ 由向量组 $A：a_1,a_2,a_3,…,a_m$ 表示的充分必要条件是矩阵 $A&#x3D;(a_1,a_2,a_3,···,a_m)$ 的秩等于矩阵 $B&#x3D;(a_1,a_2,a_3,…,a_m,b)$ 的秩</li><li>若 A ，B能互相表示，则称他们是<strong>等价的</strong></li><li>向量组 A 能由向量组 B <strong>线性表示</strong>的充分必要条件为 $R(A)&#x3D;R(A,B)$，<strong>或者</strong>$R(A) ≤ R(B)$，<strong>等价的充要条件</strong>为 $R(A)&#x3D;R(B)&#x3D;R(A,B)$</li></ul><h2 id="3-2-线性相关与线性无关"><a href="#3-2-线性相关与线性无关" class="headerlink" title="3.2 线性相关与线性无关"></a>3.2 线性相关与线性无关</h2><ol><li>给定向量组 $A：a_1,a_2,a_3,…,a_m$，存在不全为零实数$k_1,k_2,k_3,…,k_m$，使 $k_1a_1+k_2a_2+k_3a_3+···+k_ma_m &#x3D; 0$ ，则称向量组 A 是<strong>线性相关</strong>的，否则称他<strong>线性无关</strong></li></ol><div class="note note-success">            <p>简单来说：</p><ol><li><strong>线性相关：有非零解</strong></li><li><strong>线性无关：只有零解</strong></li></ol>          </div><p><strong>重要结论：</strong></p><ul><li><div class="note note-success">            <ol><li>方阵形式：直接判断行列式的值是否为零，线性相关D为0，线性无关D不为0</li><li>行数大于列数的矩阵：判断齐次线性方程组的解，<strong>线性相关有非零解</strong>，<strong>线性无关只有零解</strong></li><li>列数大于行数的矩阵：向量个数大于维数，一定线性相关</li></ol>          </div></li><li><p>向量组  $a_1,a_2,a_3,…,a_m$ <strong>线性相关</strong>的充分必要条件是：其中<strong>至少有一个向量可由</strong>其余 m -1 个向量线性表示</p></li><li><p>向量组 $a_1,a_2,a_3,…,a_m$ <strong>线性无关</strong>的充分必要条件是：其中<strong>每一个向量</strong>都<strong>不能由</strong>其余 m -1 个向量线性表示</p></li><li><p>若向量组 $a_1,a_2,a_3,…,a_m$ 线性无关，而向量组 $a_1,a_2,a_3,…,a_m,b$ 线性相关，<strong>则 b 可由 $a_1,a_2,a_3,…,a_m$ 线性表示，且表达式唯一</strong></p></li></ul><p><code>注：线性表示和线性相关性是不同的概念</code></p><hr><ul><li>若部分线性相关，则整个向量组也线性相关</li><li>若整体线性无关，则任意一个部分也线性无关</li><li>如果n维向量组$a_1,a_2,a_3,…,a_m$ 线性无关，则在每一个向量上都添加 m 个分量，得到的 <strong>n+m 维接长的向量组也线性无关</strong></li><li>如果n维向量组 $a_1,a_2,a_3,…,a_m$ 线性相关，则在每一个向量上都减去 m 个分量，得到的 <strong>n-m 维截断的向量组也线性相关</strong></li></ul><hr><ul><li>向量组线性无关 ⇔  秩等于向量个数</li><li>线性相关 ⇔  秩小于向量个数</li></ul><hr><h2 id="3-3-向量组的秩"><a href="#3-3-向量组的秩" class="headerlink" title="3.3 向量组的秩"></a>3.3 向量组的秩</h2><p><strong>定义：</strong>向量组的极大无关组所包含向量的个数，称为<strong>向量组的的秩</strong></p><p><strong>定理：</strong></p><ul><li>如果两个向量组的秩相等，且其中一个向量组可由另一个线性表示，则两个向量组等价</li></ul><p><strong>行向量组与列向量组</strong>：</p><ul><li>行向量组的秩为<strong>行秩</strong>，列向量组的秩为<strong>列秩</strong></li><li><strong>行秩&#x3D;列秩&#x3D;矩阵的秩</strong></li></ul><h2 id="3-4-极大无关组"><a href="#3-4-极大无关组" class="headerlink" title="3.4 极大无关组"></a>3.4 极大无关组</h2><p>定义：设向量组 $A：a_1,a_2,a_3,…,a_m$中有一部分向量组  $a_1,a_2,a_3,…,a_r  (r&lt;n)$满足</p><ol><li>$a_1,a_2,a_3,…,a_r $<strong>线性无关</strong></li><li>向量组 A 中任意 $r+1$(如果有 $r+1$个向量的话) ，则称 $a_1,a_2,a_3,…,a_r $是向量组 A 的一个<strong>极大线性无关组</strong>。简称为极大无关组</li></ol><div class="note note-success">            <p>&emsp;&emsp;求向量组极大无关组的方法：先将列向量组构成矩阵A，然后对A实行初等行变换，把A化为行最简型矩阵，由行最简型矩阵列之间的关系，确定原向量组间的线性关系，从而确定极大无关组。(<strong>行最简型矩阵中每行首个非零元素所在的列</strong>)</p>          </div><h2 id="3-5-内积"><a href="#3-5-内积" class="headerlink" title="3.5 内积"></a>3.5 内积</h2><h3 id="3-5-1-定义与性质"><a href="#3-5-1-定义与性质" class="headerlink" title="3.5.1 定义与性质"></a>3.5.1 定义与性质</h3><ol><li><p><strong>内积定义</strong>：对于向量$\mathbf{a}&#x3D;(a_1,…,a_n)$和$\mathbf{b}&#x3D;(b_1,…,b_n)$，其内积为：<br>$$[\mathbf{a},\mathbf{b}] &#x3D; \sum_{i&#x3D;1}^n a_ib_i$$</p></li><li><p><strong>矩阵内积</strong>：对于$m×n$矩阵$A,B$，其内积为：<br>$$[A,B] &#x3D; \sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^n a_{ij}b_{ij}$$</p></li><li><p><strong>向量长度（范数）</strong>：<br>$$|\mathbf{a}| &#x3D; \sqrt{[\mathbf{a},\mathbf{a}]} &#x3D; \sqrt{\sum_{i&#x3D;1}^n a_i^2}$$</p></li><li><p><strong>单位向量</strong>：若$|\mathbf{a}|&#x3D;1$，则称$\mathbf{a}$为单位向量</p></li><li><p><strong>施瓦茨不等式</strong>：<br>$$|[\mathbf{a},\mathbf{b}]| \leq |\mathbf{a}|\cdot|\mathbf{b}|$$</p></li></ol><h3 id="3-5-2-重要性质"><a href="#3-5-2-重要性质" class="headerlink" title="3.5.2 重要性质"></a>3.5.2 重要性质</h3><ul><li>对称性：$[\mathbf{a},\mathbf{b}]&#x3D;[\mathbf{b},\mathbf{a}]$</li><li>线性性：$[k\mathbf{a}+\mathbf{b},\mathbf{c}]&#x3D;k[\mathbf{a},\mathbf{c}]+[\mathbf{b},\mathbf{c}]$</li><li>正定性：$[\mathbf{a},\mathbf{a}] \geq 0$，且$[\mathbf{a},\mathbf{a}]&#x3D;0 \iff \mathbf{a}&#x3D;\mathbf{0}$</li></ul><div class="note note-success">            <p><strong>例题1</strong>：计算向量$\mathbf{a}&#x3D;(1,2,3)$和$\mathbf{b}&#x3D;(4,-5,6)$的内积和长度。</p><p>解：</p><ol><li><p>内积：<br>$$[\mathbf{a},\mathbf{b}] &#x3D; 1×4 + 2×(-5) + 3×6 &#x3D; 4-10+18&#x3D;12$$</p></li><li><p>长度：<br>$$|\mathbf{a}| &#x3D; \sqrt{1^2+2^2+3^2} &#x3D; \sqrt{14}$$<br>$$|\mathbf{b}| &#x3D; \sqrt{4^2+(-5)^2+6^2} &#x3D; \sqrt{77}$$</p></li></ol>          </div><hr><h2 id="3-6-正交向量组"><a href="#3-6-正交向量组" class="headerlink" title="3.6 正交向量组"></a>3.6 正交向量组</h2><h3 id="3-6-1-基本概念"><a href="#3-6-1-基本概念" class="headerlink" title="3.6.1 基本概念"></a>3.6.1 基本概念</h3><ol><li><strong>正交定义</strong>：若$[\mathbf{a},\mathbf{b}]&#x3D;0$，则称向量$\mathbf{a}$与$\mathbf{b}$正交</li><li><strong>正交向量组</strong>：由非零向量组成的向量组，其中任意两个不同向量都正交</li><li><strong>标准正交基</strong>：由单位向量组成的正交向量组</li></ol><hr><h3 id="3-6-2-重要定理"><a href="#3-6-2-重要定理" class="headerlink" title="3.6.2 重要定理"></a>3.6.2 重要定理</h3><ol><li><p><strong>正交向量组的线性无关性</strong>：<br>任何正交向量组都是线性无关的</p></li><li><p><strong>Gram-Schmidt正交化</strong>：<br>可将线性无关向量组转化为正交向量组：</p><ul><li>$\mathbf{b}_1 &#x3D; \mathbf{a}_1$</li><li>$\mathbf{b}_2 &#x3D; \mathbf{a}_2 - \frac{[\mathbf{a}_2,\mathbf{b}_1]}{[\mathbf{b}_1,\mathbf{b}_1]}\mathbf{b}_1$</li><li>$\mathbf{b}_3 &#x3D; \mathbf{a}_3 - \frac{[\mathbf{a}_3,\mathbf{b}_1]}{[\mathbf{b}_1,\mathbf{b}_1]}\mathbf{b}_1 - \frac{[\mathbf{a}_3,\mathbf{b}_2]}{[\mathbf{b}_2,\mathbf{b}_2]}\mathbf{b}_2$</li><li>…</li></ul></li></ol><hr><div class="note note-success">            <p><strong>例题2</strong>：验证向量组$\mathbf{a}_1&#x3D;(1,1,1)$，$\mathbf{a}_2&#x3D;(1,-1,0)$，$\mathbf{a}_3&#x3D;(1,1,-2)$是否正交。</p><p><strong>解：</strong><br>计算各对内积：</p><ol><li>$[\mathbf{a}_1,\mathbf{a}_2] &#x3D; 1×1 + 1×(-1) + 1×0 &#x3D; 0$</li><li>$[\mathbf{a}_1,\mathbf{a}_3] &#x3D; 1×1 + 1×1 + 1×(-2) &#x3D; 0$</li><li>$[\mathbf{a}_2,\mathbf{a}_3] &#x3D; 1×1 + (-1)×1 + 0×(-2) &#x3D; 0$<br>因此该向量组是正交向量组。</li></ol><p><strong>例题3</strong>：将线性无关向量组$\mathbf{a}_1&#x3D;(1,1,0)$，$\mathbf{a}_2&#x3D;(1,0,1)$，$\mathbf{a}_3&#x3D;(0,1,1)$正交化。</p><p><strong>解：</strong><br>使用Gram-Schmidt正交化：</p><ol><li>$\mathbf{b}_1 &#x3D; \mathbf{a}_1 &#x3D; (1,1,0)$</li><li>$\mathbf{b}_2 &#x3D; \mathbf{a}_2 - \frac{[\mathbf{a}_2,\mathbf{b}_1]}{[\mathbf{b}_1,\mathbf{b}_1]}\mathbf{b}_1 &#x3D; (1,0,1) - \frac{1}{2}(1,1,0) &#x3D; (\frac{1}{2},-\frac{1}{2},1)$</li><li>$\mathbf{b}_3 &#x3D; \mathbf{a}_3 - \frac{[\mathbf{a}_3,\mathbf{b}_1]}{[\mathbf{b}_1,\mathbf{b}_1]}\mathbf{b}_1 - \frac{[\mathbf{a}_3,\mathbf{b}_2]}{[\mathbf{b}_2,\mathbf{b}_2]}\mathbf{b}_2 &#x3D; (0,1,1) - \frac{1}{2}(1,1,0) - \frac{1&#x2F;2}{3&#x2F;2}(\frac{1}{2},-\frac{1}{2},1) &#x3D; (-\frac{2}{3},\frac{2}{3},\frac{2}{3})$</li></ol><p>最终得到正交向量组：$\mathbf{b}_1&#x3D;(1,1,0)$，$\mathbf{b}_2&#x3D;(\frac{1}{2},-\frac{1}{2},1)$，$\mathbf{b}_3&#x3D;(-\frac{2}{3},\frac{2}{3},\frac{2}{3})$</p>          </div><hr><h1 id="4、线性方程组"><a href="#4、线性方程组" class="headerlink" title="4、线性方程组"></a>4、线性方程组</h1><h2 id="4-1-非齐次"><a href="#4-1-非齐次" class="headerlink" title="4.1 非齐次"></a>4.1 非齐次</h2><ul><li>线性方程组 $A_{mn}$ * $x$&#x3D;b <strong>有解</strong>的 充要条件 是 r(A，b)&#x3D; r(A)</li><li>当线性方程组 $A_{mn} * x$&#x3D;b 有解时：r 为秩，n为系数项数，即未知量的个数(列向量个数)<ul><li>若 r(A，b)&#x3D; r(A)&#x3D;<strong>r &#x3D; n</strong>，方程组有<strong>唯一解</strong></li><li>若 r(A，b)&#x3D; r(A)&#x3D;<strong>r &lt; n</strong>，方 程组有<strong>无穷多解</strong></li></ul></li><li>同理， $A_{mn }* x $&#x3D;b <strong>无解</strong>的充要条件是 r(A，b)!&#x3D;r(A)</li></ul><hr><h2 id="4-2-齐次线性方程组解的判定"><a href="#4-2-齐次线性方程组解的判定" class="headerlink" title="4.2 齐次线性方程组解的判定"></a>4.2 齐次线性方程组解的判定</h2><p>齐次线性方程组一定满足：$r(A,b)$&#x3D;$r(A)$</p><ul><li>齐次线性方程组$A_{mn} * x&#x3D;0$ <strong>只有零解的充要条件是 r(A)&#x3D; n</strong></li><li>齐次线性方程组$A_{mn} * x&#x3D;0$ <strong>有非零解的充要条件是 r(A)&lt; n</strong>（有非零解即为无穷多解）</li></ul><hr><h2 id="4-3齐次线性方程组的解的结构"><a href="#4-3齐次线性方程组的解的结构" class="headerlink" title="4.3齐次线性方程组的解的结构"></a>4.3齐次线性方程组的解的结构</h2><p>解向量的概念</p><p>&emsp;&emsp;若齐次线性方程组有非零解，则它会有无穷多解，这些解组成一个n维向量组，若能求出这个向量组的一个极大无关组，则就能用它来表示它的全部解，<strong>这个极大无关组</strong>称为<strong>齐次线性方程组的基础解系</strong></p><p>齐次线性方程组有非零解，则它一定有基础解系。</p><ul><li><strong>定理1</strong>：如果齐次线性方程组$A_{mn} * x&#x3D;0$ 的系数矩阵A的秩 $r(A)&#x3D; r &lt; n$，则$A_{mn} * x&#x3D;0$ 的基础解系中有 $n-r$ 个解向量</li></ul><hr><h2 id="4-4非齐次线性方程组的解的结构"><a href="#4-4非齐次线性方程组的解的结构" class="headerlink" title="4.4非齐次线性方程组的解的结构"></a>4.4非齐次线性方程组的解的结构</h2><p>非齐次线性方程组的解的结构为：非齐次线性方程组的特解 + 齐次线性方程组的通解。</p><blockquote><p>求线性方程组通解的一般步骤</p><p>齐次线性方程组：</p></blockquote><blockquote><ol><li>对于增广矩阵化简为 <strong>行最简型矩阵</strong></li></ol></blockquote><blockquote><ol start="2"><li>判断解的情况并且得到解向量的个数 &#x3D; n-r</li></ol></blockquote><blockquote><ol start="2"><li><span style="color:red"><strong>判断解的情况并且得到解向量的个数 &#x3D; n-r</strong></span></li><li>通过行最简矩阵得到<strong>自由未知量</strong>，首非零元与自由未知量确定方程，求方程解，得到各个未知量的解，并且得到每一个<strong>基础解系</strong></li><li>通解为 各个基础解系的k倍和</li></ol></blockquote><blockquote><p>非齐次线性方程组：</p><ol><li>步骤与上面基本一致，但是通解为：特解 + 导出组（导出组指的是常数项为0）的基础解系</li></ol></blockquote><h1 id="5-特征值和特征向量"><a href="#5-特征值和特征向量" class="headerlink" title="5. 特征值和特征向量"></a>5. 特征值和特征向量</h1><h2 id="5-1-基本概念与定理"><a href="#5-1-基本概念与定理" class="headerlink" title="5.1 基本概念与定理"></a>5.1 基本概念与定理</h2><p><strong>定义</strong>:  设$A$是$n$阶方阵，若存在数$\lambda$和非零向量$\alpha$使得：  $A\alpha &#x3D; \lambda\alpha$，  则称$\lambda$为$A$的特征值，$\alpha$为对应$\lambda$的特征向量。</p><ul><li><p>带参数r的n阶方阵称为A的<strong>特征方阵</strong>；</p></li><li><p>它的行列式称为A的<strong>特征多项式</strong>；</p></li><li><p>$|\lambda E-A|$&#x3D;0称为A的<strong>特征方程</strong></p></li></ul><p>求解特征值与特征向量的方法：</p><ul><li><strong>n阶实方阵的特征值就是它的特征方程的n个根</strong></li><li><strong>任意取定一个特征值，其对应特征向量就是相应齐次线性方程组（rE-A）x&#x3D;0 的所有非零解</strong></li></ul><div class="note note-success">            <p>例题1：求特征值和特征向量</p><p>  求矩阵$A&#x3D;\begin{bmatrix}3&amp;1\\1&amp;3\end{bmatrix}$的特征值和特征向量。</p><p>  <strong>解</strong>：</p><ol><li><p>特征方程：<br>$$<br>\begin{vmatrix}<br>  3-\lambda &amp; 1 \\<br>  1 &amp; 3-\lambda<br>  \end{vmatrix} &#x3D; (3-\lambda)^2 -1 &#x3D; 0<br>$$<br>  解得：$\lambda_1&#x3D;2$，$\lambda_2&#x3D;4$</p></li><li><p>求特征向量：</p></li></ol><ul><li>对$\lambda_1&#x3D;2$：<br>$$<br>\begin{bmatrix}1&amp;1\\1&amp;1\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}&#x3D;0 \Rightarrow \alpha_1&#x3D;k\begin{bmatrix}1\\-1\end{bmatrix}<br>$$</li><li>对$\lambda_2&#x3D;4$：<br>$$<br>\begin{bmatrix}-1&amp;1\\1&amp;-1\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}&#x3D;0 \Rightarrow \alpha_2&#x3D;k\begin{bmatrix}1\\1\end{bmatrix}<br>$$</li></ul>          </div><hr><h2 id="5-2-矩阵对角化"><a href="#5-2-矩阵对角化" class="headerlink" title="5.2 矩阵对角化"></a>5.2 矩阵对角化</h2><p> <strong>对角化条件</strong></p><ol><li>$A$有$n$个线性无关特征向量</li><li>$A$的每个特征值的几何重数等于代数重数</li></ol><div class="note note-success">            <p><strong>例题：</strong>将$A&#x3D;\begin{bmatrix}2&amp;-1\\-1&amp;2\end{bmatrix}$对角化。</p><p><strong>解</strong>：</p><ol><li>特征值：$\lambda_1&#x3D;1$，$\lambda_2&#x3D;3$</li><li>特征向量：<ul><li>$\lambda_1&#x3D;1$对应$\alpha_1&#x3D;(1,1)^T$</li><li>$\lambda_2&#x3D;3$对应$\alpha_2&#x3D;(-1,1)^T$</li></ul></li><li>构造矩阵：<br>$$<br>P&#x3D;\begin{bmatrix}1&amp;-1\\1&amp;1\end{bmatrix}, \quad<br>P^{-1}&#x3D;\frac{1}{2}\begin{bmatrix}1&amp;1\\-1&amp;1\end{bmatrix}<br>$$</li><li>对角化结果：<br>$$<br>A&#x3D;P\begin{bmatrix}1&amp;0\\0&amp;3\end{bmatrix}P^{-1}<br>$$</li></ol>          </div><h2 id="5-3-特征值与特征向量的若干结论"><a href="#5-3-特征值与特征向量的若干结论" class="headerlink" title="5.3 特征值与特征向量的若干结论"></a>5.3 特征值与特征向量的若干结论</h2><ol><li><p><strong>实方阵的特征值未必是实数</strong>，特征向量也未必是实向量。</p></li><li><p><strong>三角矩阵的特征值</strong>：<br>上下三角矩阵的特征值就是它的全体对角元素。</p></li><li><p><strong>特征向量的唯一性</strong>：<br>一个向量 <strong>p</strong> 不可能是同一个方阵 <strong>A</strong> 的不同特征值的特征向量。</p></li><li><p><strong>方阵与其转置的特征值关系</strong>：<br>n阶方阵和它的转置具有相同的特征值。</p></li><li><p><strong>特征值与矩阵的关系</strong>：<br>设 <strong>r₁, r₂, …, rₙ</strong> 为方阵 <strong>A</strong> 的全体特征值，则必有：</p><ul><li><p><strong>特征值之和等于对角线元素之和（迹）</strong>：</p><p>$\sum_{i&#x3D;1}^{n} \lambda_{i} &#x3D; \sum_{i&#x3D;1}^{n} a_{ii} &#x3D; \text{tr}(A)$</p></li><li><p><strong>特征值之积等于行列式的值</strong>：<br>$\prod_{i&#x3D;1}^{n} \lambda_{i} &#x3D; |A|$</p></li></ul></li></ol><hr><h1 id="6、二次型"><a href="#6、二次型" class="headerlink" title="6、二次型"></a>6、二次型</h1><p>$n$元二次齐次函数：<br>$$<br>f(x_1,…,x_n)&#x3D;\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n a_{ij}x_ix_j \quad (a_{ij}&#x3D;a_{ji})<br>$$<br>矩阵形式：$f(\mathbf{x})&#x3D;\mathbf{x}^TA\mathbf{x}$</p><ul><li>A(<strong>对称矩阵</strong>)称为二次型f的矩阵，对称阵A的秩为二次型f的秩</li><li>二次型与对称阵具有一一对应的关系，一个二次型 f 由其对应的实对称矩阵 A 唯一确定。当给定了二次型 f 后，便可以确定其对应的实对称矩阵 A<ul><li>A 的对角线元素为：$a_{ii}$为$x_{i} ^2$项的<strong>系数</strong></li><li>A 的其他元素为： $a_{ij} &#x3D; a_{ji}$ 为 $x_{ij}$ 项的<strong>系数的 $2^{-1}$</strong></li></ul></li></ul><div class="note note-success">            <p>例题3：化二次型为标准形<br>化二次型$f&#x3D;2x_1^2+3x_2^2+4x_1x_2$为标准形。</p><p><strong>解法1（配方法）</strong>：<br>$$<br>\begin{aligned}<br>f &amp;&#x3D; 2x_1^2+4x_1x_2+3x_2^2 \\<br>&amp;&#x3D; 2(x_1^2+2x_1x_2+x_2^2)+x_2^2 \\<br>&amp;&#x3D; 2(x_1+x_2)^2+x_2^2<br>\end{aligned}<br>$$<br>令$y_1&#x3D;x_1+x_2$，$y_2&#x3D;x_2$，则$f&#x3D;2y_1^2+y_2^2$</p><p><strong>解法2（正交变换法）</strong>：</p><ol><li>写出矩阵$A&#x3D;\begin{bmatrix}2&amp;2\\2&amp;3\end{bmatrix}$</li><li>求特征值：$\lambda_1&#x3D;1$，$\lambda_2&#x3D;4$</li><li>标准形：$f&#x3D;y_1^2+4y_2^2$</li></ol>          </div><h2 id="6-1-标准型"><a href="#6-1-标准型" class="headerlink" title="6.1 标准型"></a>6.1 标准型</h2><p><strong>定义：只含平方项的 二次型称为二次型的标准型</strong></p><p>正交变换法化二次型为标准型的方法：</p><ol><li>写出二次型的矩阵A，求其特征值</li><li>求出特征值对应的特征向量，并且将他们<strong>正交单位化</strong></li><li>将正交单位化后的特征向量依次作为列向量构成<strong>正交矩阵 P</strong>。</li><li>做正交变换 $x&#x3D;Py$，得二次型的标准型</li></ol><blockquote><p>正交单位化的时候：</p><ol><li>如果对应不同的特征值，所以他们正交，直接单位化即可</li><li>如果对应<strong>相同的特征值</strong>，所以要<strong>首先正交化</strong>，然后<strong>再单位化</strong></li></ol></blockquote><hr><h2 id="6-2-合同"><a href="#6-2-合同" class="headerlink" title="6.2 合同"></a>6.2 合同</h2><p>对于两个矩阵A和B，如果存在可逆矩阵C，使得$C^TAC&#x3D;B$，就称A<strong>合同（或相合）</strong>于B，记作A≃B，也是一种等价关系。因此可以称A和B是合同矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>上岸</category>
      
      <category>线代</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线代</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis基本操作</title>
    <link href="/2025/06/10/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis/"/>
    <url>/2025/06/10/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="windows操作"><a href="#windows操作" class="headerlink" title="windows操作"></a>windows操作</h1><p><code>docker exec -it 容器名字 redis-cli --raw</code> ：进入redis 容器，以原始格式输出</p><hr><h1 id="服务器相关命令"><a href="#服务器相关命令" class="headerlink" title="服务器相关命令"></a>服务器相关命令</h1><p><code>ping</code> ： 检测连接是否存活<br><code>echo</code>： 在命令行打印一些内容<br><code>quit、exit</code>： 退出客户端<br><code>shutdown</code>： 退出服务器端<br><code>info</code>： 返回redis相关信息<br><code>config get dir/*</code>: 实时传递接收的请求<br><code>showlog</code>： 显示慢查询<br><code>select n</code>： 切换到数据库n，redis 默认有16个数据库（DB 0~DB 15），默认使用的第0个<br><code>dbsize</code>： 查看当前数据库大小<br><code>move key n</code>： 不同数据库之间数据是不能互通的，move移动键到指定数据库<br><code>flushdb</code>： 清空<strong>当前数据库</strong>中的键值对<br><code>flushall</code>： 清空<strong>所有数据库</strong>的键值对</p><hr><h1 id="key相关"><a href="#key相关" class="headerlink" title="key相关"></a>key相关</h1><p><code>keys * </code>：查看当前数据库中所有的key<br><code>dbsize</code>： 键总数<br><code>exists key</code>： 检查键是否存在<br><code>del key [key …]</code>： 删除键<br><code>expire key seconds</code>： 键过期<br><code>ttl key</code>： 获取键的有效时长<br><code>persist key</code>： 移除键的过期时间<br><code>type key</code>： 键的数据结构类型<br><code>randomkey</code>： 随机返回数据库中一个键<br><code>rename key1 key2</code> ： 重命名<br><code>renamex key1 key2</code> ： 当 key2 不存在时，key1 重命名</p><hr><h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">SET key value         <span class="hljs-comment"># 设置键值对</span><br>GET key               <span class="hljs-comment"># 获取键的值</span><br>INCR key              <span class="hljs-comment"># 键值递增 1（要求值为数字）</span><br>incrby key increment  <span class="hljs-comment"># 增加 increment</span><br>DECR key              <span class="hljs-comment"># 键值递减 1</span><br>APPEND key <span class="hljs-string">&quot;text&quot;</span>     <span class="hljs-comment"># 追加字符串到键值末尾</span><br>STRLEN key            <span class="hljs-comment"># 获取字符串长度</span><br>MSET key1 val1 key2 val2  <span class="hljs-comment"># 批量设置键值对</span><br>MGET key1 key2        <span class="hljs-comment"># 批量获取键的值</span><br></code></pre></td></tr></table></figure><hr><h1 id="哈希（Hash）操作"><a href="#哈希（Hash）操作" class="headerlink" title="哈希（Hash）操作"></a>哈希（Hash）操作</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">HSET user:1 name <span class="hljs-string">&quot;Alice&quot;</span> age 30  <span class="hljs-comment"># 设置哈希字段</span><br>HGET user:1 name                <span class="hljs-comment"># 获取哈希字段的值</span><br>HGETALL user:1                  <span class="hljs-comment"># 获取哈希的所有字段和值</span><br>HKEYS user:1                    <span class="hljs-comment"># 获取哈希的所有字段名</span><br>HVALS user:1                    <span class="hljs-comment"># 获取哈希的所有字段值</span><br>HINCRBY user:1 age 1            <span class="hljs-comment"># 哈希字段值递增</span><br></code></pre></td></tr></table></figure><p><code>user:1</code>：哈希的键名，通常使用 <code>对象类型:ID</code> 的格式</p><hr><h1 id="列表（List）操作"><a href="#列表（List）操作" class="headerlink" title="列表（List）操作"></a>列表（List）操作</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">LPUSH list <span class="hljs-string">&quot;item1&quot;</span> <span class="hljs-string">&quot;item2&quot;</span>      <span class="hljs-comment"># 从左侧插入元素</span><br>RPUSH list <span class="hljs-string">&quot;item3&quot;</span>              <span class="hljs-comment"># 从右侧插入元素</span><br>LPOP list                       <span class="hljs-comment"># 从左侧弹出元素</span><br>RPOP list                       <span class="hljs-comment"># 从右侧弹出元素</span><br>LRANGE list 0 -1                <span class="hljs-comment"># 获取列表所有元素</span><br>LLEN list                       <span class="hljs-comment"># 获取列表长度</span><br></code></pre></td></tr></table></figure><hr><h1 id="集合（Set）操作"><a href="#集合（Set）操作" class="headerlink" title="集合（Set）操作"></a>集合（Set）操作</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">SADD <span class="hljs-built_in">set</span> <span class="hljs-string">&quot;member1&quot;</span> <span class="hljs-string">&quot;member2&quot;</span>    <span class="hljs-comment"># 添加集合成员</span><br>SMEMBERS <span class="hljs-built_in">set</span>                    <span class="hljs-comment"># 获取集合所有成员</span><br>SISMEMBER <span class="hljs-built_in">set</span> <span class="hljs-string">&quot;member1&quot;</span>         <span class="hljs-comment"># 检查成员是否存在</span><br>SCARD <span class="hljs-built_in">set</span>                       <span class="hljs-comment"># 获取集合成员数量</span><br>SINTER set1 set2                <span class="hljs-comment"># 获取多个集合的交集</span><br>SUNION set1 set2                <span class="hljs-comment"># 获取多个集合的并集</span><br></code></pre></td></tr></table></figure><hr><h1 id="有序集合（Sorted-Set）操作"><a href="#有序集合（Sorted-Set）操作" class="headerlink" title="有序集合（Sorted Set）操作"></a>有序集合（Sorted Set）操作</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ZADD zset 10 <span class="hljs-string">&quot;member1&quot;</span> 20 <span class="hljs-string">&quot;member2&quot;</span>  <span class="hljs-comment"># 添加有序集合成员（分数在前）</span><br>ZRANGE zset 0 -1 WITHSCORES          <span class="hljs-comment"># 获取有序集合所有成员（按分数升序）</span><br>ZREVRANGE zset 0 -1 WITHSCORES       <span class="hljs-comment"># 获取有序集合所有成员（按分数降序）WITHSCORES：可选参数，指定是否返回分数。如果省略，则只返回成员名称</span><br>ZRANK zset <span class="hljs-string">&quot;member1&quot;</span>                 <span class="hljs-comment"># 获取成员的排名（分数升序）</span><br>ZCOUNT zset 10 20                    <span class="hljs-comment"># 获取分数范围内的成员数量</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git操作</title>
    <link href="/2025/06/10/%E4%B8%AD%E9%97%B4%E4%BB%B6/git/git%E6%93%8D%E4%BD%9C/"/>
    <url>/2025/06/10/%E4%B8%AD%E9%97%B4%E4%BB%B6/git/git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><img src="/../../../img/%E4%B8%AD%E9%97%B4%E4%BB%B6/git/1.jpg"></p><h1 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h1><p><strong>1、工作区 -&gt; 暂存区</strong></p><ul><li>使用<code>git add</code>命令将工作区中的修改添加到暂存区</li></ul><p><strong>2、暂存区 -&gt; 版本库</strong></p><ul><li>使用<code>git commit</code>命令将暂存区中的修改提交到版本库</li></ul><p><strong>3、版本库 -&gt; 远程仓库</strong></p><ul><li>使用 <code>git push</code> 命令将本地版本库的提交推送到远程仓库</li></ul><p><strong>4、远程仓库 -&gt; 本地版本库</strong></p><ul><li>使用 <code>git pull </code>或<code> git fetch</code> 命令从远程仓库获取更新</li></ul><hr><ul><li><strong>工作区</strong>是本地计算机上的项目目录，在这里进行文件的创建、修改和删除操作。工作区包含了当前项目的所有文件和子目录</li><li><strong>暂存区</strong>是一个临时存储区域，它包含了即将被提交到版本库中的文件快照，在提交之前，可以选择性地将工作区中的修改添加到暂存区</li><li>版本库包含项目的所有版本历史记录，每次提交都会在版本库中创建一个新的快照，这些快照是不可变的，确保了项目的完整历史记录</li><li><ol><li>版本库分为<strong>本地版本库</strong>和<strong>远程版本库</strong>。这里主要指本地版本库。</li><li>本地版本库存储在 <code>.git</code> 目录中，它包含了所有提交的对象和引用</li></ol></li></ul><hr><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1 步</span><br><span class="hljs-comment"># 初始化</span><br>git init  <span class="hljs-comment"># 初始化仓库</span><br>git <span class="hljs-built_in">clone</span> [url] <span class="hljs-comment"># 拷贝一份远程仓库，也就是下载一个项目</span><br></code></pre></td></tr></table></figure><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 2 步</span><br><span class="hljs-comment">#提交与修改</span><br>git add . / [file1] [file2] / [<span class="hljs-built_in">dir</span>]  <span class="hljs-comment"># 将当下目录 所有文件/某些文件/文件夹 添加到暂存区</span><br>git add -A   <span class="hljs-comment"># 添加所有修改过的文件（包括子目录）</span><br>git status                         <span class="hljs-comment"># 查看仓库当前的状态，显示有变更的文件</span><br>git reset [--soft | --mixed | --hard] [HEAD] <span class="hljs-comment"># 回退版本</span><br></code></pre></td></tr></table></figure><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 3 步</span><br>git commit -m <span class="hljs-string">&quot;Commit message&quot;</span>   <span class="hljs-comment"># 将暂存区的更改提交到本地版本库</span><br>git <span class="hljs-built_in">log</span>                          <span class="hljs-comment"># 查看提交历史</span><br>git diff                         <span class="hljs-comment"># 查看工作区和暂存区之间的差异</span><br>git diff --cached                <span class="hljs-comment"># 查看暂存区和最后一次提交之间的差异</span><br><br>git remote add &lt;remote_name&gt; &lt;remote_url&gt; <span class="hljs-comment"># 添加远程版本库</span><br>git remote -v <span class="hljs-comment"># 查看当前仓库中配置的远程仓库列表以及它们的 URL</span><br>git remote show [remote] <span class="hljs-comment"># 显示某个远程仓库的信息</span><br>git remote rename old_name new_name  <span class="hljs-comment"># 修改仓库名</span><br>git remote set-url &lt;remote_name&gt; &lt;new_url&gt; <span class="hljs-comment"># 修改指定远程仓库的 URL</span><br>git remote remove &lt;remote_name&gt; <span class="hljs-comment"># 从当前仓库中删除指定的远程仓库，或 git remote rm name</span><br>git push origin --delete master <span class="hljs-comment"># 远程仓库中的 master 分支将被永久删除</span><br></code></pre></td></tr></table></figure><ul><li><p><code>git status</code>通常使用 <strong>-s</strong> 参数来获得简短的输出结果，一般在前面会有字母的组合，<strong>AM</strong> 状态的意思是这个文件在将它添加到缓存之后又有改动（A 在暂存区 M修改了，应该是吧）</p></li><li><p><strong>reset</strong>： </p></li><li><ol><li><p><code>--mixed</code> 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset HEAD^            <span class="hljs-comment"># 回退所有内容到上一个版本  </span><br>git reset HEAD^ hello.php  <span class="hljs-comment"># 回退 hello.php 文件的版本到上一个版本  </span><br>git  reset  052e           <span class="hljs-comment"># 回退到指定版本</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>--soft</code>参数用于回退到某个版本</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --soft HEAD~3   <span class="hljs-comment"># 回退上上上一个版本 </span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>--hard</code> 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交（慎用，它会删除回退点之前的所有信息）</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD~3  <span class="hljs-comment"># 回退上上上一个版本  </span><br>git reset –hard bae128  <span class="hljs-comment"># 回退到某个版本回退点之前的所有信息。 </span><br>git reset --hard origin/master    <span class="hljs-comment"># 将本地的状态回退到和远程的一样 </span><br></code></pre></td></tr></table></figure></blockquote></li><li><blockquote><p><strong>HEAD 说明：</strong></p><ul><li><p>HEAD 表示当前版本</p></li><li><p>HEAD^ 上一个版本</p></li><li><p>HEAD^^ 上上一个版本</p></li><li><p>HEAD^^^ 上上上一个版本</p></li><li><p>以此类推…</p></li></ul><p>可以使用 ～数字表示</p><ul><li>HEAD~0 表示当前版本</li><li>HEAD~1 上一个版本</li><li>HEAD^2 上上一个版本</li><li>HEAD^3 上上上一个版本</li><li>以此类推…</li></ul></blockquote></li></ol></li><li><p><strong>git pull</strong> 其实就是 <strong>git fetch</strong> 和 <strong>git merge</strong> 的简写，先从远程仓库获取最新的提交记录，然后将这些提交记录合并到当前的分支中。</p></li></ul><hr><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; <span class="hljs-comment"># 如果本地分支名与远程分支名相同，则可以省略冒号及其后面内容</span><br>git push -f origin main <span class="hljs-comment"># 强推 ， 可能丢失他人代码，直接覆盖远程仓库分支</span><br></code></pre></td></tr></table></figure><hr><h2 id="远程早已更新产生问题"><a href="#远程早已更新产生问题" class="headerlink" title="远程早已更新产生问题"></a>远程早已更新产生问题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 远程分支已更新（如他人推送了新代码），而本地分支仍基于旧的提交</span><br><span class="hljs-comment"># （1）</span><br>git fetch origin  <span class="hljs-comment"># 从名为 origin 的远程仓库获取所有更新</span><br>git fetch origin main  <span class="hljs-comment"># 只获取远程的 main 分支</span><br>git fetch --all  <span class="hljs-comment"># 获取所有已配置远程仓库的更新</span><br>git fetch -p  <span class="hljs-comment"># 或 git fetch --prune  如果远程分支被删除，本地仍会保留记录。使用命令清理</span><br><span class="hljs-comment"># （2）</span><br>git merge origin/main  <span class="hljs-comment"># 将origin远程 main 分支合并到当前分支，执行完fetch之后要执行本操作进行合并</span><br><br>git branch -r  <span class="hljs-comment"># 列出所有远程分支</span><br>git pull [远程仓库名] [分支名] <span class="hljs-comment"># 从远程获取代码并合并本地的版本</span><br><span class="hljs-comment"># 举例：将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并（如果远程分支是与当前分支合并，则冒号后面的部分可以省略）</span><br>git pull origin master:brantest<br></code></pre></td></tr></table></figure><hr><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="1-日志："><a href="#1-日志：" class="headerlink" title="1.  日志："></a>1.  日志：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> -n &lt;number&gt; <span class="hljs-comment"># 限制显示的提交数</span><br>git <span class="hljs-built_in">log</span> --since=<span class="hljs-string">&quot;2024-01-01&quot;</span> <span class="hljs-comment"># 显示自指定日期之后的提交</span><br>git <span class="hljs-built_in">log</span> --<span class="hljs-keyword">until</span>=<span class="hljs-string">&quot;2024-07-01&quot;</span> <span class="hljs-comment"># 显示指定日期之前的提交</span><br>git <span class="hljs-built_in">log</span> --author=<span class="hljs-string">&quot;Author Name&quot;</span> <span class="hljs-comment"># 只显示某个作者的提交</span><br></code></pre></td></tr></table></figure><h3 id="2-撤销"><a href="#2-撤销" class="headerlink" title="2.  撤销"></a>2.  撤销</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert &lt;commit哈希值&gt;/[HEAD] <span class="hljs-comment"># 创建一个新的提交来抵消指定提交的修改，而不是直接删除历史记录,</span><br>git reset <span class="hljs-comment"># 直接删除历史记录，无法回退，一般不用</span><br></code></pre></td></tr></table></figure><ul><li>举例：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert 6d0f3b  <span class="hljs-comment"># 使用提交哈希的前几位（无需完整哈希）</span><br>git revert HEAD~3..HEAD  <span class="hljs-comment"># 撤销最近4次提交（HEAD~3 到 HEAD）</span><br></code></pre></td></tr></table></figure><h3 id="3-切换-创建分支"><a href="#3-切换-创建分支" class="headerlink" title="3. 切换&#x2F;创建分支"></a>3. 切换&#x2F;创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout &lt;branch-name&gt; <span class="hljs-comment"># 从当前分支切换到指定的分支 &lt;branch-name&gt;</span><br>git checkout -b &lt;new-branch-name&gt; <span class="hljs-comment"># 创建一个新分支 &lt;new-branch-name&gt; 并立即切换到新创建的分支</span><br>git checkout - <span class="hljs-comment"># 快速切换回前一个分支，无需记住分支名称</span><br>git checkout -- &lt;file&gt; <span class="hljs-comment"># 将工作区指定文件 &lt;file&gt; 恢复到最近一次提交时的状态，丢弃所有未提交的更改</span><br><br>git checkout -b &lt;分支名&gt; origin/&lt;分支名&gt; <span class="hljs-comment"># 快速建立联系</span><br></code></pre></td></tr></table></figure><h3 id="4-查看分支"><a href="#4-查看分支" class="headerlink" title="4. 查看分支"></a>4. 查看分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch <span class="hljs-comment"># 查看本地分支</span><br>git branch -r  <span class="hljs-comment"># 查看远程分支  或 --remotes  </span><br>git branch -a  <span class="hljs-comment"># 查看本地和远程分支  或 --all  </span><br>git branch --show-current  <span class="hljs-comment"># 查看当前分支   Git 2.22+ 版本支持</span><br>git branch -vv <span class="hljs-comment"># 查看分支关联关系</span><br><br>git branch --merged    <span class="hljs-comment"># 查看哪些分支已合并到当前分支</span><br>git branch --no-merged <span class="hljs-comment"># 查看哪些分支尚未合并到当前分支</span><br>git branch -m master main <span class="hljs-comment"># 重命名本地 master 为 main</span><br><br><br></code></pre></td></tr></table></figure><h3 id="5-查看分支差异"><a href="#5-查看分支差异" class="headerlink" title="5. 查看分支差异"></a>5. 查看分支差异</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> branch1..branch2  <span class="hljs-comment"># 显示 branch2 有但 branch1 没有的提交</span><br>git diff branch1..branch2  <span class="hljs-comment"># 显示两个分支的文件差异</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线代思维导图</title>
    <link href="/2025/06/10/%E7%BA%BF%E4%BB%A3/%E7%BA%BF%E4%BB%A3%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <url>/2025/06/10/%E7%BA%BF%E4%BB%A3/%E7%BA%BF%E4%BB%A3%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="1、行列式"><a href="#1、行列式" class="headerlink" title="1、行列式"></a>1、行列式</h1><p><img src="/../../img/%E7%BA%BF%E4%BB%A3%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%A1%8C%E5%88%97%E5%BC%8F.png"></p><h1 id="2、矩阵及其运算"><a href="#2、矩阵及其运算" class="headerlink" title="2、矩阵及其运算"></a>2、矩阵及其运算</h1><p><img src="/../../img/%E7%BA%BF%E4%BB%A3%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/2.png"></p><h1 id="3、-矩阵的初等变换与线性方程组"><a href="#3、-矩阵的初等变换与线性方程组" class="headerlink" title="3、 矩阵的初等变换与线性方程组"></a>3、 矩阵的初等变换与线性方程组</h1><p><img src="/../../img/%E7%BA%BF%E4%BB%A3%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/3.png"></p><h1 id="4、向量组的线性相关性"><a href="#4、向量组的线性相关性" class="headerlink" title="4、向量组的线性相关性"></a>4、向量组的线性相关性</h1><p><img src="/../../img/%E7%BA%BF%E4%BB%A3%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/4.png"></p><h1 id="5、相似矩阵及二次型"><a href="#5、相似矩阵及二次型" class="headerlink" title="5、相似矩阵及二次型"></a>5、相似矩阵及二次型</h1><p><img src="/../../img/%E7%BA%BF%E4%BB%A3%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.png"></p><h1 id="6、线性空间与线性变换"><a href="#6、线性空间与线性变换" class="headerlink" title="6、线性空间与线性变换"></a>6、线性空间与线性变换</h1><p><img src="/../../img/%E7%BA%BF%E4%BB%A3%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.png"></p><p><a href="https://www.bilibili.com/opus/747258631059144759">以上图片来自博客</a></p>]]></content>
    
    
    <categories>
      
      <category>上岸</category>
      
      <category>线代</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线代</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定积分</title>
    <link href="/2025/02/26/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
    <url>/2025/02/26/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0%E5%AE%9A%E7%A7%AF%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-极限转为定积分"><a href="#1-极限转为定积分" class="headerlink" title="1. 极限转为定积分"></a>1. 极限转为定积分</h2><p>从极限转为定积分的核心思想是通过 <strong>黎曼和</strong> 将求和问题转化为积分问题。常见的转化公式包括：</p><ol><li><p>均匀分割的求和极限：<br>$$<br>\lim_{n \to \infty} \sum_{i&#x3D;1}^n f\left(a + i \cdot \frac{b - a}{n}\right) \cdot \frac{b - a}{n} &#x3D; \int_a^b f(x) , dx<br>$$</p></li><li><p>无穷级数转定积分：<br>$$<br>\lim_{n \to \infty} \sum_{i&#x3D;1}^n f\left(\frac{i}{n}\right) \cdot \frac{1}{n} &#x3D; \int_0^1 f(x) , dx<br>$$</p></li></ol><h2 id="2-常用的不定积分积分方法"><a href="#2-常用的不定积分积分方法" class="headerlink" title="2.常用的不定积分积分方法"></a>2.常用的不定积分积分方法</h2><h3 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h3><h4 id="1-分部积分法所适用的函数类"><a href="#1-分部积分法所适用的函数类" class="headerlink" title="(1) 分部积分法所适用的函数类"></a>(1) 分部积分法所适用的函数类</h4><p>$$<br>\int u d v&#x3D;uv-\int v d u<br>$$</p><h4 id="2-分部积分法所适用的函数类"><a href="#2-分部积分法所适用的函数类" class="headerlink" title="(2) 分部积分法所适用的函数类"></a>(2) 分部积分法所适用的函数类</h4><p>分部积分法比较适用于两类不同函数相乘。如下列积分，这里 $ p_n(x) $ 为 $ x $ 的 $ n $ 次多项式。</p><p>$$<br>\int p_n(x) e^{ax} dx, \quad \int p_n(x) \sin ax dx,\int p_n(x) \cos ax dx,\quad \int e^{ax} \sin ax dx,<br>$$</p><p>$$<br>\int e^{ax} \cos ax dx, \quad \int p_n(x) \ln x dx,\int p_n(x) \arctan x dx, \quad \int p_n(x) \arcsin x dx.<br>$$</p><h4 id="3-分部积分法中-u-v-的选取"><a href="#3-分部积分法中-u-v-的选取" class="headerlink" title="(3) 分部积分法中 ( u,v ) 的选取"></a>(3) 分部积分法中 ( u,v ) 的选取</h4><p>分部积分法在使用时的关键是 ( u,v ) 的选取，换句话说就是把哪个数凑到微分号里去。</p><ol><li>$\int p_n(x) e^{ax} dx, \int p_n(x) \sin ax dx, \int p_n(x) \cos ax dx$，这3种积分都应多项式以外的函数凑进微分号。</li><li>$\int e^{ax} \sin ax dx, \int e^{ax} \cos ax dx$，这2种积分把指数函数或三角函数凑进微分号都可以，但把指数凑进去更简单，连续两次将指数函数凑进去分部积分还原便可求解。</li><li>$\int p_n(x) \ln x dx, \int p_n(x) \arctan x dx, \int p_n(x) \arcsin x dx$，这3种积分都应多项式函数凑进微分号。</li></ol><hr><h3 id="第二换元积分法"><a href="#第二换元积分法" class="headerlink" title="第二换元积分法"></a>第二换元积分法</h3><p><strong>定理</strong>  设 $ x &#x3D; \varphi(t) $ 是单调的、可导的函数，并且 $\varphi’(t) \neq 0$。又<br>$$<br>\int f[\varphi(t)]\varphi’(t)dt &#x3D; F(t) + C,<br>$$</p><p>则<br>$$<br>\int f(x)dx &#x3D; \int f[\varphi(t)]\varphi’(t)dt &#x3D; F(t) + C<br>$$</p><p>$$<br>&#x3D; F[\varphi^{-1}(x)] + C,<br>$$</p><p>其中 $ \varphi^{-1}(x) $ 是 $ x &#x3D; \varphi(t) $ 的反函数。</p><p><strong>常用的三种变量代换：</strong></p><ol><li><p>被积函数含有 $ \sqrt{a^2 - x^2} $，令 $x &#x3D; a\sin t $ (或 $a\cos t$)。</p></li><li><p>被积函数含有 $\sqrt{a^2 + x^2}$，令 $x &#x3D; a\tan t$。</p></li><li><p>被积函数含有 $\sqrt{x^2 - a^2}$，令 $x &#x3D; a\sec t$。</p></li></ol><hr><h3 id="三角有理式积分"><a href="#三角有理式积分" class="headerlink" title="三角有理式积分"></a>三角有理式积分</h3><p>$$<br>\int R(\sin x, \cos x) dx<br>$$</p><h4 id="1-一般方法（万能代换）"><a href="#1-一般方法（万能代换）" class="headerlink" title="(1) 一般方法（万能代换）"></a>(1) 一般方法（万能代换）</h4><p>令 $\tan \frac{x}{2} &#x3D; t$，</p><p>$$<br>\int R(\sin x, \cos x) dx &#x3D; \int R\left( \frac{2t}{1+t^2}, \frac{1-t^2}{1+t^2} \right) \frac{2}{1+t^2} dt<br>$$</p><h4 id="2-特殊方法（三角变形，换元，分部）"><a href="#2-特殊方法（三角变形，换元，分部）" class="headerlink" title="(2) 特殊方法（三角变形，换元，分部）"></a>(2) 特殊方法（三角变形，换元，分部）</h4><p>几种常用的换元法：</p><ol><li><p>若 $R(-\sin x, \cos x) &#x3D; -R(\sin x, \cos x)$，则令 $u &#x3D; \cos x$，或凑 $d \cos x$。</p></li><li><p>若 $R(\sin x, -\cos x) &#x3D; -R(\sin x, \cos x)$，则令 $u &#x3D; \sin x$，或凑 $d \sin x$。</p></li><li><p>若 $R(-\sin x, -\cos x) &#x3D; R(\sin x, \cos x)$，则令 $u &#x3D; \tan x$，或凑 $d \tan x$。</p></li></ol><hr><h2 id="3-定积分的积分方法"><a href="#3-定积分的积分方法" class="headerlink" title="3.定积分的积分方法"></a>3.定积分的积分方法</h2><p>定积分的计算主要有以下五种方法：</p><h3 id="1-牛顿—莱布尼茨公式"><a href="#1-牛顿—莱布尼茨公式" class="headerlink" title="1. 牛顿—莱布尼茨公式"></a>1. 牛顿—莱布尼茨公式</h3><p>设 $f(x)$ 在区间 $[a,b]$ 上连续，$F(x)$ 为 $f(x)$ 在 $[a,b]$ 上的一个原函数，则有<br>$$<br>\int_a^b f(x) dx &#x3D; F(x) \bigg|_a^b &#x3D; F(b) - F(a)。<br>$$</p><h3 id="2-换元积分法"><a href="#2-换元积分法" class="headerlink" title="2. 换元积分法"></a>2. 换元积分法</h3><p>设 $f(x)$ 在区间 $I$ 上连续，函数 $x &#x3D; \varphi(t)$ 满足以下条件：  </p><ol><li>$\varphi(\alpha) &#x3D; a, \varphi(\beta) &#x3D; b$。  </li><li>$\varphi(t)$ 在 $[\alpha,\beta]$（或 $[\beta,a]$）上有连续导数，且 $R_\varphi \subseteq I$，则<br>$$<br>\int_a^b f(x) dx &#x3D; \int_\alpha^\beta f[\varphi(t)] \varphi’(t) dt。<br>$$</li></ol><h3 id="3-分部积分法"><a href="#3-分部积分法" class="headerlink" title="3. 分部积分法"></a>3. 分部积分法</h3><p>$$<br>\int_a^b u dv &#x3D; uv \bigg|_a^b - \int_a^b v du。<br>$$</p><h3 id="4-利用奇偶性和周期性"><a href="#4-利用奇偶性和周期性" class="headerlink" title="4. 利用奇偶性和周期性"></a>4. 利用奇偶性和周期性</h3><p>(1) 设 $f(x)$ 为 $[-a,a]$ 上的连续函数 ($a&gt;0$)，则<br>$$<br>\int_{-a}^{a} f(x) dx &#x3D;<br>\begin{cases}<br>0, &amp; f(x) \text{为奇函数时}, \\<br>2 \int_{0}^{a} f(x) dx, &amp; f(x) \text{为偶函数时}.<br>\end{cases}<br>$$</p><p>(2) 设 $f(x)$ 是以 $T$ 为周期的连续函数，则对任给数 $a$，总有<br>$$<br>\int_{a}^{a+T} f(x) dx &#x3D; \int_{0}^{T} f(x) dx.<br>$$</p><h3 id="5-利用已有公式"><a href="#5-利用已有公式" class="headerlink" title="5. 利用已有公式"></a>5. 利用已有公式</h3><p>(1)<br>$$<br>\int_{0}^{\frac{\pi}{2}} \sin^n x dx &#x3D; \int_{0}^{\frac{\pi}{2}} \cos^n x dx &#x3D;<br>\begin{cases}<br>\frac{n-1}{n} \cdot \frac{n-3}{n-2} \cdots \frac{1}{2} \cdot \frac{\pi}{2}, &amp; n \text{为正偶数}\\<br>\frac{n-1}{n} \cdot \frac{n-3}{n-2} \cdots \frac{2}{3}, &amp; n \text{为大于1的奇数}<br>\end{cases}<br>$$</p><p>(2)<br>$$<br>\int_{0}^{\pi} x f(\sin x) dx &#x3D; \frac{\pi}{2} \int_{0}^{\pi} f(\sin x) dx \quad (\text{其中} f(x) \text{连续}).<br>$$</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>上岸</category>
      
      <category>高数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泰勒公式</title>
    <link href="/2025/02/26/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/"/>
    <url>/2025/02/26/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-指数函数-e-x"><a href="#1-指数函数-e-x" class="headerlink" title="1. 指数函数 ( $ e^x $ )"></a>1. 指数函数 ( $ e^x $ )</h3><p>$$<br>e^x &#x3D; 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \cdots &#x3D; \sum_{n&#x3D;0}^\infty \frac{x^n}{n!}<br>$$</p><hr><h3 id="2-正弦函数-sin-x"><a href="#2-正弦函数-sin-x" class="headerlink" title="2. 正弦函数 ($ \sin x$ )"></a>2. 正弦函数 ($ \sin x$ )</h3><p>$$<br>\sin x &#x3D; x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \cdots &#x3D; \sum_{n&#x3D;0}^\infty (-1)^n \frac{x^{2n+1}}{(2n+1)!}<br>$$</p><hr><h3 id="3-余弦函数-cos-x"><a href="#3-余弦函数-cos-x" class="headerlink" title="3. 余弦函数 ($ \cos x$ )"></a>3. 余弦函数 ($ \cos x$ )</h3><p>$$<br>\cos x &#x3D; 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} + \cdots &#x3D; \sum_{n&#x3D;0}^\infty (-1)^n \frac{x^{2n}}{(2n)!}<br>$$</p><hr><h3 id="4-自然对数函数-ln-1-x"><a href="#4-自然对数函数-ln-1-x" class="headerlink" title="4. 自然对数函数 ($ \ln(1 + x)$ )"></a>4. 自然对数函数 ($ \ln(1 + x)$ )</h3><p>$$<br>\ln(1 + x) &#x3D; x - \frac{x^2}{2} + \frac{x^3}{3} - \frac{x^4}{4} + \cdots &#x3D; \sum_{n&#x3D;1}^\infty (-1)^{n+1} \frac{x^n}{n}, \quad |x| &lt; 1<br>$$</p><hr><h3 id="5-几何级数-frac-1-1-x"><a href="#5-几何级数-frac-1-1-x" class="headerlink" title="5. 几何级数 ( $\frac{1}{1 - x} $)"></a>5. 几何级数 ( $\frac{1}{1 - x} $)</h3><p>$$<br>\frac{1}{1 - x} &#x3D; 1 + x + x^2 + x^3 + x^4 + \cdots &#x3D; \sum_{n&#x3D;0}^\infty x^n, \quad |x| &lt; 1<br>$$</p><hr><h3 id="6-反正切函数-arctan-x"><a href="#6-反正切函数-arctan-x" class="headerlink" title="6. 反正切函数 ( $\arctan x $)"></a>6. 反正切函数 ( $\arctan x $)</h3><p>$$<br>\arctan x &#x3D; x - \frac{x^3}{3} + \frac{x^5}{5} - \frac{x^7}{7} + \cdots &#x3D; \sum_{n&#x3D;0}^\infty (-1)^n \frac{x^{2n+1}}{2n+1}, \quad |x| \leq 1<br>$$</p><hr><h3 id="7-二项式级数-1-x-k-（-k-为任意实数）"><a href="#7-二项式级数-1-x-k-（-k-为任意实数）" class="headerlink" title="7. 二项式级数 ($ (1 + x)^k $)（( k ) 为任意实数）"></a>7. 二项式级数 ($ (1 + x)^k $)（( k ) 为任意实数）</h3><p>$$<br>(1 + x)^k &#x3D; 1 + kx + \frac{k(k-1)}{2!}x^2 + \frac{k(k-1)(k-2)}{3!}x^3 + \cdots &#x3D; \sum_{n&#x3D;0}^\infty \binom{k}{n} x^n, \quad |x| &lt; 1<br>$$</p><hr><h3 id="8-双曲正弦函数-sinh-x"><a href="#8-双曲正弦函数-sinh-x" class="headerlink" title="8. 双曲正弦函数 ($ \sinh x $)"></a>8. 双曲正弦函数 ($ \sinh x $)</h3><p>$$<br>\sinh x &#x3D; x + \frac{x^3}{3!} + \frac{x^5}{5!} + \frac{x^7}{7!} + \cdots &#x3D; \sum_{n&#x3D;0}^\infty \frac{x^{2n+1}}{(2n+1)!}<br>$$</p><hr><h3 id="9-双曲余弦函数-cosh-x"><a href="#9-双曲余弦函数-cosh-x" class="headerlink" title="9. 双曲余弦函数 ( $\cosh x $)"></a>9. 双曲余弦函数 ( $\cosh x $)</h3><p>$$<br>\cosh x &#x3D; 1 + \frac{x^2}{2!} + \frac{x^4}{4!} + \frac{x^6}{6!} + \cdots &#x3D; \sum_{n&#x3D;0}^\infty \frac{x^{2n}}{(2n)!}<br>$$</p><hr><h3 id="10-平方根函数-sqrt-1-x"><a href="#10-平方根函数-sqrt-1-x" class="headerlink" title="10. 平方根函数 ( $\sqrt{1 + x}$ )"></a>10. 平方根函数 ( $\sqrt{1 + x}$ )</h3><p>$$<br>\sqrt{1 + x} &#x3D; 1 + \frac{1}{2}x - \frac{1}{8}x^2 + \frac{1}{16}x^3 - \frac{5}{128}x^4 + \cdots, \quad |x| &lt; 1<br>$$</p><hr><h3 id="11-正切函数"><a href="#11-正切函数" class="headerlink" title="11. 正切函数"></a>11. 正切函数</h3><p>$$<br>\tan x &#x3D; x + \frac{x^3}{3} + \frac{2x^5}{15} + \frac{17x^7}{135}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>上岸</category>
      
      <category>高数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lombok</title>
    <link href="/2024/12/11/lombok/lombok/"/>
    <url>/2024/12/11/lombok/lombok/</url>
    
    <content type="html"><![CDATA[<hr><hr><p><strong>快速生成相关的 <code>Get</code>和<code>Set</code>方法</strong></p><hr><p>需要导入<code>jar</code>包</p><p>传统方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(Integer sid, String name, String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sid = sid;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getSid</span><span class="hljs-params">()</span> &#123;             <span class="hljs-comment">//长！</span><br>        <span class="hljs-keyword">return</span> sid;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSid</span><span class="hljs-params">(Integer sid)</span> &#123;     <span class="hljs-comment">//到！</span><br>        <span class="hljs-built_in">this</span>.sid = sid;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;             <span class="hljs-comment">//爆！</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;    <span class="hljs-comment">//炸！</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而使用Lombok之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用Lombok之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！</p><hr><hr><ul><li>通过添加<code>@Getter</code>和<code>@Setter</code>来为当前类的所有字段生成get&#x2F;set方法，他们可以添加到类或是字段上，注意静态字段不会生成，final字段无法生成set方法。<ul><li>还可以使用@Accessors来控制生成Getter和Setter的样式。</li></ul></li><li>我们通过添加<code>@ToString</code>来为当前类生成预设的toString方法。</li><li>我们可以通过添加<code>@EqualsAndHashCode</code>来快速生成比较和哈希值方法。</li><li>我们可以通过添加<code>@AllArgsConstructor</code>和<code>@NoArgsConstructor</code>来快速生成全参构造和无参构造。</li><li>我们可以添加<code>@RequiredArgsConstructor</code>来快速生成参数只包含<code>final</code>或被标记为<code>@NonNull</code>的成员字段。</li><li>使用<code>@Data</code>能代表<code>@Setter</code>、<code>@Getter</code>、<code>@RequiredArgsConstructor</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code>全部注解。<ul><li>一旦使用<code>@Data</code>就不建议此类有继承关系，因为<code>equal</code>方法可能不符合预期结果（尤其是仅比较子类属性）。</li></ul></li><li>使用<code>@Value</code>与<code>@Data</code>类似，但是并不会生成setter并且成员属性都是final的。</li><li>使用<code>@SneakyThrows</code>来自动生成try-catch代码块。</li><li>使用<code>@Cleanup</code>作用与局部变量，在最后自动调用其<code>close()</code>方法（可以自由更换）</li><li>使用<code>@Builder</code>来快速生成建造者模式。<ul><li>通过使用<code>@Builder.Default</code>来指定默认值。</li><li>通过使用<code>@Builder.ObtainVia</code>来指定默认值的获取方式。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>lombok</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java语法基础</title>
    <link href="/2024/12/11/java/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/12/11/java/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>1.</strong> 字符串比较<br><code>==</code>  比较两个对象的地址是否相等<br><code>equals</code> 比较两个对象的内容是否相等例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String a=<span class="hljs-string">&quot;fsd&quot;</span>,b=<span class="hljs-string">&quot;fsafsdd&quot;</span>;<br><br>boolen od=a.equals(b);<span class="hljs-comment">//判断a串和b串是否相等</span><br></code></pre></td></tr></table></figure><hr><h1 id="一、基本格式"><a href="#一、基本格式" class="headerlink" title="一、基本格式"></a>一、基本格式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 class 类名&#123;<br>代码<br><span class="hljs-comment">//类名通常用首字母大写形式</span><br><span class="hljs-comment">//类名和文件名必须一致</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>变量名</code>：由数字、字母、下划线、美元符号（$）组成，不能以数字开头</p><hr><h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><h2 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h2><p>整数型：<code>short 、 int 、long、byte</code><br>浮点数：<code>float 、double</code><br>字符型：<code>char</code><br>布尔型：<code>boolean</code></p><h2 id="2、引用数据类型"><a href="#2、引用数据类型" class="headerlink" title="2、引用数据类型"></a>2、引用数据类型</h2><p>类：<code>class</code><br>接口：<code>interface</code><br>数组<br>枚举：<code>enum</code><br>注解：<code>annotation</code></p><hr><h1 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h1><h2 id="1、方法"><a href="#1、方法" class="headerlink" title="1、方法"></a>1、方法</h2><p>方法是一段可重复调用的代码。（类似于c++中的子函数）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名<span class="hljs-number">1</span>,参数类型 参数名<span class="hljs-number">2.</span>...)&#123;<br><br><span class="hljs-keyword">return</span> 返回值;<span class="hljs-comment">//void没有返回值</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="2、方法的重载"><a href="#2、方法的重载" class="headerlink" title="2、方法的重载"></a>2、方法的重载</h2><p> 在同一个作用域中，方法名相同但参数个数或者参数类型不同的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <br>        <span class="hljs-type">int</span> n=add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> m=add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>        <span class="hljs-type">double</span> p=add(<span class="hljs-number">1.2</span>,<span class="hljs-number">1.3</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//同一个方法名，不同的参数类型或个数，是允许的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-keyword">return</span> x+y;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span>&#123;<br>        <span class="hljs-keyword">return</span> x+y+z;<br>    &#125;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> x,<span class="hljs-type">double</span> y)</span>&#123;<br>        <span class="hljs-keyword">return</span> x+y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、构造方法"><a href="#3、构造方法" class="headerlink" title="3、构造方法"></a>3、构造方法</h2><blockquote><p>作用: 在实例化对象的时候为变量赋值</p></blockquote><p>注意：</p><ul><li>构造方法名字要和类名一致</li><li>构造方法前不能有任何返回值类型的声明</li><li>不能在构造方法中<code>return</code>一个值，但是，可以单独写<code>return</code>作为方法的结束</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">role</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">role</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        role stu=<span class="hljs-keyword">new</span> <span class="hljs-title class_">role</span>(<span class="hljs-string">&quot;宁&quot;</span>);<span class="hljs-comment">//调用构造方法进行初始赋值</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在定义了有参构造方法之后，无参的构造方法不能在访问，即代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">role</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">role</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        role stu=<span class="hljs-keyword">new</span> <span class="hljs-title class_">role</span>();<span class="hljs-comment">//调用 无参 构造方法进行初始赋值</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>是 <strong>错误的</strong>，如果要用无参的构造方法需要重载一个无参的构造方法，同理，构造方法<code>可以进行多次重载</code>，但是要遵循构造方法的写法规范</p><h2 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4.静态方法"></a>4.静态方法</h2><blockquote><p>访问同静态变量一样，也可以通过实例化的对象访问</p></blockquote><p>注意：</p><ul><li>静态方法只能访问静态成员</li><li>非静态成员需要先创建对象才能访问</li></ul><h2 id="5-继承中方法的重写"><a href="#5-继承中方法的重写" class="headerlink" title="5.继承中方法的重写"></a>5.继承中方法的重写</h2><blockquote><p>有时需要在子类中对继承的方法进行一些修改，即对父类的方法进行重写</p></blockquote><p><code>在子类中，重写的方法需要和父类中被重写的方法具有相同的方法名、参数列表、返回值类型！！！！！！</code></p><p><strong>在重写的时候，注意：</strong></p><ul><li>子类重写父类的方法的时候，不能使用比父类更严格的访问权限，例如：父类是用<code>public</code>修饰，子类就不能用<code>protected</code>以及更低的访问权限修饰</li></ul><hr><h1 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名;<br>数组名=<span class="hljs-keyword">new</span> 数据类型[长度];<span class="hljs-comment">//和C同样的从下标0开始</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//初始化1</span><br>       <span class="hljs-type">int</span>[] x;<br>       x=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100</span>];<br>       <br>       <span class="hljs-comment">//初始化2</span><br>       <span class="hljs-type">int</span>[] y=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;元素，元素....&#125;;<br>       <br>       <span class="hljs-comment">//初始化3</span><br>       <span class="hljs-type">int</span>[] z=&#123;元素，元素..&#125;;<br>       <br>   <span class="hljs-type">int</span> u=x.length;<span class="hljs-comment">//获取数组长度</span><br>   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二维数组</strong> ：和一维基本相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[][] 数组名=<span class="hljs-keyword">new</span> 数据类型[行数][列数]<br><br><span class="hljs-comment">//列数不确定</span><br>数据类型[][] 数组名=<span class="hljs-keyword">new</span> 数据类型[行数][]<br><br><span class="hljs-comment">//和一维的初始化2,3一样</span><br></code></pre></td></tr></table></figure><hr><h1 id="五、类和对象"><a href="#五、类和对象" class="headerlink" title="五、类和对象"></a>五、类和对象</h1><h2 id="1、类"><a href="#1、类" class="headerlink" title="1、类"></a>1、类</h2><p>类是对象的抽象，用于描述一组对象的共同特征和行为。<br>类中可以定义成员变量和成员方法。<br>成员变量用于描述对象的特征，也被称为对象的属性<br>成员方法用于描述对象的行为简称对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名&#123;<br>    成员变量;<br>    成员方法;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span>  <span class="hljs-title class_">student</span>&#123;<br>    <span class="hljs-comment">//成员变量</span><br>    string name;<br>    <span class="hljs-type">int</span> age=<span class="hljs-number">30</span>;<span class="hljs-comment">//成员变量</span><br>    string sex;<br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> age=<span class="hljs-number">50</span>;<span class="hljs-comment">//局部变量</span><br>        System.out.println(<span class="hljs-string">&quot;成员方法&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><code>允许局部变量和成员变量同名，但此时，方法中的变量值为局部变量的值，上面age就是50</code></p><h2 id="2、对象（类比结构体）"><a href="#2、对象（类比结构体）" class="headerlink" title="2、对象（类比结构体）"></a>2、对象（类比结构体）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">类名 对象名=<span class="hljs-literal">null</span>;<br>对象名=<span class="hljs-keyword">new</span> 类名();<br><br><span class="hljs-comment">//或者</span><br>类名 对象名=<span class="hljs-keyword">new</span> 类名();<br><br><span class="hljs-comment">//创建好实例对象之后，可以使用了</span><br><br>对象名.属性名<br>对象名.方法名<br><br></code></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">student</span>&#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    string sex;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>&#123;<br>        System.out.println();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        student st=<span class="hljs-keyword">new</span> <span class="hljs-title class_">student</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、访问控制权限"><a href="#六、访问控制权限" class="headerlink" title="六、访问控制权限"></a>六、访问控制权限</h1><p><code>private</code>私有访问权限，只能在本类中访问<br><code>default</code>默认访问权限，如果一个类中的属性或方法没有任何访问权限的生命，则为默认访问权限，只能被本包中的类访问<br><code>protected</code> 受保护的访问权限，只能被本本包及不同包的子类访问<br><code>public</code>公共访问权限，可以被所有的类访问，不论是否在同一个包中</p><p><strong>注意</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;局部变量没有访问控制权限，因为局部成员只在其所在的作用  域内起作用</p><h1 id="七、封装性"><a href="#七、封装性" class="headerlink" title="七、封装性"></a>七、封装性</h1><blockquote><p>类的封装：是指将对象的状态信息 <code>隐藏在对象内部</code>，<code>不允许外部程序直接访问</code>对象的内部信息，而是通过该类提供的方法实现对内部信息的访问</p></blockquote><blockquote><p>具体方法：在定义一个类的时候将类中的属性私有化，即使用<code>private</code>修饰，私有属性只能被本类访问<br>如果需要外界访问或修改，<code>要提供公共的方法</code> </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">role</span>&#123;<br>    <span class="hljs-keyword">private</span> string name;<span class="hljs-comment">//私有成员</span><br><br>    <span class="hljs-keyword">public</span> string <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//公有方法</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(string name)</span> &#123;<span class="hljs-comment">//公有方法</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        role stu=<span class="hljs-keyword">new</span> <span class="hljs-title class_">role</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="八、关键字"><a href="#八、关键字" class="headerlink" title="八、关键字"></a>八、关键字</h1><h2 id="1-this"><a href="#1-this" class="headerlink" title="1. this"></a>1. this</h2><p>如代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">role</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">role</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        role stu=<span class="hljs-keyword">new</span> <span class="hljs-title class_">role</span>(<span class="hljs-string">&quot;宁&quot;</span>);<span class="hljs-comment">//调用构造方法进行初始赋值</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由于<code>name</code>变量不仅作为成员变量，也作为的构造方法的形参，在使用时会产生错误，所以，将本类的成员变量<code>name</code>用<code>this.name</code>进行调用。</p><p><code>this</code>不仅可以调用本类的成员变量，也可以在本类中调用本类的成员方法、构造方法（不是必须，条件可以的话，也可不用写<code>this</code>）</p><p>在调用构造方法的时候应注意：</p><ul><li>只能在构造方法中调用其他的构造方法，不能在成员方法中调用构造方法</li><li>在构造方法中，使用<code>this</code>调用其他构造方法是，必须位于第一行，且只能出现一次</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">role</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">role</span><span class="hljs-params">()</span>&#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">role</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.role();<span class="hljs-comment">//错误，不在第一行</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        role stu=<span class="hljs-keyword">new</span> <span class="hljs-title class_">role</span>(<span class="hljs-string">&quot;宁&quot;</span>);<span class="hljs-comment">//调用构造方法进行初始赋值</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>不能在一个类的两个构造方法中使用<code>this</code>互相调用</li></ul><h2 id="2、static"><a href="#2、static" class="headerlink" title="2、static"></a>2、static</h2><blockquote><p>用于修饰类的成员，如成员方法、成员变量、代码块等</p></blockquote><blockquote><p>如果在Java程序中用<code>static</code>修饰属性，则该属性成为静态属性（也称全局属性），可以用类名直接访问</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名.属性名<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">role</span> &#123;<br>  <span class="hljs-keyword">static</span>  String name=<span class="hljs-string">&quot;ppp&quot;</span>;<br>    <span class="hljs-type">int</span> age;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(role.name); <span class="hljs-comment">//通过类名直接访问</span><br>        <br>        role r1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">role</span>(),r2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">role</span>();<br>        r1.age=<span class="hljs-number">10</span>;<br>        r2.age=<span class="hljs-number">20</span>;<br>        role.name=<span class="hljs-string">&quot;iii&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果 name 没有 static 修饰，那么不能通过类名直接访问</span><br><span class="hljs-comment">当 name 用 static 用修饰的时候，如果修改 name 的值， r1 和 r2 的</span><br><span class="hljs-comment">name 都会修改，如果没有 static 修饰，则不会同时修改</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure><p><strong>图释：</strong><br><img src="/../../img/java/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/0c1920c1be4d4f75f5183c07f2a456f7.png"></p><p>注意：</p><ul><li>该关键字不能修饰局部变量</li></ul><h2 id="3-super"><a href="#3-super" class="headerlink" title="3.super"></a>3.super</h2><blockquote><p>当子类重写了父类的方法后，子类对象将无法访问父类中被重写的方法，为了解决该问题，<code>super</code>便产生了</p></blockquote><p>（1）使用<code>super</code>访问父类的非私有属性或方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>.属性<br><span class="hljs-built_in">super</span>.方法(参数<span class="hljs-number">1</span>，参数<span class="hljs-number">2.</span>....)<br></code></pre></td></tr></table></figure><p>（2）使用<code>super</code>调用父类中指定的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>(参数<span class="hljs-number">1</span>，参数<span class="hljs-number">2.</span>。。。);<br></code></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    <br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<span class="hljs-comment">//调用父类的构造方法</span><br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>使用<code>super</code>调用父类构造方法的代码<code>必须位于子类构造方法的第一行</code></li></ul><h2 id="4-this-和-super-区别"><a href="#4-this-和-super-区别" class="headerlink" title="4. this 和 super 区别"></a>4. this 和 super 区别</h2><p><img src="/../../img/java/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/feda5556fe52746e0594e369d0ae053a.jpeg"><br>由于这两个需要放到构造方法的首行，所以，他们不能同时出现</p><h2 id="5-final"><a href="#5-final" class="headerlink" title="5. final"></a>5. final</h2><blockquote><p>在默认情况下，所有的成员变量和成员方法都可以被子类重写，但是由的父类成员不希望被子类重写，那么该关键字产生了</p></blockquote><blockquote><p>使用<code>final</code>修饰的类不可以被继承，也就是这样的类不能派生子类</p></blockquote><p><strong>例如：</strong></p><p>①</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//错误，A 类是不可继承的类</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>②</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;balabala&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//错误，final 修饰的方法不能被子类重写</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>③ <code>final</code> 修饰的变量不能修改，类似于C语言中的<code>const</code>，并且用其修饰的时候，变量名字要全部大写例如声明全局变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> AGE=<span class="hljs-number">89</span>;<br></code></pre></td></tr></table></figure><h2 id="6、-instanceof-（判断是否为接口）"><a href="#6、-instanceof-（判断是否为接口）" class="headerlink" title="6、 instanceof （判断是否为接口）"></a>6、 instanceof （判断是否为接口）</h2><blockquote><p>判断一个对象是否是某个类（或接口）的实例</p></blockquote><p>格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">对象 instanof 类（或接口）<br></code></pre></td></tr></table></figure><p>上述 “ 对像 ” 如果是指定类的实例对像，则返回<code>true</code> 否则返回<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> PACAK1;<br><br><span class="hljs-keyword">import</span> javafx.scene.AmbientLight;<br><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;喵喵...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-comment">//重写shout方法，不是抽象类的方法，也可以不重写，看自己需求</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;汪汪汪...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;不吃饭....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Animal a1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<span class="hljs-comment">//通过向上转型实例化 Animal 对象</span><br>        System.out.println(<span class="hljs-string">&quot;Animal a1=new Dog():&quot;</span>+(a1 <span class="hljs-keyword">instanceof</span> Animal));<br>        System.out.println(<span class="hljs-string">&quot;Animal a1=new Dog():&quot;</span>+(a1 <span class="hljs-keyword">instanceof</span> Dog));<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        System.out.println(<span class="hljs-string">&quot;Animal a1=new Animal():&quot;</span>+(a2 <span class="hljs-keyword">instanceof</span> Animal));<br>        System.out.println(<span class="hljs-string">&quot;Animal a1=new Animal():&quot;</span>+(a2 <span class="hljs-keyword">instanceof</span> Dog));<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Animal a1=new Dog():true</span><br><span class="hljs-comment">Animal a1=new Dog():true</span><br><span class="hljs-comment">Animal a1=new Animal():true</span><br><span class="hljs-comment">Animal a1=new Animal():false</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><hr><hr><h1 id="九、代码块"><a href="#九、代码块" class="headerlink" title="九、代码块"></a>九、代码块</h1><p>执行循序： 静态代码块 -&gt; 构造代码块 -&gt; 构造方法<br>普通代码块是在主类中第一的代码块，所以执行循序不包括该<code>块</code></p><h2 id="1-普通代码块"><a href="#1-普通代码块" class="headerlink" title="1.普通代码块"></a>1.普通代码块</h2><blockquote><p>意思：就是直接在方法会语句中定义的代码块</p></blockquote><p>错误事例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        &#123;<br>            <span class="hljs-type">int</span> age=<span class="hljs-number">10</span>;<br>            System.out.println(age);<br>        &#125;<br>        <br>        System.out.println(age);<span class="hljs-comment">//错误的</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>正确事例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        &#123;<br>            <span class="hljs-type">int</span> age=<span class="hljs-number">10</span>;<br>            System.out.println(age);<br>        &#125;<br>        <span class="hljs-type">int</span> age=<span class="hljs-number">10</span>;<br>        System.out.println(age);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由单纯的<code>&#123;&#125;</code>括起来的代码为普通代码块，可以对变量起到了<code>作用域的限定作用</code></p><h2 id="2-构造块"><a href="#2-构造块" class="headerlink" title="2.构造块"></a>2.构造块</h2><blockquote><p>意思：在类中定义的代码块</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">role</span> &#123;<br>    String name;<br>    <br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造代码块&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        role stu=<span class="hljs-keyword">new</span> <span class="hljs-title class_">role</span>();<span class="hljs-comment">//调用构造方法进行初始赋值</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>构造代码块与构造方法、成员属性、成员方法同级</li><li>在实例化对象的时候，构造块先于构造方法执行，这个构造代码块写到前面还是后面没有关系</li><li>每当实例化一个对象的时候，都会先执行构造代码块，然后才会执行构造方法</li></ul><h2 id="3-静态代码块"><a href="#3-静态代码块" class="headerlink" title="3.静态代码块"></a>3.静态代码块</h2><blockquote><p>使用 <code>static</code> 修饰的代码块</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">role</span> &#123;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块在此&quot;</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>静态代码块只在<code>第一次实例化对象</code>的时候执行</li></ul><h1 id="十、继承"><a href="#十、继承" class="headerlink" title="十、继承"></a>十、继承</h1><blockquote><p>继承是指在一个现有的基础类上构建一个新的类，构建的新类被称为子类，现有的类称作父类，用关键字<code>extends</code>声明</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">class 父类名&#123;<br><br>&#125;<br><br>class 子类名 extends 父类名&#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>子类虽然可以通过继承访问父类的方法和成员，但是只能访问<code>public</code>和<code>protected</code>修饰的成员和方法，对于<code>private   ， default</code>修饰的成员和方法不能访问</li><li>类<code>只允许</code>单继承，<code>不允许</code>多继承，如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">c</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>,B&#123; &#125;<br><span class="hljs-comment">//这种是不允许的，不可以同时继承</span><br></code></pre></td></tr></table></figure><ul><li>多个类<code>可以</code>继承一个父类，例如</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123; &#125;<br></code></pre></td></tr></table></figure><ul><li>多层继承也是可以的，即一个类的父类可以在继承另外的父类，如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&#123; &#125;<br><br><span class="hljs-comment">// c 继承了 b 类，c 是 b 的子类，b 继承了 a 类，b 是 a 的子类，同时</span><br><span class="hljs-comment">// c 也是 a 的子类</span><br></code></pre></td></tr></table></figure><ul><li>子类，父类的称呼是相对的，正如上面的：b 是 c 的父类，同时又是 a 的子类</li></ul><h1 id="十一、抽象类"><a href="#十一、抽象类" class="headerlink" title="十一、抽象类"></a>十一、抽象类</h1><blockquote><p>定义一个类时，常常需要定义一些成员方法用于描述类的行为特征，但有写方法的实现是无法确定的，例如：定义一个 <code>Animal</code> 的父类，其中有<code>shout() </code>方法（用于输出叫声），那么不同的子类（也就是不同的动物）对于<code>shout() </code>方法的输出也就不同，那么父类中的<code>shout() </code>方法就无法确定写法，于是<code>abstract</code>关键字就诞生了</p></blockquote><p>（1）抽象方法实现不需要写出方法体，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> 返回值类型 方法名(参数<span class="hljs-number">1</span>，参数<span class="hljs-number">2.</span>..); <span class="hljs-comment">//注意分号别忘了写</span><br></code></pre></td></tr></table></figure><p>（2）抽象类也必须用<code>abstract</code>关键字修饰，语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> class 类名&#123;<br>属性;<br>访问权限 返回值类型 方法名(参数....)&#123;<br><span class="hljs-comment">//普通方法</span><br>&#125;<br><br>访问权限 <span class="hljs-keyword">abstract</span> 返回值类型 抽象方法名（参数）;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象类定义规则：</p><ul><li>包含抽象方法的类必须是抽象类</li><li>声明抽象类和抽象方法必须用<code>abstract</code>修饰</li><li>抽象方法只需要声明不需要实现</li><li>如果一个非抽象类继承了抽象类，那么，该类必须重写抽象类中的<code>全部抽象方法</code></li></ul><p>注意：</p><ul><li>使用<code>abstract</code>修饰的抽象方法不能使用<code>private</code>修饰</li></ul><h1 id="十二、接口"><a href="#十二、接口" class="headerlink" title="十二、接口"></a>十二、接口</h1><blockquote><p>是一种用来定义程序的协议，它用于描述类或结构的一组相关行为</p></blockquote><blockquote><p>来源：接口是由抽象类衍生的一个概念，并由此产生了一种编程逻辑，可以称这种编程方式为<code>面向接口编程</code></p></blockquote><blockquote><p><code>面向接口编程</code>：将程序的不同的业务逻辑分离，以接口的形式<code>对接</code>不同的业务模块。接口中不实现任何业务逻辑，业务逻辑由接口的实现类完成。当业务需求变更时，只需要修改实现类中的业务逻辑，而不需要修改接口中的内容，以减少需求变更对系统产生的影响</p></blockquote><p>面向接口编程，思想类比：<br>    &emsp;鼠标，键盘等通过 USB 接口来连接计算机，如需更换只要拔掉当前的 USB 插口，换上新的即可</p><blockquote><p>目的：克服单继承的限制，因为一个类只能有一个父类，而一个类可以实现多个接口，使用关键字<code>interface</code>声明</p></blockquote><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-keyword">public</span>] interface 接口名 [extends 接口<span class="hljs-number">1</span>,接口<span class="hljs-number">2.</span>..]&#123;<br>        [<span class="hljs-keyword">public</span>] [<span class="hljs-keyword">static</span>] [<span class="hljs-keyword">final</span>] 数据类型 常量名=常量;<br>        [<span class="hljs-keyword">public</span>] [<span class="hljs-keyword">abstract</span>] 返回值的数据类型 方法名(参数列表);<br>        [<span class="hljs-keyword">public</span>] <span class="hljs-keyword">static</span> 返回值的数据类型 方法名(参数列表)&#123; &#125;<br>        [<span class="hljs-keyword">public</span>] <span class="hljs-keyword">default</span> 返回值的数据类型 方法名(参数列表)&#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>语法 “ extends 接口1,接口2… ” 表示一个接口可以有多个父接口，父接口之间用逗号隔开</li><li>接口中变量默认使用<code>public static final</code>进行修饰，即全局变量，抽象方法默认用<code>public abstract</code>修饰</li><li>接口中无论使写不写访问权限，接口中方法的默认权限永远都是用<code>public</code>修饰</li></ul><blockquote><p>接口本身不能实例化，只能通过接口<code>实现类</code>的事例对象进行访问（抽象方法和默认方法），<code>implements</code> 关键字实现。<code>实现类必须重写接口中所有的抽象方法</code></p></blockquote><p>定义接口实现类语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 class 类名 implements 接口<span class="hljs-number">1</span>，接口<span class="hljs-number">2.</span>。。。&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>综合应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义接口 Animal</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-type">int</span> ID=<span class="hljs-number">1</span>;<span class="hljs-comment">//定义全局常量</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>;<span class="hljs-comment">//定义抽象方法</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Action</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<span class="hljs-comment">//定义抽象方法</span><br>&#125;<br><br><span class="hljs-comment">//定义 Dog 类实现 Animal 接口和 Action 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>,Action&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;喜欢吃饭&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;汪汪汪&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Dog dog=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<span class="hljs-comment">//创建 Dog 类的实例对象</span><br>        dog.eat();<span class="hljs-comment">//调用 Dog 类中重写的 eat() 方法</span><br>        dog.shout();<span class="hljs-comment">//调用 Dog 类中重写的 shout() 方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>补注：</p><ul><li>如果一个子类既要实现接口，又要继承抽象类，则可以写为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 class 类名 extends 父类名 implements 接口<span class="hljs-number">1</span>，接口<span class="hljs-number">2.</span>。。&#123;<br><br>&#125;<br><br><span class="hljs-comment">//例如：c 类继承了 A 抽象类，并实现了 B 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">abstract</span> A&#123;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">B</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>接口不允许继承抽象类，但是允许接口继承接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span>&#123;<br><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>,B&#123; <span class="hljs-comment">//定义 c 接口，同时继承了 A B 接口</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">C</span>&#123;<br><span class="hljs-comment">//定义 D 类实现 C 的接口</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十三、多态"><a href="#十三、多态" class="headerlink" title="十三、多态"></a>十三、多态</h1><blockquote><p>大意：不同类的对象在调用同一个方法时表现出来的多种不同行为<br>例如：定义了一个抽象类 <code>animal</code>，在该类中定义了一个抽象方法<code>shout</code>，那么，同过定义不同的类去继承<code>animal</code>类，并且重写其中的<code>shout</code>方法，这样就是实现了多态</p></blockquote><h1 id="十四、对象类型的转换"><a href="#十四、对象类型的转换" class="headerlink" title="十四、对象类型的转换"></a>十四、对象类型的转换</h1><blockquote><p>向上转型：子类对象 —-&gt; 父类对象<br>向下转型：父类对象 —-&gt; 子类对象</p></blockquote><h2 id="（1）、向上转型"><a href="#（1）、向上转型" class="headerlink" title="（1）、向上转型"></a>（1）、向上转型</h2><blockquote><p>对象可以调用子类重写父类的方法，这样当需要添加新功能时，只需要新增一个子类，在子类中对父类的功能进行拓展，而不用更改父类的代码</p></blockquote><p>更改格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">父类类型  父类对象 = 子类实例 ;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;喵喵...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-comment">//重写shout方法，不是抽象类的方法，也可以不重写，看自己需求</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;汪汪汪...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;不吃饭....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Dog dog=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// 创建 Dog 对象，即子类</span><br>        Animal an=dog;<span class="hljs-comment">// 完成了向上转型</span><br>        an.shout(); <span class="hljs-comment">// 输出 喵喵... </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>转型后的父类<code>an</code>无法调用<code>Dog</code>中的<code>eat()</code>方法，因为<code>eat()</code>方法只在子类定义了</li></ul><h2 id="（2）、向下转型"><a href="#（2）、向下转型" class="headerlink" title="（2）、向下转型"></a>（2）、向下转型</h2><blockquote><p>向下转型一般是为了重新获得<code>因向上转型而丢失的子类特性 </code></p></blockquote><p>格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">父类类型 父类对象 = 子类实例;<br>子类类型 子类对象 = (子类)父类对象;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;喵喵...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-comment">//重写shout方法，不是抽象类的方法，也可以不重写，看自己需求</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;汪汪汪...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;不吃饭....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">an</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">//完成了向上转型： 子类 ---&gt; 父类</span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> (Dog) an; <span class="hljs-comment">// 向下转型</span><br>        dog.shout();<br>        dog.eat();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意:</p><ul><li>向下转型的时候，必须先进性向上转型</li></ul><h1 id="十五、内部类"><a href="#十五、内部类" class="headerlink" title="十五、内部类"></a>十五、内部类</h1><blockquote><p>在一个类的内部定义的类，叫做内部类<br>根据内部类的位置、修饰符和定义方式不同，内部类可分为：成员内部类、局部内部类、静态内部类、匿名内部类</p></blockquote><h2 id="（1）、成员内部类"><a href="#（1）、成员内部类" class="headerlink" title="（1）、成员内部类"></a>（1）、成员内部类</h2><blockquote><p>内部类可以访问外部类的所有成员、无论是何种访问权限（额。。。就是类中套类）</p><p>如果想要通过外部类访问内部类，则需要通过外部类创建内部类对象，格式：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">外部类名 外部类对象 = new 外部类名() ;<br>外部类名.内部类名 内部类对象 = 外部类对象.new 内部类名() ;<br></code></pre></td></tr></table></figure><h2 id="（2）、局部内部类"><a href="#（2）、局部内部类" class="headerlink" title="（2）、局部内部类"></a>（2）、局部内部类</h2><blockquote><p>：也称方法内部类。在某个局部范围定义的类，他和局部变量都是在方法中定义的，有效范围只限于方法内部</p></blockquote><blockquote><p>可以访问外部类的所有成员变量和成员方法<br>如果要在外部类中访问局部内部类的成员，只能在局部内部类的所属方法中创建局部内部类的对象，通过对象访问局部内部类的额变量和方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tes1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;外部成员方法。。。&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//定义一个局部内部类，在局部内部类中访问外部变量和方法</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>            <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;外部成员变量m：&quot;</span>+m);<br>                tes1();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//访问局部内部类中的成员和方法</span><br>        Inner inner=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        System.out.println(<span class="hljs-string">&quot;局部内部类变量n= &quot;</span>+inner.n);<br>        inner.shout();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Outer outer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>        outer.test2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="（3）、静态内部类"><a href="#（3）、静态内部类" class="headerlink" title="（3）、静态内部类"></a>（3）、静态内部类</h2><blockquote><p>就是用<code>static</code>关键字修饰的成员内部类，</p></blockquote><blockquote><p>与成员内部类相比：多了一个<code>static</code>关键字； 静态内部类只能访问外部类的静态成员</p></blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类名.静态内部类 变量名 = <span class="hljs-keyword">new</span> 外部类名.静态内部类名() ;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//静态内部类的方法中访问外部静态变量</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;访问外部静态变量 m= &quot;</span>+m);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Outer.Inner inner=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner();<br><br>        inner.show();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="（4-、匿名内部类"><a href="#（4-、匿名内部类" class="headerlink" title="（4)、匿名内部类"></a>（4)、匿名内部类</h2><blockquote><p>匿名内部类，就是没有名字的一种嵌套类。它是Java对类的定义方式之一。<br>:如果 Java 调用某个方法时、如果该方法的参数是<code>接口类型</code>，那么在传参时，除了可以传入一个接口实现类，还可以传入实现接口的匿名内部类作为参数</p></blockquote><p><font color="blue">为什么要使用匿名内部类？</font><br><font color="rebsffsaasdffdfdgrenn">在实际开发中，我们常常遇到这样的情况：一个接口&#x2F;类的方法的某个实现方式在程序中只会执行一次，但为了使用它，我们需要创建它的实现类&#x2F;子类去实现&#x2F;重写。此时可以使用匿名内部类的方式，可以无需创建新的类，减少代码冗余</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 继承的父类或实现的接口名&#123;<br>匿名内部类的类体<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">animal</span>&#123;<span class="hljs-comment">//定义一个接口</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        animalopa(<span class="hljs-keyword">new</span> <span class="hljs-title class_">animal</span>() &#123; <span class="hljs-comment">// 调用animalopa() 方法，参数为匿名内部类</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;miao...&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">animalopa</span><span class="hljs-params">(animal an)</span>&#123;<span class="hljs-comment">//该方法为接口类型</span><br>        an.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//具体类</span><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String s)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;啦啦啦&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象类</span><br> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass01</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String s)</span>;<br>&#125;<br><span class="hljs-comment">//接口</span><br> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interface01</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String s)</span>;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//重写具体类的方法</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class01</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String s)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;我是一个&quot;</span> + s);<br>            &#125;<br>        &#125;.show(<span class="hljs-string">&quot;具体类&quot;</span>);<br><br>        <span class="hljs-comment">//重写抽象类的抽象方法</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractClass01</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String s)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;我是一个&quot;</span> + s);<br>            &#125;<br>        &#125;.show(<span class="hljs-string">&quot;抽象类&quot;</span>);<br><br>        <span class="hljs-comment">//实现接口的抽象方法</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Interface01</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String s)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;我是一个&quot;</span> + s);<br>            &#125;<br>        &#125;.show(<span class="hljs-string">&quot;接口&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">我是一个具体类<br>我是一个抽象类<br>我是一个接口<br></code></pre></td></tr></table></figure><p>对于<code>@Override</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>注解是伪代码，用于表示被标注的方法是一个重写方法。<br><br><span class="hljs-meta">@Override</span>注解，只能用于标记方法，并且它只在编译期生效，不会保留在class文件中。<br><br><span class="hljs-meta">@Override</span> 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。<br><br><span class="hljs-meta">@Override</span>注解标记的方法声明，如果没有覆写或者实现超类(被继承的类)的方法声明，或者不是覆写Object的<span class="hljs-keyword">public</span>方法，那么编译就会报错。<br>使用<span class="hljs-meta">@Override</span>注解，有助于我们尽早发现这样的错误：本来想声明一个“覆写”方法，却偶然声明成“重载”方法。<br><br><br>使用<span class="hljs-meta">@Override</span>注解主要有两个好处：<br><br><span class="hljs-number">1</span>）帮助自己检查是否正确的重写父类方法<br><br><span class="hljs-number">2</span>）明显的提示看代码的人，这是重写的方法<br></code></pre></td></tr></table></figure><h2 id="拓展：-1"><a href="#拓展：-1" class="headerlink" title="拓展："></a><strong>拓展：</strong></h2><p><code>Lambda表达式</code>：只有一个带实现的抽象方法时，匿名内部类可以用<code>Lambda表达式</code>表示，可以存在其他方法，其他方法必须用<code>default</code>修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Animal stu=()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;lambda方法&quot;</span>);<br>        &#125; ;<span class="hljs-comment">//相当于实例化的时候重写方法</span><br>        stu.show();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果说<code>show()</code>有参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    String <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Animal stu=(u)-&gt;&#123;<span class="hljs-comment">//参数类型可以不写</span><br>            <span class="hljs-keyword">return</span> u+<span class="hljs-string">&quot;fsd&quot;</span>;<br>        &#125; ;<span class="hljs-comment">//相当于实例化的时候重写方法</span><br>        String a=stu.show(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果说<code>show()</code>只有一个参数:<br>也可写为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    String <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Animal stu=u-&gt;&#123; <span class="hljs-comment">//小括号可以不写</span><br>            <span class="hljs-keyword">return</span> u+<span class="hljs-string">&quot;fsd&quot;</span>;<br>        &#125; ;<span class="hljs-comment">//相当于实例化的时候重写方法</span><br>        String a=stu.show(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果说，方法体中<code>只有一个返回语句</code>还可以在简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"> Animal stu=u-&gt;&#123; <span class="hljs-comment">//小括号可以不写</span><br>            <span class="hljs-keyword">return</span> u+<span class="hljs-string">&quot;fsd&quot;</span>;<br>        &#125; ;<span class="hljs-comment">//相当于实例化的时候重写方法</span><br><span class="hljs-comment">// 简化为</span><br> Animal stu=u-&gt; u+<span class="hljs-string">&quot;fsd&quot;</span>;<br></code></pre></td></tr></table></figure><p>还可以用下面的方式重写方法：<br>第一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    String <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        t1 a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">t1</span>(); <span class="hljs-comment">//因为成员方法只能具体成员调用</span><br>        Animal animal=a::shoow;<span class="hljs-comment">//对接口中的 show() 方法重写，用 shoow() 方法覆盖，名字可以相同，亦可以不相同</span><br>        <span class="hljs-comment">// 双冒号必须有，建议自己重写的方法用冒号覆盖，函数库的还可以用下面的方法</span><br>        System.out.println( animal.show(<span class="hljs-number">2</span>));<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">shoow</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fsad&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种：(函数库自带的可以用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-comment">//    String show(int u);</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Animal animal=(a,b)-&gt;Integer.sum(a,b);<span class="hljs-comment">//或者 = Integer：：sum ;</span><br>        System.out.println( animal.sum(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;</h1><h1 id="-1"><a href="#-1" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;</h1><h1 id="一、异常"><a href="#一、异常" class="headerlink" title="一、异常"></a>一、异常</h1><blockquote><p>：在程序运行时可能出现的错误或非正常情况</p></blockquote><p><img src="/../../img/java/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/9aca75e2c9155cf79006c5fa929b8352.png"><br><strong>1.系统错误（Error）</strong><br><strong>2.编译时异常（Exception)</strong></p><ul><li>1.运行时异常（RuntimeException）</li></ul><h2 id="（1）抛出异常"><a href="#（1）抛出异常" class="headerlink" title="（1）抛出异常"></a>（1）抛出异常</h2><blockquote><p>当调用某个方法的时候，如果跟传入错误的参数，那么程序将无法继续运行，这个时候我们可以手动抛出一个异常来终止程序运行下去，同时告知上一级方法执行出现了问题</p></blockquote><p><code>throw</code> 和  <code>throws</code>区别：</p><ul><li><code>throw</code>写在方法内部，<code>throws</code>跟在方法声明的后面</li><li><code>throw</code>抛出的是一个异常实例，并且每次只能抛出一个，<code>throws</code>后面必须加上异常类型，如果多个用逗号隔开</li><li><a href="https://blog.csdn.net/m0_46316970/article/details/119898445"> 声明异常的关楗字是 throws, 抛出异常的关键字是 throw</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(test(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;除数为零&quot;</span>);<span class="hljs-comment">//通过 throw 抛出异常</span><br>        <span class="hljs-keyword">return</span> a/b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="/../../img/java/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/7ed5c2fd9939873b07795365f1f77abf.png"><br>如果说抛出了一个编译时的异常那么写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception &#123;<span class="hljs-comment">//使用 throws 告知此方法会抛出那些异常，请调用方法处理</span><br>     <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;除数为零&quot;</span>);<br>     <span class="hljs-keyword">return</span> a/b;<br> &#125;<br></code></pre></td></tr></table></figure><p>该异常会返回到调用的地方，那么调用的一方必须对该异常进行处理<br>如果说不同的分支会抛出不同的异常，那么必须在方法中都需要注明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> ArithmeticException,ClassCastException &#123;<span class="hljs-comment">//多个异常用逗号隔开</span><br>       <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>();<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassCastException</span>();      <br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="（2）捕获异常"><a href="#（2）捕获异常" class="headerlink" title="（2）捕获异常"></a>（2）捕获异常</h2><blockquote><p>捕获之后程序继续执行，如果没有被捕获那么程序就会终止<br>如果是多个，可以继续往下写，类似于 if…else…</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><br>&#125;<span class="hljs-keyword">catch</span>(....)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">int</span> res=divi(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>            System.out.println(res);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;捕获的异常信息为：&quot;</span>+e.getMessage());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;程序继续执行&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-type">int</span> res=a/b;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<img src="/../../img/java/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/5dd6c94004492418b7a4dcd1808f1e62.png"></p><p>注意：(如果抛出多个异常，并且分情况讨论的话，并且相对异常父类在前的话，所以多个情况的要注意捕获的循序）</p><ul><li>抛出异常的子类会被其异常的父类捕获</li></ul><p>如果多个异常一起打包处理的话，也可写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">int</span> res=divi(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>            System.out.println(res);<br>        &#125;<span class="hljs-keyword">catch</span> (ArithmeticException | NegativeArraySizeException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;出现了异常&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;程序继续执行&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-type">int</span> res=a/b;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>finally</code>语句块中：放的是不管问题异常是否产生 都要执行的代码code。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>...<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>...<span class="hljs-comment">//无论异常是否产生 都要执行</span><br>&#125;<br><br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">try</span>&#123;<br>...<br>&#125;<span class="hljs-keyword">catch</span>&#123;<br>...<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>...<span class="hljs-comment">//无论异常是否产生 都要执行</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="（3）自定义异常（对异常的方法重写）"><a href="#（3）自定义异常（对异常的方法重写）" class="headerlink" title="（3）自定义异常（对异常的方法重写）"></a>（3）自定义异常（对异常的方法重写）</h2><h1 id="2、工具类（Java-API）"><a href="#2、工具类（Java-API）" class="headerlink" title="2、工具类（Java API）"></a>2、工具类（Java API）</h1><h2 id="（1）数学类"><a href="#（1）数学类" class="headerlink" title="（1）数学类"></a>（1）数学类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.abs();<br>Math.max();<br>.<br>.<br>.<br>.<br>.<br>Math.log();<span class="hljs-comment">// 默认 ln</span><br>Math.log10();<span class="hljs-comment">//以10为底</span><br><span class="hljs-comment">//其他的用换底公式</span><br>Math.log(a)/Math.log(b);<span class="hljs-comment">//以 b 为底 a 的对数</span><br><br>Math.ceil();<span class="hljs-comment">//向上取整，不是四舍五入</span><br>Math.floor();<span class="hljs-comment">//向下取整，不是四舍五入</span><br></code></pre></td></tr></table></figure><h2 id="2-数组类"><a href="#2-数组类" class="headerlink" title="(2) 数组类"></a>(2) 数组类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1,arr2;<br>Arrays.toString(数组名);<span class="hljs-comment">//打印数组，结果形式：[1,2,3,4]</span><br>Arrays.deepToString(数组名);<span class="hljs-comment">// 打印多维数组 结果形式：[[1,2,3,4],[1,2,3,4]]</span><br>Arrays.sort(数组名);<span class="hljs-comment">// 从小到大排序，对浮点也可 无返回值</span><br>Arrays.fill( 数组名 , 赋值为多少); <span class="hljs-comment">// 无返回值</span><br>Arrays.copyOf(赋值的数组 , 复制多少个 ); <span class="hljs-comment">// 返回拷贝的数组</span><br>Arrays.copyOfRange(赋值的数组 , a , b ); <span class="hljs-comment">//  返回拷贝的数组 区间[a,b)  下表为零开始计数</span><br>System.arraycopy(arr1 , s , arr2 , s1 , len);<span class="hljs-comment">//无返值 从 arr1 中下表为 s 位置拷贝，到 arr2 下表为 s1 开始，拷贝了 len 个</span><br>Arrays.binarySearch(arr1 , <span class="hljs-number">8</span>);<span class="hljs-comment">//二分查找有序数组 arr1 中值为 8 的下标，不存在返回 -1</span><br><br>Arrays.equals(arr1,arr2);<span class="hljs-comment">// 一维数组 比较内容</span><br>Arrays.deepEquals(arr1,arr2);<span class="hljs-comment">// 二维数组 比较内容</span><br><br></code></pre></td></tr></table></figure><h2 id="（3）字符串类"><a href="#（3）字符串类" class="headerlink" title="（3）字符串类"></a>（3）字符串类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">String str=<span class="hljs-string">&quot;fasdf&quot;</span>;<br>String str1=<span class="hljs-string">&quot;fs&quot;</span>;<br>String str2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<span class="hljs-comment">// 也可以直接 new 一个字符串 </span><br> <br>str.indexOf(<span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// 返回 字符 或 字符串 在 str 中的第一个位置</span><br>str.lastIndexOf(<span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// 返回 字符 或 字符串 在 str 中的最后一个位置</span><br>str.charAt(<span class="hljs-number">3</span>); <span class="hljs-comment">// 返回当前位置的 字符</span><br><br>str.equals(str1); <span class="hljs-comment">// 比较 str 和 str1 的内容是否相同 返回 Boolean</span><br>str.isEmpty(); <span class="hljs-comment">// 字符串如果为 0 返回true</span><br><br>str.toLowerCase(); <span class="hljs-comment">// 全部转为小写</span><br>str.toUpperCase(); <span class="hljs-comment">// 全部转为大写</span><br><br>str.toCharArray(); <span class="hljs-comment">// 将 str 转为 char 数组，并返回 char 数组，应赋值（可以直接复赋值）给一个 char 数组</span><br>str.getBytes(); <span class="hljs-comment">// 将 str 转为 byte 数组 ，和 char 数组用法一样</span><br>str.substring(l,r); <span class="hljs-comment">// 返回 [l,r) 区间内的字符串，如果不写 r 则会从 l 到末尾</span><br><br>str.trim(); <span class="hljs-comment">// 去掉当前字符串的首位空格.</span><br><br><br></code></pre></td></tr></table></figure><p><code>String</code> 是 <code>final</code> 类型的，所以一旦创建，<strong>其长度和内容是不可以改变</strong>的，他是一个常量<br>因此可以用 <code>StringBuffer</code> 类（也称字符串缓冲区）来操作字符串，<strong>他的长度和内容可以改变</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuffer str=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(); <span class="hljs-comment">// 如果没用 new 一个对象的话，那么初始创建容量为 16， 缓冲区内不含任何内容</span><br>        <span class="hljs-comment">// 也可以直接 new 一个空间，即 new 里面是数字,缓冲区内不含任何内容</span><br>        <span class="hljs-comment">// 也可以直接 new 一个对象，缓冲区内是该对象，容量为 该对象的长度+16</span><br><br>str.length(); <span class="hljs-comment">// 获取缓冲区的内容长度</span><br>str.capacity(); <span class="hljs-comment">// 获取缓冲区的当前的容量</span><br>str.toString(); <span class="hljs-comment">// 获取缓冲去的字符</span><br><br>str.append(<span class="hljs-string">&#x27;c&#x27;</span>); <span class="hljs-comment">// 将参数添加到字符串中,无返回值</span><br>str.setCharAt(pos,<span class="hljs-string">&#x27;f&#x27;</span>); <span class="hljs-comment">// 修改指定索引位置的内容</span><br><br>str.insert(pos,<span class="hljs-string">&quot;fd&quot;</span>); <span class="hljs-comment">// 在 pos 的位置插入 “fd&quot; ，无返回值</span><br>str.delete(pos); <span class="hljs-comment">// 移除 pos 位置的字符，无返回值</span><br>str.delete(l,r); <span class="hljs-comment">// 移除区间内字符 [ l, r )</span><br>str.reverse(); <span class="hljs-comment">//反转字符串</span><br></code></pre></td></tr></table></figure><p><code>StringBuffer</code> 和 <code>StringBuilder</code> 基本相同<br>但是：</p><ul><li><code>StringBuffer</code> 是线程安全的， <code>StringBuilder</code>不是，即：如果没要求线程安全，且操作大量的字符串，用 <code>StringBuilder</code>更快</li><li><code>equals()</code> 对这两种不能用，可以这样：<code>str1.toString().equals(str2.toString())</code></li><li>这两种不能直接用 <code>+</code> 连接两个字符串</li></ul><h2 id="（4）System-类和-Runtime-类"><a href="#（4）System-类和-Runtime-类" class="headerlink" title="（4）System 类和 Runtime 类"></a>（4）System 类和 Runtime 类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">System.exit(); <span class="hljs-comment">// 若参数为 0 则表示异常终止</span><br><br>System.gc(); <span class="hljs-comment">// 回收垃圾</span><br><br> System.currentTimeMillis(); <span class="hljs-comment">// 返回的是当前时间与 1970年1月1日0：00 的时间差，单位 ms</span><br><br></code></pre></td></tr></table></figure><p><code>getProperties()</code> 和 <code>getProperty()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Enumeration;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fsd</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        Properties properties=System.getProperties(); <span class="hljs-comment">// 获取当前系统属性</span><br><br>        Enumeration enumeration=properties.propertyNames(); <span class="hljs-comment">// 获取所有系统属性的键</span><br><br>        <span class="hljs-keyword">while</span>(enumeration.hasMoreElements())&#123;<br>            String key= (String) enumeration.nextElement(); <span class="hljs-comment">// 获取系统属性的键</span><br><br>            String value=System.getProperty(key); <span class="hljs-comment">// 获取当前的键值</span><br>            System.out.println(key+<span class="hljs-string">&quot; ++++++  &quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Runtime rt=Runtime.getRuntime(); <span class="hljs-comment">// 创建 Runtime对象</span><br>rt.exec(); <span class="hljs-comment">// 参数为指定的可执行文件的路径</span><br>rt.freeMemory(); <span class="hljs-comment">// 返回java虚拟机的空闲内存量，以字节为单位</span><br>rt.maxMemory(); <span class="hljs-comment">// 返回Java虚拟机的最大可用内存量，以字节为单位</span><br>rt.availableProcessors(); <span class="hljs-comment">// 返回java虚拟机的处理器个数</span><br>rt.totalMemory(); <span class="hljs-comment">// 返回Java虚拟机的内存总量 ，以字节为单位</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fsd</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        Runtime rt=Runtime.getRuntime(); <span class="hljs-comment">// 创建 Runtime对象</span><br>        Process process=rt.exec(<span class="hljs-string">&quot;notepad.exe&quot;</span>); <span class="hljs-comment">// 打开记事本 ，得到一个 表示进程的 Process 对象</span><br>        Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 休眠 1s</span><br>        <br>        process.destroy(); <span class="hljs-comment">// 销毁进程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="（5）Random类"><a href="#（5）Random类" class="headerlink" title="（5）Random类"></a>（5）Random类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(); <span class="hljs-comment">// 以时间为种子，每次产生的随机数不同</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">100</span>); <span class="hljs-comment">// [0,100)以内的整数</span><br><br><span class="hljs-comment">// 还可以有 nextDouble()  nextFloat() nextBoolean() 等  </span><br><span class="hljs-comment">// 不写参数生成的是该类型的随机数</span><br> <br><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">12</span>);<span class="hljs-comment">//设置指定种子，使得每次的随机数都相同</span><br><br></code></pre></td></tr></table></figure><h2 id="（6）BigInteger-类和-BigDecimal-类"><a href="#（6）BigInteger-类和-BigDecimal-类" class="headerlink" title="（6）BigInteger 类和 BigDecimal 类"></a>（6）BigInteger 类和 BigDecimal 类</h2><br/><p>如果需要定义一个超出<code>int</code>类型的<code>整型</code>数据，可以使用<code>BigInteger</code> 类的对象接收数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">BigInteger(String val)  将字符串 val 变为  BigInteger 类型的数据<br><br>BigInteger integer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(<span class="hljs-string">&quot;123&quot;</span>);<br>BigInteger integer1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(<span class="hljs-string">&quot;345&quot;</span>);<br><br>integer.add(integer1); <span class="hljs-comment">// 计算和</span><br>integer.subtract(integer1); <span class="hljs-comment">//计算与 integer1 的差</span><br>integer.multiply(integer1); <span class="hljs-comment">// 计算 积</span><br>integer.divide(integer1); <span class="hljs-comment">// 计算与 integer1 商</span><br>BigInteger res[]=integer.divideAndRemainder(integer1); <span class="hljs-comment">// 计算与 integer 的商，第一个位置为 商 ，第二个位置为 余数</span><br></code></pre></td></tr></table></figure><p><code> BigDecimal</code> 多用于数据精度高的地方，因为 <code>double</code> 和<code>float</code>容易丢失精度、<br>用法和<code>BigInteger</code>基本一样，多了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">BigDecimal d=BigDecimal.valueOf(<span class="hljs-number">0.99</span>); <span class="hljs-comment">// 可以将 double 类型的数转为 BigDecimal</span><br></code></pre></td></tr></table></figure><h2 id="（7）日期类"><a href="#（7）日期类" class="headerlink" title="（7）日期类"></a>（7）日期类</h2><h2 id="（8）包装类"><a href="#（8）包装类" class="headerlink" title="（8）包装类"></a>（8）包装类</h2><p><a href="https://blog.csdn.net/qq_42764468/article/details/87898191?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170199312816800182745560%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170199312816800182745560&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-87898191-null-null.142%5Ev96%5Econtrol&utm_term=%E5%8C%85%E8%A3%85%E7%B1%BB&spm=1018.2226.3001.4187">不想写了转一下</a><br><a href="https://blog.csdn.net/weixin_43362924/article/details/123728673?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-123728673.142%5Ev96%5Econtrol&spm=1018.2226.3001.4187">正则表达式</a><br><a href="https://blog.csdn.net/m0_62618110/article/details/123704869?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170199437416800225582728%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170199437416800225582728&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-123704869-null-null.142%5Ev96%5Econtrol&utm_term=java%E4%B8%AD%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95&spm=1018.2226.3001.4187">Java正则表达式用法</a></p><h1 id="3、I-O"><a href="#3、I-O" class="headerlink" title="3、I&#x2F;O"></a>3、I&#x2F;O</h1><p><img src="/../../img/java/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/d00b21c3f9eb8fef1b5d52648c1fd0a6.png"></p><h2 id="（1）、File类"><a href="#（1）、File类" class="headerlink" title="（1）、File类"></a>（1）、File类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">File(); 参数为路径，根据指定路径创建一个File对像，可以为<span class="hljs-number">2</span>个参数，具体参考样例<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E://test//Test.txt&quot;</span>);<br><br><span class="hljs-comment">//可以写为</span><br><br><span class="hljs-type">File</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E://test&quot;</span>);<br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parent,<span class="hljs-string">&quot;Test.txt&quot;</span>);<br></code></pre></td></tr></table></figure><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> te=file.exists();<span class="hljs-comment">// 判断文件是否存在</span><br><span class="hljs-type">boolean</span> te=file.delete();<span class="hljs-comment">// 如果删除文件成功则返回 true</span><br><span class="hljs-type">boolean</span> te=file.createNewFile();<span class="hljs-comment">// 当前文件不存在时，创建一个新文件，成功返回true</span><br><span class="hljs-type">boolean</span> te=file.canWrite();<span class="hljs-comment">// 判断文件是否可读，可读返回true</span><br><span class="hljs-type">boolean</span> te=file.isDirectory();<span class="hljs-comment">//判断File对象是否是目录</span><br><br>String name=file.getName();<span class="hljs-comment">// 返回文件的名字</span><br>String path=file.getPath();<span class="hljs-comment">// 返回文件的路径（相对路径）</span><br>String patha=file.getAbsolutePath();<span class="hljs-comment">// 返回绝对路径</span><br><br><span class="hljs-type">long</span> time=file.lastModified();<span class="hljs-comment">// 返回文件的最后修改时间</span><br><span class="hljs-type">long</span> tie=file.length(); <span class="hljs-comment">// 返回文件的字节长度</span><br></code></pre></td></tr></table></figure><p>有时候需要用到一些临时文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">File file=File.createTempFile(<span class="hljs-string">&quot;te&quot;</span>,<span class="hljs-string">&quot;.txt&quot;</span>);<span class="hljs-comment">// 文件的名字和后缀</span><br>file.deleteOnExit();<span class="hljs-comment">// 在推出虚拟机后自动删除</span><br></code></pre></td></tr></table></figure><h2 id="（2）字节流"><a href="#（2）字节流" class="headerlink" title="（2）字节流"></a>（2）字节流</h2><p><code> FileInputStream</code>是文件字节输入流<br><code> InputStream</code>是字节输入流</p><p>前者是后者的子类</p><p>用法基本相同<br>1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">FileInputStream fileInputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;te.txt&quot;</span>);<span class="hljs-comment">// 文件字节输入流</span><br>   <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>((b=fileInputStream.read())!=-<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//每次读取一个字节，当等与-1 表示文件读取完毕，读取会返回一个0~255的整数</span><br>       System.out.println(b);<br>   &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 读取数据，读取缓冲区指定大小的数据</span><br><span class="hljs-comment">  * 返回实际读取字节的数量(长度),如果未读取到数据则返回-1</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> - <span class="hljs-number">1</span>;<br> <span class="hljs-comment">//循环读取文件中的数据,当len的值为-1时表示读取结束</span><br> <span class="hljs-keyword">while</span>((len=fileInputStream.read(buf,<span class="hljs-number">0</span>,buf.length))!=-<span class="hljs-number">1</span>)&#123;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 将字节数组中的字节转换字符串</span><br><span class="hljs-comment">      * 指定转换的起始下标，及转换长度</span><br><span class="hljs-comment">      */</span><br><br>     <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf,<span class="hljs-number">0</span>,len);<br><br>     System.out.println(str);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>输出流</strong>（<code>OutputStream</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span>; <span class="hljs-comment">// 写入一个字节</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b)</span>;<span class="hljs-comment">// 写入指定的字节数组</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b,<span class="hljs-type">int</span> off ,<span class="hljs-type">int</span> len)</span>;<span class="hljs-comment">// 从 off 开始的len字节写入 </span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span>;<span class="hljs-comment">// OutputStream 类的方法，刷新输出流，并强制写出所有缓冲的输出字节</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<span class="hljs-comment">// 输入/输出 关闭输入/输出流</span><br></code></pre></td></tr></table></figure><h2 id="（3）-字符流"><a href="#（3）-字符流" class="headerlink" title="（3） 字符流"></a>（3） 字符流</h2><p><code>FileReader</code> 输入流<br><code>FileWriter</code> 输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>;<span class="hljs-comment">// 以字符为单位读取数据</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">char</span> cbuf[])</span>; <span class="hljs-comment">// 将数据读入char类型的数组，并返回数据长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">char</span> cbuf[],<span class="hljs-type">int</span> star,<span class="hljs-type">int</span> len)</span>; <span class="hljs-comment">// 将数据读入char类型的数组，并返回数据长度，从star开始写len个</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">transferTo</span><span class="hljs-params">(Writer out)</span>;<span class="hljs-comment">// 将数据直接读入字符输出流 </span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span>;<span class="hljs-comment">// 以字符为单位写入数据</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">char</span> cbuf[])</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">char</span> cbuf[],<span class="hljs-type">int</span> star,<span class="hljs-type">int</span> len)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">wirte</span><span class="hljs-params">(String str)</span>; <span class="hljs-comment">// 将String类型的数据写出</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">wirte</span><span class="hljs-params">(String str,<span class="hljs-type">int</span> star,<span class="hljs-type">int</span> len)</span>;<span class="hljs-comment">// 指定str的区间</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span>;<span class="hljs-comment">// 只有输出流有</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql常用字符集和排序规则</title>
    <link href="/2024/12/11/mysql/mysql%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    <url>/2024/12/11/mysql/mysql%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="utf8mb4-和-utf8mb3-的区别"><a href="#utf8mb4-和-utf8mb3-的区别" class="headerlink" title="utf8mb4 和 utf8mb3 的区别"></a><code>utf8mb4</code> 和 <code>utf8mb3</code> 的区别</h3><ol><li><p><strong>utf8mb3</strong>：</p><ul><li>它是一个较旧的字符集，用于存储 UTF-8 编码的字符数据，最多支持 3 字节的字符。</li><li>由于最多支持 3 字节，它不能存储一些超出基本多文种平面（BMP）范围的字符（例如 Emoji 表情等）。因此，它不支持所有的 Unicode 字符。</li></ul></li><li><p><strong>utf8mb4</strong>：</p><ul><li>它是 <code>utf8mb3</code> 的超集，能够支持 4 字节的字符，包括所有 Unicode 字符（如 emoji 和一些亚洲特殊字符等）。</li><li>由于支持 4 字节，<code>utf8mb4</code> 能够存储更多种类的字符，尤其是 BMP 之外的字符</li></ul></li></ol><table><thead><tr><th>字符集</th><th>排序方式</th><th>描述</th></tr></thead><tbody><tr><td><code>utf8mb3</code></td><td><code>utf8mb3_general_ci</code></td><td>不区分大小写的通用排序规则，适用于多种语言。</td></tr><tr><td><code>utf8mb3</code></td><td><code>utf8mb3_unicode_ci</code></td><td>更精确的 Unicode 排序，支持更多语言。</td></tr><tr><td></td><td></td><td></td></tr><tr><td><code>utf8mb4</code></td><td><code>utf8mb4_general_ci</code></td><td>不区分大小写的通用排序规则，适用于大多数语言。</td></tr><tr><td><code>utf8mb4</code></td><td><code>utf8mb4_unicode_ci</code></td><td>更精确的 Unicode 排序，支持更多语言的复杂排序。</td></tr><tr><td><code>utf8mb4</code></td><td><code>utf8mb4_bin</code></td><td>按字节顺序比较字符，区分大小写，非常精确的二进制排序规则</td></tr></tbody></table><h3 id="xxxxx-0900-ai-ci"><a href="#xxxxx-0900-ai-ci" class="headerlink" title="xxxxx_0900_ai_ci"></a><strong><code>xxxxx_0900_ai_ci</code></strong></h3><ol><li><p>**<code>0900</code>**：</p><ul><li><code>0900</code> 代表 MySQL 版本 8.0（MySQL 8.0 版本引入了新的 Unicode 排序规则）。这个数字表示该排序规则是在 MySQL 8.0 中引入的，并且它基于 Unicode 9.0 规范进行优化。</li></ul></li><li><p>**<code>ai</code>**：</p><ul><li><code>ai</code> 代表 <strong>accent insensitive</strong>（不区分重音）。在进行字符比较时，这种排序规则会忽略字符中的重音符号（例如，<code>é</code> 和 <code>e</code> 被视为相同的字符）。</li></ul></li><li><p>**<code>ci</code>**：</p><ul><li><code>ci</code> 代表 <strong>case insensitive</strong>（不区分大小写）。在字符比较时，它会忽略大小写的差异（例如，<code>A</code> 和 <code>a</code> 被视为相同的字符）</li></ul></li></ol><hr><ul><li><blockquote><p> <strong><code>as</code></strong> &#x3D; accent sensitive（区分重音）</p><p><strong><code>cs</code></strong> &#x3D; case sensitive（区分大小写</p></blockquote></li></ul><div class="note note-success">            <p>&emsp;&emsp;常用<code>uft8mb4</code> 和 <code>utf8mb4_0900_ai_ci</code> </p>          </div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组期末复习</title>
    <link href="/2024/12/05/%E8%AE%A1%E7%BB%84/%E8%AE%A1%E7%BB%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/12/05/%E8%AE%A1%E7%BB%84/%E8%AE%A1%E7%BB%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-顺序存储和交叉存储"><a href="#1-顺序存储和交叉存储" class="headerlink" title="1.顺序存储和交叉存储"></a>1.顺序存储和交叉存储</h2><p><strong>顺序存储</strong>又称<strong>高位交叉编址</strong></p><p><strong>交叉存储</strong>又称 <strong>低位交叉存储</strong></p><p><strong>低位交叉</strong>存储连续取<code>n个字</code>所需的时间为<br>$$<br>t_1&#x3D;T+(n-1)τ<br>$$<br><strong>高位交叉</strong>存储连续取<code>n个字</code>所需的时间为<br>$$<br>t2&#x3D;nT<br>$$</p><p>$$<br>带宽&#x3D;\frac{bit}{s}<br>[这里的是单位]<br>$$</p><h2 id="2-冯·诺依曼"><a href="#2-冯·诺依曼" class="headerlink" title="2.冯·诺依曼"></a>2.冯·诺依曼</h2><p>冯·诺依曼计算机的主要<strong>设计思想是以“存储程序”为基础，是以运算器为中心的。</strong></p><p>主要组成部分有：<strong>运算器，控制器</strong>(前两个合起来称为CPU)，<strong>存储器，输入设备和输出设备</strong>五大部件。</p><h2 id="3-动态存储器"><a href="#3-动态存储器" class="headerlink" title="3.动态存储器"></a>3.动态存储器</h2><p>&emsp;&emsp;刷新的目的：由于存储单元被访问是随机的，有可能某些存储单元长期得不到，不进行存储器的读&#x2F;写操作，其存储单元内的原信息将会慢慢消失，为此，必须采用定时刷新的方法。</p><p>常用的刷新方式：</p><ol><li><p>集中刷新：集中刷新是在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读&#x2F;写操作。</p></li><li><p>分散刷新：分散刷新是指对每行存储单元的刷新分散到每个存取周期内完成、</p></li><li><p>异步刷新：既可缩短“死时间”，又充分利用最大刷新间隔为2ms的特点。</p></li></ol><h2 id="4-微指令、指令"><a href="#4-微指令、指令" class="headerlink" title="4.微指令、指令"></a>4.微指令、指令</h2><p>指令：指挥机器工作的指示和命令</p><p>微指令：把在同一CPU周期内并行执行的微操作控制信息，存储在控制存储器里，称为一条微指令</p><p>机器指令和微指令之间的关系：<br>(1) 一条机器指令对应一个微程序，这个微程序是由若干条微指令构成的。因此，一条机器指令的功能是若干条微指令组成的序列来实现的。简而言之，一条机器指令所完成的操作划分成若干条微指令来完成，由微指令进行解释和执行。</p><p>(2)从指令与微指令，程序与微程序，地址与微地址的一一对应关系上看，前者与内存储器有关，而后者与控制存储器（它是微程序控制器的一部分。微程序控制器主要由控制存储器、微指令寄存器和地址转移逻辑三部分组成。其中，微指令寄存器又分为微地址寄存器和微命令寄存器两部分）有关，与此相关也有相对应的硬设备。</p><p>(3)从一般指令的微程序执行流程图可以看出。每个CPU周期就对于一条微指令。这就告诉我们怎么设计微程序，也将使得我们进一步体验到机器指令很微指令的关系。</p><h2 id="5-Cache主存地址映射"><a href="#5-Cache主存地址映射" class="headerlink" title="5.Cache主存地址映射"></a>5.Cache主存地址映射</h2><ol><li>直接映射(一对多的方式)</li><li>全相连映射 （多对多）</li><li>组相连映射</li></ol><p>更多可参考：<a href="https://blog.csdn.net/aiden_kevin/article/details/113198046">Cache与主存的三种地址映射详细解读</a></p><hr><p>&emsp;&emsp;主存容量为 512 K  * 16 位，Cache容量为 4096 * 16 位，块长为4个16位的字，访存地址为字地址</p><blockquote><p>Cache 容量为 $4096 &#x3D; 2^{12}$ 字，则 Cache 字地址为 12 位</p><p>块长为4，且访存地址为字地址，字块内地址为 $log_2 4&#x3D;2$</p><p>主存容量为 $512 K &#x3D; 2^{19}$ 字，主存地址为 19 位</p></blockquote><p>&emsp;&emsp;对于直接映射和全相连映射则有 </p><p><strong>主存字块标记 &#x3D; 19 - 12 &#x3D; 7</strong></p><p><strong>Cache字块地址 &#x3D; $log_2\frac{4096}{4}&#x3D;log_2{2^{10}}&#x3D;10$</strong></p><p><strong>字块内地址 &#x3D; 2</strong></p><p>&emsp;&emsp;对于二路组相连， <strong>一个组内有两块</strong>，</p><p>则 <strong>Cache 共分为 $\frac{2^{10}}{2}&#x3D;2^9$ 组</strong>，即 <strong>组地址为 9</strong>， 主存字块标记  &#x3D; 19 - 9 -2 &#x3D;8</p><p>四路组相连，一个组内有 4块，则 <strong>Cache 共分为 $\frac{2^{10}}{4}&#x3D;2^8$ 组</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">直接映射：<br>| 主存字块标记（7） | Cache字块地址（10） | 字块内地址（2） |<br><br>全相连映射：<br>| 主存字块标记（17） | 字块内地址（2） |<br><br>二路组相连映射：<br>| 主存字块标记（8） | 组地址（9） | 字块内地址（2） |<br></code></pre></td></tr></table></figure><div class="note note-success">            <ol><li><strong>字地址</strong>：字地址是用于定位字块内某个字（word）的地址。在一个字块内，通常会有多个字，每个字都有一个唯一的字地址。字地址的位数取决于字块内字的数量。</li><li><strong>字节地址</strong>：字节地址是用于定位字内某个字节（byte）的地址。由于一个字通常由多个字节组成（例如，32位系统中的一个字通常由4个字节组成），因此需要使用字节地址来进一步定位字内的数据。</li></ol><p><strong>对于字块内地址：</strong></p><p>假设有一个存储系统，其中每个字块包含16个字，每个字32位（即4个字节）。</p><ol><li><strong>按字寻址</strong>：<ul><li>字地址位数：由于每个字块包含16个字，因此字地址需要4位二进制数来表示（因为2^4 &#x3D; 16）。</li><li>字块内地址位数：在这种情况下，字块内地址就等于字地址，即4位。</li></ul></li><li><strong>按字节寻址</strong>：<ul><li>字地址位数：同样需要4位二进制数来表示字地址。</li><li>字节地址位数：由于每个字包含4个字节，因此字节地址需要2位二进制数来表示（因为2^2 &#x3D; 4）。</li><li>字块内地址位数：在这种情况下，字块内地址由字地址和字节地址共同构成，即4位（字地址）+ 2位（字节地址）&#x3D; 6位。</li></ul></li></ol>          </div><h2 id="6-数据寻址"><a href="#6-数据寻址" class="headerlink" title="6.数据寻址"></a>6.数据寻址</h2><p><a href="https://blog.csdn.net/vavid317/article/details/120553807">计组——十种数据寻址方式</a></p>]]></content>
    
    
    <categories>
      
      <category>上岸</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络期末复习</title>
    <link href="/2024/12/02/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/12/02/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="五层体系结构"><a href="#五层体系结构" class="headerlink" title="五层体系结构"></a>五层体系结构</h1><blockquote><p>自上向下：应用层、运输层、网络层、数据链路层、物理层</p></blockquote><hr><h2 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1.应用层"></a>1.应用层</h2><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E5%BA%94%E7%94%A8%E5%B1%82.png"></p><h3 id="应用层协议类型"><a href="#应用层协议类型" class="headerlink" title="应用层协议类型"></a>应用层协议类型</h3><ol><li>HTTP（超文本传输协议）</li><li>FTP（文件传输协议）</li><li>SMTP（简单邮件传输协议）</li><li>DNS（域名解析协议）</li></ol><h2 id="2-运输层"><a href="#2-运输层" class="headerlink" title="2.运输层"></a>2.运输层</h2><p>本小节的主要内容来自：<a href="https://blog.csdn.net/OYMNCHR/article/details/119118383">计算机网络总结——运输层</a></p><p>运输层有三个阶段</p><ul><li>连接建立（三次握手）</li><li>数据传送</li><li>连接释放（四次挥手）</li></ul><p><strong>运输层向它上面的应用层提供通信服务</strong></p><p>在计算机网络中进行通信的<strong>真正实体是</strong>通信主机中的<strong>进程</strong>。也就是说，端到端的通信是应用进程之间的通信</p><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E8%BF%90%E8%BE%93%E5%B1%821.png" alt="mac帧"></p><p><strong>网络层为主机之间的通信提供服务，而运输层则在网络层的基础上，为应用进程之间的通信提供服务</strong></p><p>运输层主要需要有两种不同的运输协议，即<strong>面向连接的TCP</strong>和<strong>无连接的UDP</strong></p><h3 id="2-1-端口号"><a href="#2-1-端口号" class="headerlink" title="2.1 端口号"></a>2.1 端口号</h3><p>端口号使用16比特表示，取值范围为0-65535，分为以下两大类：</p><ol><li><p>服务器使用的端口：</p><ul><li><p>熟知端口号：<strong>0-1023</strong>，IANA把这些端口号指派给了TCP&#x2F;IP体系中最重要的一些应用协议，如：FTP使用21和20号端口，HTTP使用80号端口，DNS使用53端口号。</p></li><li><p>登记端口号：<strong>1024-49151</strong>，为没有熟知端口号的应用进程使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复，例如微软远程桌面RDP使用的端口号为3389。</p></li></ul></li><li><p>客户端使用的端口号：</p><p>   短暂端口号（别称）：<strong>49152-65535</strong>，留给客户进程暂时使用。通信结束后，这个端口号可供其他客户进程使用。</p><p>   <img src="/../../img/%E8%AE%A1%E7%BD%91/%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt="常用的端口号"></p></li></ol><p>&emsp;&emsp;端口号只具有本地意义，即端口号只是为了标识本计算机中各进程，不同计算机可能有相同的端口号，但是并没有任何关系</p><h3 id="2-2UDP和TCP的对比"><a href="#2-2UDP和TCP的对比" class="headerlink" title="2.2UDP和TCP的对比"></a>2.2UDP和TCP的对比</h3><blockquote><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E5%AF%B9%E6%AF%941.png"></p><ol><li>UDP可以随时发送数据，也就是<strong>无连接的。</strong></li><li>TCP发送数据之前需要先建立连接，也就是<strong>面向连接的</strong>。</li></ol></blockquote><hr><blockquote><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E5%AF%B9%E6%AF%942.png"></p><ol><li>在局域网中，UDP可以<strong>发送单播，多播，广播数据</strong></li><li>而TCP只能发送<strong>单播数据。</strong></li></ol></blockquote><hr><blockquote><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E5%AF%B9%E6%AF%943.png"></p><p>对应用报文的处理方式不同：</p><ol><li>UDP对应用层的应用层报文直接添加一个首部，然后<strong>直接进行发送</strong>。接收方接收数据报后去掉首部，上交给上层应用层</li><li>&emsp;&emsp;TCP把应用层交付下来的数据块仅仅看作是一连串的，无结构的字节流，<strong>并将它们进行编号，存储在自己的发送缓存中，</strong>TCP根据发送策略，从发送缓存中提取一定数量的字节，构建成TCP报文段进行发送。接收方一方面从所接受的TCP报文段中取出数据载荷部分并存储在接收缓存中，一方面将接收缓存的一些字节交付给应用进程。</li></ol></blockquote><hr><blockquote><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E5%AF%B9%E6%AF%944.png"></p><ol><li>UDP协议向其上层提供的是<strong>无连接不可靠传输服务</strong>，数据报发生误码仅仅丢弃，并不会采取其他措施。</li><li>TCP协议向其上层提供的是<strong>面向连接的可靠服务</strong>。</li></ol></blockquote><hr><blockquote><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E5%AF%B9%E6%AF%945.png" alt="图一"></p><ol><li>UDP由于不提供可靠传输服务，<strong>首部比较简单</strong>。</li><li>TCP由于要实现可靠传输，流量控制，拥塞控制等服务，其<strong>首部比较复杂</strong>。</li></ol></blockquote><hr><p>注意：TCP 提供了全双工的通信方式</p><h3 id="2-3-TCP-首部格式"><a href="#2-3-TCP-首部格式" class="headerlink" title="2.3 TCP 首部格式"></a>2.3 TCP 首部格式</h3><p>如上图中的格式：</p><ol><li><strong>确认号（ ack ）</strong>： 4个字节，是 <strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>；应当记住：<font color="#d34751">确认号 &#x3D; N ，则表明：到序号 N - 1 为止的所有数据都已正确收到</font></li><li><strong>紧急 URG</strong> ： 当 URG &#x3D; 1 时，表明紧急指针字段有效。告诉系统，此报文段中有紧急数据，因尽快传送（相当于高优先级的数据），而不要按照原来的排队顺序传送</li></ol><ul><li>注意：<strong>并不意味着本报文段中的所有数据都是紧急数据</strong>，紧急数据的范围从TCP首部中的“紧急指针”字段所指的位置开始，直到报文段结束</li></ul><ol start="3"><li><strong>确认 ACK ：</strong>仅当<code> ACK=1</code> 的时候<strong>确认号</strong>字段才有效，<strong>一般只有</strong>第一次握手的时候<code>ACK=0</code>才会成立。TCP 规定，在建立连接后所有传送的报文段都必须把<code>ACK</code><strong>置为1</strong></li><li><strong>复位 RST</strong>：当<code>RST = 1</code>时，表明 TCP 连接中出现严重差错（如主机崩溃），必须释放连接，然后重新建立运输连接。</li><li><strong>同步 SYN</strong>： 当<code>SYN = 1 &amp;&amp; ACK = 0</code>时，表明这是一个连接请求报文段。若对方同意建立连接，则应在响应的报文段中使用<code>SYN = 1 &amp;&amp; ACK = 1</code>。故： <strong>SYN 置为 1 就表示这是一个连接请求或连接接受报文</strong></li><li><strong>终止 FIN</strong> ： <code>FIN = 1</code>表示此报文段发送方的数据已发送完，并要求释放运输连接</li><li><strong>窗口</strong> ： 2字节。 它表示接收方当前愿意接收的最大数据量（以字节为单位）。发送方会根据这个窗口大小来决定可以连续发送多少数据而不必等待对方的确认。<font color="#d34751">应当记住：窗口字段明确指出了 现在 允许对方发送的数据量，窗口值经常在动态变化着 </font></li></ol><p>&emsp;&emsp;MSS（最大报文段长度）是TCP协议中的一个重要参数，它表示TCP报文段中<strong>数据部分的最大允许长度</strong>，不包括TCP头部和IP头部</p><h3 id="2-4-连续-ARQ-协议"><a href="#2-4-连续-ARQ-协议" class="headerlink" title="2.4 连续 ARQ 协议"></a>2.4 连续 ARQ 协议</h3><p>它允许发送方在未收到确认的情况下连续发送多个数据分组。</p><p> <strong>连续ARQ协议的基本原理</strong></p><ul><li><strong>发送窗口</strong>：发送方维护一个发送窗口，窗口内的分组可以连续发送，不需要等待每个分组的确认。</li><li><strong>接收窗口</strong>：接收方有一个接收窗口，表示它一次可以接收的数据分组数量。</li><li><strong>累积确认</strong>：接收方通常采用累积确认的方式，即只对按序到达的最后一个分组发送确认，表示直到该分组为止的所有分组都已正确接收。</li></ul><p>更多参考：<a href="https://blog.csdn.net/OYMNCHR/article/details/119118383">计算机网络总结——运输层</a></p><h3 id="2-5-拥塞控制"><a href="#2-5-拥塞控制" class="headerlink" title="2.5 拥塞控制"></a>2.5 拥塞控制</h3><blockquote><p> 假定：以最大报文段的个数为讨论问题的单位，而不是以字节为单位。</p></blockquote><p><strong>控制方法：</strong></p><ol><li><p>慢开始</p><p>即由小到大逐渐增大发送窗口，也就是说，由小到达逐渐增大拥塞窗口值</p><p><strong>每经过一个传输轮次，拥塞窗口就加倍。</strong></p><p>传输轮次：发送方发送完报文段并且接收方进行确认，也就是一个往返时间</p></li><li><p>拥塞避免</p><p><code>为了防止拥塞窗口cwnd增长过大引起网络拥塞</code>，还需要设置一个慢开始<strong>门限ssthresh</strong>状态变量</p><ul><li>当cwnd &lt; ssthresh时，使用上述的<code>慢开始</code>算法。</li><li>当cwnd &gt; ssthresh时，<code>停止使用慢开始算法而改用拥塞避免算法</code>。</li><li>当cwnd &#x3D; ssthresh时，<code>既可使用慢开始算法，也可使用拥塞避免算法</code>。</li></ul></li><li><p>快重传</p><p>&emsp;&emsp;如下图所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3但却收到了M4。本来接收方可以什么都不做。<strong>但按照快重传算法，接收方必须立即发送对M2的重复确认</strong>，以便让发送方尽早知道接收方没有收到报文段M3。发送方接着发送M5和M6.接收方收到后也仍要<strong>再次分别发出对M2的重复确认</strong></p><p>&emsp;&emsp;快重传算法规定，发送方只要<strong>一连收到3个重复确认</strong>，就知道接收方确实没有收到报文段M3，因而应该立即进行重传(即“快重传”)，这样就不会出现超时 (如果没有快重传，只要发生超时就执行门限ssthresh &#x2F; 2,然后慢开始) ，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约20%。</p><p>总的来说就是：</p><ul><li>要求接收方不要等到自己发送数据时才捎带确认，而是要<strong>立即发送确认</strong>。</li><li>即使收到了失序的报文段也要立即对已收到报文段的<strong>重复确认</strong>。</li><li>发送方一旦收到<strong>3个连续的重复确认</strong>后，就将相应的报文段<strong>立即重传</strong>，而不是等该报文段的超时重传计时器超时再重传。</li></ul><p><img src="/../../img/%E8%AE%A1%E7%BD%91/3-ACK.png"></p></li><li><p>快恢复</p><p>发送方一旦<strong>收到3个重复确认</strong>，就知道现在只是丢失了个别报文段，于是<strong>不启动慢开始算法，而执行快恢复算法。</strong></p><p>发送方将<strong>慢开始门限值和拥塞窗口值调整为当前窗口的一半</strong>，开始<strong>执行拥塞避免算法</strong>。</p></li></ol><p><strong>操作步骤整合如下</strong>：</p><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png"></p><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><h3 id="2-5-三次握手"><a href="#2-5-三次握手" class="headerlink" title="2.5 三次握手"></a>2.5 三次握手</h3><p>并不是发送了三次，而是在 <strong>一次握手的时候，交换了三个报文，类似于：两个人握手，上下挥动了3次</strong></p><p><img src="/../../img/%E8%AE%A1%E7%BD%91/3%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><p>采用三次握手的方法：<strong>防止已经失效的连接请求报文段突然又传送到了（并没有丢失，只不过是时间延长了），因而产生的 TCP 连接错误</strong></p><p><strong>部分细节：</strong></p><blockquote><ol><li>在第一次，A 向 B 发出连接请求报文段，其首部中的同步位 SYN &#x3D; 1，并选择序号 seq &#x3D; x，表明传送数据时的第一个数据字节的序号是 x。</li><li>B 收到连接请求报文段后，同意A的请求，发回确认，B 在确认报文段中设置SYN &#x3D; 1，ACK &#x3D; 1，确认号ack &#x3D; x+1（注意确认号的值，所代表的意思） ，自己选择的序号 seq &#x3D; y</li><li>A收到此报文段后向 B 给出确认，设置 ACK &#x3D; 1，确认号 ack &#x3D; y +1，seq&#x3D;x+1（因为：SYN 报文段不能携带数据，但是 <strong>要消耗掉一个序号</strong>），然后 A 通知上层应用进程，连接已经建立。</li></ol></blockquote><h3 id="4-6-四次挥手"><a href="#4-6-四次挥手" class="headerlink" title="4.6 四次挥手"></a>4.6 四次挥手</h3><ul><li><strong>第一步</strong>：客户端进程发出断开连接指令，这将导致客户端的<code>TCP</code>程序创建一个特殊的<code>TCP</code>报文段，发送到服务器。这个报文段的<code>FIN</code>字段被置为1，表示这是一条断开连接的报文；</li><li><strong>第二步</strong>：服务器接收到客户端发来的断开连接报文，向客户端回送这个报文的确认报文（<code>ACK</code>字段为<code>1</code>），告诉服务器已经接收到<code>FIN</code>报文，并允许断开连接；</li><li><strong>第三步</strong>：服务器发送完确认报文后，服务器的<code>TCP</code>程序创建一条自己的断开连接报文，此报文的<code>FIN</code>字段被置为<code>1</code>，然后发往客户端；</li><li><strong>第四步</strong>：客户端接收到服务器发来的<code>FIN</code>报文段，则产生一条确认报文（<code>ACK</code>为<code>1</code>），发送给服务器，告知服务器已经接收到了它的断开报文。服务器接收到这条<code>ACK</code>报文段后，释放<code>TCP</code>连接相关的资源（缓存和变量），而<strong>客户端等待一段时间后</strong>（半分钟、一分钟或两分钟），也释放处于客户端的缓存和变量；</li></ul><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p><blockquote><p>Q： 为什么 TCP 关闭连接为什么要四次而不是三次？</p><p>A：服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段，接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接，然后客户端再做出应答，因此一共需要四次挥手。</p><p>Q：客户端为什么需要在 TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态？</p><p>A：按照常理，在网络正常的情况下，四个报文段发送完后，双方就可以关闭连接进入 CLOSED 状态了，但是网络并不总是可靠的，如果客户端发送的 ACK 报文段丢失，服务器在接收不到 ACK 的情况下会一直重发 FIN 报文段，这显然不是我们想要的。因此客户端为了确保服务器收到了 ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL 的时间，如果在此期间又收到了来自服务器的 FIN 报文段，那么客户端会重新设置计时器并再次等待 2MSL 的时间，如果在这段时间内没有收到来自服务器的 FIN 报文，那就说明服务器已经成功收到了 ACK 报文，此时客户端就可以进入 CLOSED 状态了。</p></blockquote><div class="note note-success">            <p>&emsp;&emsp;在我们做题的时候，要计算最短时间，那么图中的<strong>第二步，第三步</strong>是同时发生的，因为没有数据要发送</p><p>最短时间为 &#x3D;  1.5RTT + 2MSL</p>          </div><h3 id="运输层协议类型"><a href="#运输层协议类型" class="headerlink" title="运输层协议类型"></a>运输层协议类型</h3><ol><li>TCP（传输控制协议）</li><li>UDP（用户数据报协议）</li></ol><hr><h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h2><p>也称为： <strong>IP层、网际层</strong></p><hr><h3 id="1-网际协议IP"><a href="#1-网际协议IP" class="headerlink" title="1.网际协议IP"></a>1.网际协议IP</h3><p>即互联网协议地址，与之配套的还有 <strong>ARP、ICMP、IGMP</strong></p><h3 id="2-直接交付和间接交付"><a href="#2-直接交付和间接交付" class="headerlink" title="2.直接交付和间接交付"></a>2.直接交付和间接交付</h3><p>&emsp;&emsp;不需要经过任何路由器的是 <strong>直接交付</strong>，反之是间接交付</p><blockquote><p>h1  -&gt;  R1 -&gt; R2 -&gt; h2</p><p>h1到R1，R1到R2，的数据发送为间接,</p><p>R2到h2 ，为直接交付</p></blockquote><h3 id="3-IP地址格式和分类"><a href="#3-IP地址格式和分类" class="headerlink" title="3.IP地址格式和分类"></a>3.IP地址格式和分类</h3><blockquote><p>IP地址 &#x3D; 网络号(n位)  主机号(32-n位)</p></blockquote><ul><li><p>A类地址（网络号8位）</p><p>：第一个字节表示网络地址，范围从1.0.0.0到126.255.255.255。适用于大型网络</p></li><li><p>B类地址（网络号16位）</p><p>：前两个字节表示网络地址，范围从128.0.0.0到191.255.255.255。适用于中型网络</p></li><li><p>C类地址（网络号24位）</p><p>：前三个字节表示网络地址，范围从192.0.0.0到223.255.255.255。适用于小型网络</p></li></ul><p><img src="/../../img/%E8%AE%A1%E7%BD%91/ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt="mac帧"></p><p><strong>网络前缀前面的固定数字为网络标识位</strong></p><h3 id="4-CIDR无分类编址"><a href="#4-CIDR无分类编址" class="headerlink" title="4.CIDR无分类编址"></a>4.CIDR无分类编址</h3><p>CIDR使用斜杠（&#x2F;）后跟一个数字来表示一个IP地址块，这个数字表示网络前缀的位数，即子网掩码中连续的1的个数</p><div class="note note-success">            <p>设 n 为主机号</p><p>可分配 ip 个数 &#x3D; 2^n - 2   （网络地址、广播地址）</p><p>可接入计算机个数 &#x3D;  2^n - 3  （多了一个网关）</p>          </div><div class="note note-primary">            <p>在计算某个网络包含了多少个C类地址的话，可以用<br>$$<br>个数 &#x3D; 2^{该网络的网络前缀位数 - C类主机号位数}<br>$$</p>          </div><h3 id="5-路由聚合"><a href="#5-路由聚合" class="headerlink" title="5.路由聚合"></a>5.路由聚合</h3><p>就是寻找需要聚合的CIDR地址块的<strong>公共前缀</strong></p><h3 id="6-IP地址与MAC地址"><a href="#6-IP地址与MAC地址" class="headerlink" title="6.IP地址与MAC地址"></a>6.IP地址与MAC地址</h3><p><img src="/../../img/%E8%AE%A1%E7%BD%91/TCPIP%E5%8D%8F%E8%AE%AE.png"></p><p>上图以HTTP协议为例，具体说明</p><h3 id="7-IP数据报头部格式"><a href="#7-IP数据报头部格式" class="headerlink" title="7.IP数据报头部格式"></a>7.IP数据报头部格式</h3><p><img src="/../../img/%E8%AE%A1%E7%BD%91/ip%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%A4%B4%E9%83%A8.png"></p><ol><li>首部长度：<strong>单位：字节</strong>，最小值为<code>0101</code> 也就是 <strong>20B</strong></li><li>总长度： <strong>单位：字节</strong></li></ol><div class="note note-success">            <p>&emsp;&emsp;最大传送单元 MTU ： 在 IP 层的下面的每一种数据链路层协议都规定了一个数据帧中的数据字段的最大长度</p><p>IP数据报封装链路层的帧时，此数据报的总长度（首部加上数据部分）一定不能超过下面数据<strong>链路层所规定的MTU</strong></p>          </div><div class="note note-warning">            <p>&emsp;&emsp;在进行分片的时候，<strong>数据首部中的”总长度“</strong>字段是指分片后的<strong>每一个分片的首部长度与该分片的数据部分长度的总和</strong></p>          </div><ol start="3"><li>标志：目前之后后两位有意义<ul><li>最低位记为 <strong>MF</strong> ：<code>MF = 1</code>即表示<strong>后面还有分片</strong>的数据报，<code>MF = 0</code>表示这已是若干个数据报片中的最后一个</li><li>中间的一位记为 <strong>DF</strong> : 意思是<strong>不能分片</strong>，只有<code>DF = 0</code>时才允许分片</li></ul></li><li>片偏移：相对于用户数据字段的起点，该分片从何处开始。偏位移以<strong>8个字节</strong>为单位，也就是说，除了最后一个数据报片外，其每个分片的长度一定是8字节的整数倍</li></ol><div class="note note-info">            <p>片偏移的计算：</p><p>​将一段数据分片后（不要加入首部地址计算），用每段的第一个数据部分所在的位置除以8，即得到该片的片偏移值</p><p>例如： <strong>数据部分</strong>为3800字节的数据报，每个分片长度不超多1420字节</p><p>&emsp;&emsp;则可以分3个数据报片，数据报的数据部分长度为：1400、1400、1000，则每片的片偏移值为 0&#x2F;8&#x3D;0, 1400&#x2F;8&#x3D;175, 2800&#x2F;8&#x3D;350</p><p>&emsp;&emsp;每片的MF,DF的值为：1,0  ； 1,0 ； 0,0</p><p><strong>计算的时候，一定要注意是总长度（加上头部的20B），还是数据部分的长度！！！！！</strong></p>          </div><h3 id="8-地址解析协议ARP"><a href="#8-地址解析协议ARP" class="headerlink" title="8.地址解析协议ARP"></a>8.地址解析协议ARP</h3><p>从 ip 到 mac 的解析；从 mac 到 ip 的解析是 RARP</p><p>主机的<strong>MAC</strong>地址实际上就是其网络适配器的MAC地址</p><p><strong>每一台主机都设有一个ARP高速缓存</strong>，里面存有<strong>本局域网</strong>上的各主机和路由器的 <strong>IP 地址到 MAC 地址的映射表</strong></p><blockquote><p>ARP 用与解决 <strong>同一个局域网上</strong> 的主机或路由器的 IP 地址到 MAC 地址的映射问题</p><p> IP 地址到 MAC 地址的映射是自动完成的</p></blockquote><h3 id="9-网际控制报文协议ICMP"><a href="#9-网际控制报文协议ICMP" class="headerlink" title="9.网际控制报文协议ICMP"></a>9.网际控制报文协议ICMP</h3><ul><li>连通性使用 <code>ping</code></li><li>路由追踪 <code>tracert</code>(windows)</li></ul><h3 id="10-路由选择协议"><a href="#10-路由选择协议" class="headerlink" title="10.路由选择协议"></a>10.路由选择协议</h3><ul><li>内部网关协议 IGP：用的最多的是 RIP 、 OSPF </li><li>外部网关协议 EGP</li></ul><h4 id="10-1-内部网关协议RIP"><a href="#10-1-内部网关协议RIP" class="headerlink" title="10.1 内部网关协议RIP"></a>10.1 内部网关协议RIP</h4><p><strong>RIP</strong> 是一种分布式的 <strong>基于距离向量的路由选择协议</strong>，是互联网的标准协议。其最大优点是简单。</p><p>该协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（因此，这是一组距离，即“<strong>距离向量</strong>”）</p><blockquote><p>从一路由器到直接连接的网络的距离定义为1。</p><p>从一主机到非直接连接的网络的距离定为所经过的路由器数加1</p><p><strong>该距离</strong>也称为<strong>跳数</strong> </p><p><font color="#d34751">该距离为最短距离，并且 RIP 允许一条路径最多只能包含 15 个网络，因此当距离为 16 时就相当于不可达</font>，可见他只适用于小型互联网</p></blockquote><hr><h4 id="路由表的更新"><a href="#路由表的更新" class="headerlink" title=" # 路由表的更新 "></a><font color="#d34751"> # 路由表的更新 </font></h4><p><strong>路由表和转发表是两个相似的概念，讨论路由选择原理的时候，往往不区分它们之间的区别</strong></p><p>基本原理再次不在叙述，只说一些写题的方法：</p><ol><li>距离向量算法：对每一相邻路由器发送过来的 RIP 报文，执行以下步骤：</li></ol><blockquote><blockquote><p> 为了更清楚认识，不妨令需要更新的路由器记为 A；</p><p>则可看做 X  &#x3D;&#x3D;&#x3D;&gt; A，X 发给 A 的  RIP 报文</p></blockquote><p>a. 对<strong>地址为X的相邻路由器发来的RIP报文</strong>，把 <strong>下一跳</strong>字段中的地址<strong>都改为X</strong>，并把所有的<strong>距离都加1</strong>，不妨只讨论一下三个关键的数据： <strong>到目的网络的地址 Net、距离 d、下一跳的路由</strong>，在本样例中，下一跳路由为 X。</p><p>b. 对修改后的 RIP 报文执行一下步骤：</p><p>以下的该项目：修改后 RIP 报文中的内容，即 <strong>执行步骤 a 之后的路由表</strong></p><blockquote><p>i. 若原来的路由表（路由表A）中<strong>没有目的网络 Net</strong> ，则把该项目添加到路由表（路由表A）中</p><ul><li><p>否则，<strong>有目的网络 Net</strong> ，同时，<strong>若下一跳的路由器地址 为 X</strong>，则<strong>把收到的项目替换原来路由表的项目</strong>（即：把该项目替换 A 中的项目）</p></li><li><p>否则，<strong>有目的网络 Net</strong> ，同时，<strong>下一跳的路由器地址 不是 X</strong>，</p><blockquote><p>如果该项目中的距离小于路由表中的距离，则更新</p><p>否则，什么也不做</p><p>&emsp;&emsp;<strong>也就是取最短距离更新</strong></p></blockquote></li></ul></blockquote></blockquote><ol start="2"><li>平常写题的时候，有时并不是都是上面的那种情况，就是单纯的给一个网络拓扑图，然后写出路由表</li></ol><p>在分析之前，首先要确定，我们此时写出的路由表的模版：</p><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E8%B7%AF%E7%94%B1%E8%A1%A8%E7%9A%84%E5%86%99%E6%B3%95.png" alt="图1 "></p><p>目的网络地址：写的是网络号</p><p>下一跳地址：写的是别的路由器的IP地址</p><p>路由器接口：写的是数据从本路由器的哪个端口发出</p><p>&emsp;&emsp;注意：图中的<code>0.0.0.0</code>是<strong>默认路由</strong>，这就是不管目的网络在哪里，都有指定的路由器 R 来处理，上图中路由器 R 的 IP 为<code>192.168.0.65</code>。我们需要知道：<strong>全0 的掩码和任何目的地址进行 AND 运算，结果一定是全0</strong>。</p><ul><li>Q：那么也即是说，经过该路由表转发的分组，都会从这个全0 段发出去，那么，其他的目的网络不就不可以用了吗？？？？？？</li><li>A：其实，按照最长前缀匹配原则，默认路由的优先级最低，也就是说，当其他网络地址没有匹配上，才会从此地址发出去</li></ul><div class="note note-success">            <p>&emsp;&emsp;最长匹配原则：在路由表查找过程中，路由器会将数据包的目的IP地址与路由表中的条目进行逐位比较，选择与目的IP地址匹配的最长网络前缀的路由条目</p>          </div><div class="note note-warning">            <p>&emsp;&emsp;我们在写题的时候，要灵活一点，看题目主要是让我们写出什么信息！！！</p><p>上述四列不一定都要写</p>          </div><hr><hr><p>有了上面的解释之后，可看如下图：</p><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E6%8B%93%E6%89%91%E5%9B%BE1.png"></p><p>Q：假如与R互连的接入Internet的另一台路由器的端口IP为211.84.5.1，R与S连接的端口为E0,写出R的路由表？</p><table><thead><tr><th align="center">目的网络</th><th align="center">地址掩码</th><th align="center">下一跳&#x2F;路由器接口</th></tr></thead><tbody><tr><td align="center">192.168.1.0</td><td align="center">255.255.255.128</td><td align="center">E0</td></tr><tr><td align="center">0.0.0.0</td><td align="center">0.0.0.0</td><td align="center">211.84.5.1</td></tr></tbody></table><p>分析：路由器 R 的下面为同一个网络：<code>192.168.1.0/25</code>，那么目的网络就为<code>192.168.1.0/25</code>。</p><p><strong>再看一个：</strong></p><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E6%8B%93%E6%89%91%E5%9B%BE2.png"></p><p>注意：</p><ul><li>此题目中说明了 <strong>尽量使用默认路由简化</strong>，故 R1 路由表向右边跳的时候都经过 R2 因此，可以简化</li><li>R2 有3个目的网络，然后，其他3个网络必须经过不同的路由器，故要写出来</li><li>在没有下一跳的情况下，尽量用 <strong>-</strong> 这个写，不要用<strong>图一</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="![图1 ](../../img/计网/路由表的写法.png)图一">[1]</span></a></sup>种的写法</li></ul> <div class="note note-danger">            <p>&emsp;&emsp;在不理解深层原理的时候，注意先记住如何写（个人感觉知道怎么写，比原理好理解&gt;_&lt;）！！</p><p><strong>首先能写题，然后再去深究原理！！！！！！！！</strong></p>          </div><hr><p>可参考：</p><ol><li><p><a href="https://www.cnblogs.com/yunjisuanchengzhanglu/p/16621175.html">路由器工作原理、路由表的形成、静态路由、缺省路由、单臂路由</a></p></li><li><p><a href="https://blog.csdn.net/weixin_42319408/article/details/103704387">计算路由表</a></p></li></ol><hr><h4 id="10-2外部网关协议OSPF"><a href="#10-2外部网关协议OSPF" class="headerlink" title="10.2外部网关协议OSPF"></a>10.2外部网关协议OSPF</h4><p><strong>开放最短路径优先OSPF</strong>，为了克服 RIP 的缺点在 1989 年开发出来的</p><p><strong>最短路径优先</strong>是因为使用了 Dijkstra 提出的最短路径算法 SPF。</p><p><strong>OSPF</strong>只是一个协议的名字，他并不表示其他的路由选择协议不是“最短路径优先”。</p><p><font color="skyblue">关于OSPF的其他的知识点并非不重要，只不过没时间写这个了。。。。hhh</font></p><hr><h3 id="11-虚拟专用网-VPN"><a href="#11-虚拟专用网-VPN" class="headerlink" title="11.虚拟专用网 VPN"></a>11.虚拟专用网 VPN</h3><p>&emsp;&emsp;本地地址： 仅在本机构有效的 IP 地址。这类地址以169.254开头，主要用于设备在无法获取DHCP服务器分配的IP地址时，自动配置网络参数</p><p>&emsp;&emsp;专用地址，也称为私有地址，是在私有网络中使用的IP地址范围。这些地址不会被路由器或互联网上的其他网络所使用，主要用于局域网或公司内部使用。有如下三块</p><blockquote><p>10.x.x.x</p><p>172.16.x.x — 172.31.x.x</p><p>192.168.x.x</p></blockquote><p><font color="skyblue">不过多写了。。。。。</font></p><h3 id="12-网络地址转换-NAT"><a href="#12-网络地址转换-NAT" class="headerlink" title="12.网络地址转换 NAT"></a>12.网络地址转换 NAT</h3><p>&emsp;&emsp;网络地址转换技术NAT——<strong>主要用于实现位于内部网络的主机访问外部网络的功能</strong>。当局域网内的主机需要访问外部网络时，通过NAT技术可以将其私网地址转换为公网地址，并且多个私网用户可以共用一个公网地址，这样既可保证网络互通，又节省了公网地址。</p><p>&emsp;&emsp;<strong>NAT是将IP数据报文头部中的IP地址转换为另一个IP地址的过程，主要用于实现内部网络（私有IP地址）访问外部网络（公有IP地址）的功能。</strong></p><p>更多可参考：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/157769590">NAT网络地址转换</a></li><li><a href="https://blog.csdn.net/qq_21125183/article/details/86487747">NAT基本原理</a></li></ol><h3 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h3><ol><li>IP（互联网协议）</li><li>ICMP（互联网控制报文协议）</li><li>ARP（地址解析协议）</li></ol><hr><h2 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4.数据链路层"></a>4.数据链路层</h2><h3 id="1-信道类型"><a href="#1-信道类型" class="headerlink" title="1.信道类型"></a>1.信道类型</h3><ol><li>点对点信道</li><li>广播信道</li></ol><h3 id="2-帧"><a href="#2-帧" class="headerlink" title="2.帧"></a>2.帧</h3><h4 id="1、封装成帧"><a href="#1、封装成帧" class="headerlink" title="1、封装成帧"></a>1、封装成帧</h4><p><code>：</code> 在一段数据的前后分别添加首部和尾部</p><p><code>MTU</code>：帧的数据部分长度上线（最大传送单元）</p><p><code>SOH  数据部分 EOT</code>： 帧定界使用特殊的字帧定界符</p><h4 id="2、透明传输"><a href="#2、透明传输" class="headerlink" title="2、透明传输"></a>2、透明传输</h4><p><code>：</code> 帧使用文本文件组成（文本文件中的字符都是从键盘上输入的）</p><p>为了解决数据中同样存在帧界定字符，使用<code>ESC</code>转移字符加在特殊字符前（这是字节填充，还有一种字符填充）</p><h4 id="3、差错检验"><a href="#3、差错检验" class="headerlink" title="3、差错检验"></a>3、差错检验</h4><p><code>CRC</code>:循环冗余检验</p><blockquote><p>该检验方法为在正常的数据后面添加计算得到的 <strong>FCS</strong>（帧检验序列）</p><ul><li>计算步骤如下：</li></ul><blockquote><p> 除数<strong>P</strong>肯定是已知的，一下的运算数据均为二进制下的状态</p><ol><li>首先在<strong>传送的数据M</strong>部分后面加上 <code>n个0</code> ，<strong>n为除数的位数 - 1</strong> </li><li><strong>M</strong>除以<strong>P</strong>求出余数（余数的位数一定小于除数，但是我们要保证添加的余数的位数为<code>n位</code> ，即，<strong>位数不够的在前面加0</strong>）</li></ol><p>在进行除法的过程中，<strong>减法使用异或运算</strong>，<strong>减法的过程中不用在差的前面补零</strong>  （和书上的不太一样，但是这个方法更好理解）</p></blockquote><p>检验的过程：</p><blockquote><ul><li><p>将收到的数据除以除数，得到的余数为零，即没有差错</p></li><li><p>只能判断是否出错，如果出错需要重传</p></li></ul></blockquote><p>生成多项式：</p><blockquote><p>即除数的值</p><p>一般采用：<br>$$<br>P(X)&#x3D;X^3+X+1<br>$$<br>的形式出现，上述的除数为<code>1011</code>,即：从最高次幂开始，如果该次幂存在则该位为1，否则为0</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text"><br><br>上述公式：<br><br>最高次幂为3，次幂为3存在则该位置为1,<br><br>2次幂不存在，该位置为0,<br><br>1次幂存在该位置为1,<br><br>0次幂存在该位置为1，<br><br>即从高位到低位有：1011<br><br><br></code></pre></td></tr></table></figure></blockquote></blockquote><h3 id="4-传输差错分类"><a href="#4-传输差错分类" class="headerlink" title="4.传输差错分类"></a>4.传输差错分类</h3><ol><li><p>比特差错：</p><p>举例：数据链路层通过 CRC 检验后，进行接受的数据均无差错，但是，出现差错的帧被丢掉了，可能会导致接受的帧不够</p></li><li><p>传输差错</p><p>举例：帧丢失、帧重复、帧失序属于传输差错，这些帧中均无比特差错</p></li></ol><h3 id="5-PPP点对点协议"><a href="#5-PPP点对点协议" class="headerlink" title="5.PPP点对点协议"></a>5.PPP点对点协议</h3><ol><li><p>设计时的要求：</p><ul><li>简单</li><li>封装成帧</li><li>透明性</li><li>差错检验</li><li>MTU（一般等于1500B）</li><li>等</li></ul></li><li><p>组成</p><blockquote><ol><li>一个IP数据报分装到串行链路的方法。IP 数据报在 PPP帧中就是信息部分</li><li>一个用来建立、配置、测试数据链路连接的链路控制协议 LCP</li><li>一套网络控制协议 NCP</li></ol></blockquote></li><li><p>格式</p><blockquote><p>按照顺序：</p><ol><li><p>首部</p><blockquote><p><code>1B：</code> F、 7E（F为字段标志，7E为该字段的值，下同理）</p><p><code>1B：</code> A、FF</p><p><code>1B：</code> C、03</p><p><code>2B：</code> 协议</p></blockquote></li><li><p>信息部分（即为，IP 数据报），长度可变，不超过 1500B</p></li><li><p>尾部</p><blockquote><p><code>2B：</code> FCS（帧的检验序列）</p><p><code>1B：</code> F、7E</p></blockquote></li></ol></blockquote></li><li><p><strong>字节填充</strong></p><p>规定：转移字符为 <code>0x7D</code></p><p>填充方法：</p><ol><li><code>0x7E</code>转为<code>0x7D,0x5E</code></li><li><code>0x7D</code>转为<code>0x7D,0x5D</code></li><li>如果出现数值小于<code>0x20</code>则在他的前面加上<code>0x7D</code></li></ol></li><li><p>零比特填充</p><p>PPP 在使用同步传输（一连串的比特连续传送）而不是异步传输（逐个字符的发送），做法如下：</p><ol><li>扫描整个信息字段</li><li>发现<strong>连续的5个1</strong> ，则立即在<strong>后面填上一个0</strong></li></ol></li></ol><div class="note note-success">            <p>适配器：计算机与外界局域网的连接就是通过适配器实现的。适配器本来是在主机箱内插入的一块网络接口板，这种接口板又称为 <strong>网络接口卡 NIC</strong> ，简称： <strong>网卡</strong></p>          </div><h3 id="5-CSMA-CD协议"><a href="#5-CSMA-CD协议" class="headerlink" title="5.CSMA&#x2F;CD协议"></a>5.CSMA&#x2F;CD协议</h3><p>意思为：载波监听多点接入&#x2F;碰撞检测</p><p>要点：</p><p>1.多点接入： 说明这是总线型网络</p><p>2.载波监听： 边监听边发送</p><hr><p>在发送中检测信道，是为了及时发现如果有其他站也在发送，就立即中断本站的发送，这就是 <strong>碰撞检测</strong>；他是适配器边发送数据边检测信道上的信号电压的变化情况</p><div class="note note-success">            <p>电磁波在 1km 电缆的传播时延约为 5us</p>          </div><p><strong>在局域网的分析中，常把总线上单程端到端传播时延记为  τ</strong>  （tao，第四声，希腊字符）</p><p><strong>取总线两个站之间（这两个站之间的距离最大）的传播时延为端到端的传播时延</strong></p><p><strong>这个协议为半双工通信</strong></p><hr><p>对于一条具体的信道：<br>$$<br>最短有效帧长 &#x3D; 发送速率 × 2τ<br>$$</p><p>$$<br>τ &#x3D; \frac{链路长度}{电磁波在链路上的传播速度}<br>$$</p><hr><p>以太网端到端的往返时间 <strong>2τ</strong> 称为<strong>争用期</strong>。<strong>争用期又称为碰撞窗口</strong></p><p>以太网通过 <strong>截断二进制指数退避</strong> 算法确定重传时机。</p><p>他有如下规定：</p><ol><li>基本退避时间为争用期 2τ ，具体时间为 <strong>51.2us</strong>，对于 <strong>10Mbit&#x2F;s</strong>以太网在争用期内可发送 512 比特，即 64 字节，也可以称为 <strong>512比特时间</strong></li><li>从集合 [ 0 , 1 , … ,  $2^k$ -1 ] 中随机取一个数，记为 <strong>r</strong>，重传应推后的时间是 <strong>r</strong> 倍的争用期，<strong>但是 ，k&#x3D;min( 重传次数，10 )</strong> </li><li>当<strong>重传16次</strong>仍不能成功，则丢弃该帧，并向高层汇报</li></ol><hr><p>从上面知道：<strong>凡是长度小于 64 字节的帧都是由于冲突而异常终止的无效帧</strong> </p><div class="note note-primary">            <p>以太网中最短有效帧长为 64 个字节，请从争用信道的角度分析原因？</p><p>&emsp;&emsp;对于争用信道的以太网，为了减少冲突发生的概率，使用的是 CSMA&#x2F;CD 协议， 该协议规定了基本退避时间为 51.2µs，对于 10Mbit&#x2F;s 的以太网，在争用期内可发送 512bit，即 64 字节，凡是长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</p>          </div><h3 id="6-以太网的MAC层"><a href="#6-以太网的MAC层" class="headerlink" title="6.以太网的MAC层"></a>6.以太网的MAC层</h3><p>在局域网中，硬件地址又称为物理地址或MAC地址（因为这种地址用MAC帧）</p><p>发送本站的帧：</p><ol><li>单播（一对一），收到的帧的MAC地址和本站的相同</li><li>广播（一对全体），发送给本局域网上所有站点的帧（全1地址）</li><li>多播（一对多），发送给本局域网上部分站点的帧</li></ol><hr><p>MAC帧格式：</p><p><img src="/../../img/%E8%AE%A1%E7%BD%91/mac%E5%B8%A7.png" alt="mac帧"></p><h3 id="7-集线器、路由器"><a href="#7-集线器、路由器" class="headerlink" title="7.集线器、路由器"></a>7.集线器、路由器</h3><p>1、集线器</p><blockquote><p>&emsp;&emsp;集线器是工作在物理层的设备，当他收到数据以后就把这个数据复制复制以后就把这个数据象所有的接口发送一次。所以集线器所有的接口是一个冲突域和广播域。</p></blockquote><p>2、交换机</p><blockquote><p>&emsp;&emsp;交换机就和集线器不一样了，交换机工作数据链路层的设备，他能够识别数据帧和MAC地址，他工作的方式就和集线器有很大的区别。交换机是依靠MAC地址表来转发数据。对于MAC地址表里没有的数据就广播。所以我们说交换机的每个接口都是一个冲突域，交换机的所有的接口都属于一个广播域。</p></blockquote><p>3、路由器</p><blockquote><p>&emsp;&emsp;路由器是工作在网络层的设备，路由器转发数据是依靠路由表来转发数据。对于广播流量路由器会处理但是不会转发数据。所以我们说路由器的每个接口都属于同一个冲突域和广播域。路由器可以用来隔离广播。</p></blockquote><p>总结</p><blockquote><p>   &emsp;&emsp; 集线器（HUB）所有端口都在同一个广播域、冲突域内，所以HUB不能分割冲突域和广播域。<br>   &emsp;&emsp; 交换机（Switch）所有端口都在同一个广播域内，而每一个端口就是一个冲突域，所以交换机能分割冲突域，但分割不了广播域。虚拟局域网（Vlan）技术可以隔离广播域。<br>    &emsp;&emsp;路由器（Router）的每个端口属于不同的广播域、冲突域。</p></blockquote><p>也可以这样理解：</p><blockquote><p>HUB属于第一层设备所以分隔不了冲突域；<br>交换机和网桥属于第二层设备所以能分割冲突域；<br>路由器属于第三层设备，所以既能分割冲突域又能分割广播域。</p></blockquote><hr><p>1、冲突域（碰撞域）</p><blockquote><p><strong>冲突域是指在一个局域网（LAN）上，当两个或多个设备同时发送数据帧（数据包）时，可能发生冲突的区域</strong>。在以太网中，当两个设备同时发送数据帧到同一个物理网络（例如，使用同一根网线）时，它们的数据帧可能会在中途碰撞，导致数据帧损坏，需要重新传输。</p></blockquote><p>2、广播域</p><blockquote><p><strong>广播域是指在一个网络中，广播数据包可以传播到的范围</strong>。广播数据包是一种特殊的数据包，它会被发送到网络中的所有设备，而不仅仅是目标设备。通常广播数据包用于网络发现和配置。</p></blockquote><p><img src="/../../img/%E8%AE%A1%E7%BD%91/%E5%86%B2%E7%AA%81%E5%9F%9F.png" alt="冲突域"></p><h3 id="8-虚拟局域网（VLAN）"><a href="#8-虚拟局域网（VLAN）" class="headerlink" title="8.虚拟局域网（VLAN）"></a>8.虚拟局域网（VLAN）</h3><hr><p><strong>能隔离碰撞域的不一定能隔离广播域，能隔离广播域的一定能隔离碰撞域</strong></p><hr><p>&emsp;&emsp;VLAN（Virtual Local Area Network，虚拟局域网） 是一种将网络中的设备划分为逻辑子网的技术。与传统的物理局域网不同，VLAN不依赖设备的物理位置，而是基于逻辑划分，将局域网内的设备虚拟地组织到同一组。这种方式允许网络管理员按照不同的需求，将不同区域、不同楼层，甚至不同交换机上的设备，划分到同一个VLAN中，使其表现得像一个独立的子网。</p><p><img src="/../../img/%E8%AE%A1%E7%BD%91/802.1Q%E5%B8%A7.png" alt="冲突域"></p><p>&emsp;&emsp;<strong>VLAN标识</strong>(上图802.1Q标识字段)：每个虚拟局域网都有一个唯一的标识符，称为VLAN标识（VLAN ID）。这个标识（具体是<strong>VID的12位</strong>）可以是一个数字，通常范围在1到4094之间。VLAN标识用于区分不同的虚拟局域网。</p><p><strong>插入该标识字段后，FCS要重新进行计算</strong></p><p>工作原理：</p><ol><li><p>端口划分：交换机上的每个端口都可以配置为属于一个或多个VLAN。通过配置端口所属的VLAN，可以将该端口上的设备划分到相应的虚拟局域网中。</p></li><li><p>数据转发：<strong>交换机会根据目标MAC地址来转发数据，根据端口配置将数据转发到相应的VLAN</strong>。在同一个VLAN内部的设备之间的数据交换是直接进行的，而不同VLAN之间的数据需要经过路由器或三层交换机进行转发。</p></li><li><p>VLAN隔离：不同的VLAN之间是逻辑上隔离的，设备在一个VLAN中无法直接访问另一个VLAN中的设备。这种隔离可以提高网络的安全性，防止未授权的访问。</p></li></ol><p>关于VLAN的划分，参考：<a href="https://blog.csdn.net/mansky0618/article/details/80292511">VLAN 划分——基于交换机端口划分VLAN</a></p><hr><h3 id="协议类型-1"><a href="#协议类型-1" class="headerlink" title="协议类型"></a>协议类型</h3><ol><li>以太网协议（帧的生成、传输、接受）</li><li>PPP（点对点协议）</li><li>CSMA&#x2F;CD（载波监听多路访问&#x2F;碰撞检测）</li></ol><hr><h2 id="5-物理层"><a href="#5-物理层" class="headerlink" title="5.物理层"></a>5.物理层</h2><h3 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h3><ul><li><p>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列等</p></li><li><p>电气特性：指明接口电缆的各条线上出现的电压范围</p></li><li><p>功能特性：指明某条线上出现的某一电平的电压意义</p></li><li><p>过程特性：指明对不同功能的各种可能事件的出现顺序</p></li></ul><h3 id="2-信道"><a href="#2-信道" class="headerlink" title="2. 信道"></a>2. 信道</h3><ul><li>单向通信（单工通信）：只能有一个方向的通信；例如：无线电广播、有线电广播、电视</li><li>双向交替通信（半双工通信）：双方都可以发送信息，但是<strong>不能同时发送</strong> </li><li>双向同时通信（全双工通信）：双方可以同时发送和接受信息</li></ul><h3 id="3-奈氏准则和香农公式"><a href="#3-奈氏准则和香农公式" class="headerlink" title="3. 奈氏准则和香农公式"></a>3. 奈氏准则和香农公式</h3><blockquote><p> 奈氏准则：在宽带为 W（Hz）的低通信道中，如不考虑噪声影响，则码元传输的最高速率是 2W（码元&#x2F;s）。传输速率超过此上限，就会出现严重的马间串扰的问题，是接受码元的判决（即识别）称为不可能。</p></blockquote><div class="note note-success">            <p>$$<br>B&#x3D;2W<br>$$<br><code>B</code>:码元传输速率<br>$$<br>M&#x3D;2^n<br>$$<br>$$<br>n&#x3D;log_2 M<br>$$</p><p><code>M</code>：码元状态数（不同振幅的信号的个数 | 频率 | 相位）<br>$$<br>C &#x3D;Wlog_2(1+\frac{S}{N}) [香农公式]\<br> &#x3D; Bn\<br> &#x3D; B log_2 M\<br> &#x3D; 2Wlog_2M<br>$$</p><p><code>W</code>:带宽（Hz）</p><p><code>S</code>: 信道内所传信号的平均功率</p><p><code>N</code>：为信道内部的高斯噪声功率</p><p><code>C</code>:单位 <code>bit/s</code></p>          </div><h3 id="协议类型-2"><a href="#协议类型-2" class="headerlink" title="协议类型"></a>协议类型</h3><ol><li>EIA&#x2F;TIA RS-2322</li><li>IEEE 802.3（以太网）</li><li>IEEE 802.11（无线局域网）</li></ol><h1 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><img src="/../../img/%E8%AE%A1%E7%BD%91/%E8%B7%AF%E7%94%B1%E8%A1%A8%E7%9A%84%E5%86%99%E6%B3%95.png" alt="图1 ">图一<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>上岸</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo文章</title>
    <link href="/2024/11/30/hexo/hexo%E6%96%87%E7%AB%A0/"/>
    <url>/2024/11/30/hexo/hexo%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Tag的使用"><a href="#Tag的使用" class="headerlink" title="Tag的使用"></a>Tag的使用</h1><p>在 markdown 中加入如下的代码来使用便签：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% note success %&#125;<br>文字 或者 <span class="hljs-code">`markdown`</span> 均可<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure><p>或者使用 HTML 形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>样式如下：</p><div class="note note-primary">            <p><code>primary</code> 文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-secondary">            <p><code>secondary</code> </p>          </div><div class="note note-success">            <p><code>success</code> </p>          </div><div class="note note-danger">            <p><code>danger</code> </p>          </div><div class="note note-warning">            <p><code>warning</code> </p>          </div><div class="note note-info">            <p><code>info</code> </p>          </div><div class="note note-light">            <p><code>light</code> </p>          </div><h1 id="勾选框"><a href="#勾选框" class="headerlink" title="勾选框"></a>勾选框</h1><p>在 markdown 中加入如下的代码来使用 Checkbox：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% cb text, checked?, incline? %&#125;<br></code></pre></td></tr></table></figure><p>text：显示的文字<br>checked：默认是否已勾选，默认 false<br>incline: 是否内联（可以理解为后面的文字是否换行），默认 false</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;% cb 普通示例 %&#125;<br><br>&#123;% cb 默认选中, true %&#125;<br><br>&#123;% cb 内联示例, false, true %&#125; 后面文字不换行<br><br>&#123;% cb false %&#125; 也可以只传入一个参数，文字写在后边（这样不支持外联）<br></code></pre></td></tr></table></figure><div>            <input type="checkbox"  >普通示例          </div><div>            <input type="checkbox"  checked="checked">默认选中          </div>            <input type="checkbox"  >内联示例           后面文字不换行<br /><input type="checkbox" disabled > 也可以只传入一个参数，文字写在后边（这样不支持外联）<h1 id="图片的组合"><a href="#图片的组合" class="headerlink" title="图片的组合"></a>图片的组合</h1><p>如果想把多张图片按一定布局组合显示，你可以在 markdown 中按如下格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% gi total n1-n2-... %&#125;<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>  ![](<span class="hljs-link">url</span>)<br>&#123;% endgi %&#125;<br></code></pre></td></tr></table></figure><p><code>total</code>：图片总数量，对应中间包含的图片 url 数量<br><code>n1-n2-...</code>：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于 total，否则按默认样式</p><p>如<code>&#123;% gi 5 3-2 %&#125;</code> 示例，代表共 5 张图，第一行 3 张图，第二行 2 张图。</p><h1 id="站内文章引用"><a href="#站内文章引用" class="headerlink" title="站内文章引用"></a>站内文章引用</h1><p><strong>post_link</strong></p><ul><li>通过内置的标签插件的语法 <code>post_link</code>来实现引用。</li><li>这里默认的路径是在 <code>_post</code> 路径下，如果不是默认路径，需要写上相对路径。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;% post_link <span class="hljs-string">&#x27;文章文件名(不要后缀)&#x27;</span> <span class="hljs-string">&#x27;文章标题(可选,自定义名字)&#x27;</span> %&#125;<br></code></pre></td></tr></table></figure><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><h2 id="1、关于中括号的问题"><a href="#1、关于中括号的问题" class="headerlink" title="1、关于中括号的问题"></a>1、关于中括号的问题</h2><p>不在代码块中的 <code>&#123;</code> 不能出现一对，否则不能渲染页面</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2024/11/30/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/11/30/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1-互联网的概述"><a href="#1-1-互联网的概述" class="headerlink" title="1.1 互联网的概述"></a>1.1 互联网的概述</h2><p>互联网具有两个最重要的基本特点：<strong>连通性和共享</strong></p><p>计算机网络（简称为<strong>网络</strong>）由若干个节点和连接这些节点的链路组成</p><blockquote><p>网络中的节点可以是计算机、集线器、交换机和路由器等</p><blockquote><p>例如：由三个计算机通过三条链路连接到一个集线器上，这就是一个简单的计算机网络（简称为网络）</p><p>&emsp;&emsp; 由许多网络通过路由器相互连接起来，构成了一个覆盖范围更大的计算机网络，这样的网络称为<strong>互连网</strong></p><p>因此，互连网是一个<strong>网络的网络</strong></p></blockquote><p>网络把许多计算机连接在一起，而<strong>互连网</strong>则把许多网络通过一些路由器连接在一起。与网络相连的计算机常称为主机。</p><blockquote><p>&emsp;一般用云表示的网络已经包含了网络中的计算机，为了讨论方便（例如：讨论几个计算机之间如何进行通信），一般把有关的计算机画在云外。</p><p>&emsp; 习惯上：与网络相连的计算机成为<strong>主机</strong>，在互联网中不可缺少的<strong>路由器是一种特殊的计算机</strong>（有中央处理器、存储器、操作系统等），<strong>但不能成为主机</strong></p></blockquote></blockquote><p><strong>注意：</strong> </p><ol><li><code>internet</code> （互连网）是一个通用名词，他泛指有多个计算机网络互连而成的计算机网络，在这些网络之间的通信协议（即通信规则）可以任意选择，不一定非要使用<code>TCP/IP协议</code></li><li><code>Internet</code>（互联网，或因特网）则是一个专用名词，他指当前全球最大的、开放的、由众多网络相互连接而成的<strong>特定互连网</strong>，它采用<code>TCP/IP协议</code>族作为通信的规则，且其前身是美国的 AEPANET</li></ol><ul><li>可见，任意把几个计算机网络互连起来（不管采用什么协议），并能够互相通信，<strong>这样构成的是一个互连网</strong>，<strong>而不是互联网</strong></li></ul><h2 id="1-2-互联网的组成"><a href="#1-2-互联网的组成" class="headerlink" title="1.2 互联网的组成"></a>1.2 互联网的组成</h2><p>从工作方式上看，可以划分为两大类：</p><ol><li><strong>边缘部分</strong> :由所有连接在互联网上的主机组成，这部分是<strong>用户直接使用的</strong>，用来进行通信（传送数据、音频、视频）和资源共享 </li><li><strong>核心部分</strong> : 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）</li></ol><ul><li><blockquote><p><strong>边缘部分</strong>：</p><p>&emsp; 处在互联网边缘的部分就是连接在互联网上的所有的主机，这些主机又称<strong>端系统</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*  端系统</span><br><span class="hljs-comment">    小的端系统可以是一台普通的个人电脑和具有上网功能的智能手机、甚至是一个很小的网络摄像头、大的端系统可以是一个昂贵的大型计算机</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure><p>主机<strong>A</strong>的某个进程和主机<strong>B</strong>上的另一个进程进行通信，这种说法通常可以简称为<strong>计算机之间通信</strong></p><p><strong>边缘方式的通信可以分为两大类：</strong>客户-服务器方式（C&#x2F;S方式）和对等方式（P2P方式）</p><ol><li>C&#x2F;S</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* </span><br><span class="hljs-comment">客户和服务器都是值通信中所涉及的两个应用进程，他们描述的是进程之间服务和被服务的关系</span><br><span class="hljs-comment">服务请求方和服务提供方都要使用网络核心部分所提供的服</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">但是他们之间的通信可以是双向的，客户和服务器都可发送和接受数据！！！！！！！</span><br></code></pre></td></tr></table></figure><ol start="2"><li>P2P</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* </span><br><span class="hljs-comment">没有明确的服务请求方和服务提供者，具体看进程工作时的动作</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">对等连接工作方式可支持大量对等用户（如上百万个）同时工作</span><br></code></pre></td></tr></table></figure></blockquote><ul><li><blockquote><p><strong>核心部分</strong></p><p>&emsp;核心部分是互联网中最复杂的部分，因为<strong>网络中的核心部分要向网络边缘部分中的大量主机提供连通性，使边缘部分中的任何一台主机都能够与其他主机通信</strong> </p><p>&emsp; 起<strong>特殊作用的是路由器</strong>，他是一种专用计算机（但不叫作主机）。路由器是实现<strong>分组交换</strong>的关键构件，其任务是<strong>转发收到的分组</strong>，这是网络核心部分最重要的功能</p><blockquote><p>为了了解分组交换，首先了解电路交换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* </span><br><span class="hljs-comment">交换：从通信资源的分配来看，他就是按照某种方式动态的分配传输路线的资源</span><br><span class="hljs-comment">    必须经过：  建立连接（占用通信资源）---&gt; 通话（已知占用资源）--&gt; 释放连接（归还通信资源） 三个步骤的交换方式成为电路交换</span><br><span class="hljs-comment">    电路交换的一个重要特点：</span><br><span class="hljs-comment">    在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure><p>分组交换：</p><p>​通常把要发送的整块数据成为一个<strong>报文</strong>。</p><p>​在发送报文之前，先把报文划分为一个个更小的等长数据段，在每一个数据段前面，加上一些必要的控制信息组成的<strong>首部</strong>后，就构成了一个<strong>分组</strong>，分组又称为“<strong>包</strong>”，而分组的首部也可称为“包头”。</p></blockquote></blockquote></li></ul></li></ul><h2 id="1-6计算机网络的性能"><a href="#1-6计算机网络的性能" class="headerlink" title="1.6计算机网络的性能"></a>1.6计算机网络的性能</h2><ol><li><blockquote><p><strong>速率</strong>：网络中的速率指的是数据的传送速率，也称为<strong>数据率</strong>或<strong>比特率</strong> </p><p>​单位 <code>bit/s</code>（比特每秒）或 <code>b/s</code> 有时也写为<code>bps</code> ，当速率较高的时候，就在单位前加一个字母，如：<br>$$<br>k&#x3D;10^3 （千）\<br>M&#x3D;10^6  （兆）<br>$$</p><p>当提到网络速率的时候，往往指的是<strong>额定速率或标称速率</strong></p><p><strong>注意： B 是字节，1个字节&#x3D;8比特</strong></p></blockquote></li><li><blockquote><p><strong>带宽</strong></p><ol><li>本来指某个信号具有的频带宽度，信号的带宽指的是该信号包含的各种不同频率成分所占据的频率范围，这种意义的<strong>带宽的单位是赫</strong> </li><li>在计算机网络中，带宽用来表示网络中<strong>某通</strong>道传送数据的能力，因此网络带宽表示<strong>单位时间内</strong>网络中的某信道所能通过的最<strong>高数据率</strong> ，单位 <code>bit/s</code></li></ol></blockquote></li><li><blockquote><p><strong>吞吐量</strong> ： 表示在单位时间内通过某个网络的实际数据量</p></blockquote></li><li><blockquote><p><strong>时延</strong>： 指数据（一个报文或分组，甚至比特）从网络（或链路）的一段传送到另一端所需的时间</p><p>​       他是一个重要的性能指标，他有事也称为<strong>延迟或迟延</strong></p><p>网络的时延是由以下几个不同的部分组成：</p><ol><li><strong>发送时延</strong> ： 是主机或路由器发送数据帧所需要的时间（也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需要的时间），计算公式：</li></ol><p>$$<br>发送时延&#x3D;\frac{数据帧长度(bit)}{发送速率（bit&#x2F;s）}<br>$$</p><ol start="2"><li><p><strong>传播时延</strong>： 是电磁波在信道中传播一定的距离需要花费的时间，计算公式：<br>$$<br>发送时延&#x3D;\frac{信道长度(m)}{电磁波在信道上的传播速率（m&#x2F;s）}<br>$$<br>电磁波在自由空间的传播速率是光速，也就是<code>3.0 x 10^5  km/s</code>  </p></li><li><p><strong>处理时延</strong> ： 主机或路由器在收到分组时要花费一定的时间进行处理，例如：分析分组的首部、从分组中提取数据部分等</p></li><li><p><strong>排队时延</strong> ： 分组在经过网络传输时，要经过许多路由器，但分组在进入路由器后要现在输入队列中排队等待处理，在路由器确定了转发接口后，还要在输出队列中排队等待</p></li></ol><hr><p>   发送时延发生在机器内部的发送器中（一般就是发生在网络适配器中）<strong>与传输信道的长度没有任何关系</strong></p><p>   传播时延发生在机器外部的传输信道媒体上，与<strong>信号的发送速率无关</strong>，<strong>信号传送的距离越远，传播时延就越大</strong><br>$$<br>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 + 排队时延<br>$$</p></blockquote></li><li><blockquote><p><strong>时延宽带积</strong><br>$$<br>时延宽带积 &#x3D; 传播时延 + 宽带<br>$$<br>​        例如：某链路的传播时延为 20s，宽带为 10Mbit&#x2F;s，则时延宽带 &#x3D; 20 x 10 x （10^6）bit</p><p>这表明，若发送端连续发送数据，则发送的第一个比特即将到达终点时，发送端就已经发送了  20 x 10 x （10^6）比特，这写比特都在链路上向前移动，因此，链路的时延带宽积又称为 <strong>以比特为单位的链路长度</strong></p></blockquote></li><li><blockquote><p>往返时间<strong>RTT</strong> ： 双向交互一次所需的时间</p><p>​       有时也称为往返时延<br>$$<br>有效数据率&#x3D;\frac{数据长度}{发送时间+RTT}<br>$$</p></blockquote></li><li><blockquote><p><strong>利用率</strong></p><p>​      <strong>信道利用率或网络利用率过高就会产生非常大的时延</strong></p></blockquote></li></ol><h2 id="1-7-具有五层协议的体系结构"><a href="#1-7-具有五层协议的体系结构" class="headerlink" title="1.7 具有五层协议的体系结构"></a>1.7 具有五层协议的体系结构</h2><p>对<strong>OSI</strong>的七层协议体系结构和 <strong>TCP&#x2F;IP</strong>的四层体系结构进行综合，讨论五层体系结构，即（从上到下）： <strong>应用层，运输层，网络层，数据链路层，物理层</strong></p><ol><li><blockquote><p><strong>应用层</strong>：协议定义：应用进程间通信和交互的规则   （进程指的是主机中正在运行的程序）</p><p>​    任务：<strong>通过应用进程间的交互来完成特定网络应用</strong></p><p>​    我们将应用层交互的数据单元称为<strong>报文</strong></p><p>如：域名系统DNS、支持万维网应用的HTTP协议等</p></blockquote></li><li><blockquote><p><strong>运输层</strong> ： 任务：向两台主机中进程之间的通信提供<strong>通用的数据传输服务</strong> ，应用进程利用该服务传送应用层报文</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>上岸</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令操作</title>
    <link href="/2024/11/26/linux/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/11/26/linux/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="1、进入-root-用户"><a href="#1、进入-root-用户" class="headerlink" title="1、进入 root 用户"></a>1、进入 root 用户</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">sudo</span> <span class="hljs-string">-i</span>  <br></code></pre></td></tr></table></figure><p>输入后，输入密码即可。</p><h2 id="2、解压文件"><a href="#2、解压文件" class="headerlink" title="2、解压文件"></a>2、解压文件</h2><p><code>unzip</code>解压文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip file.zip<br></code></pre></td></tr></table></figure><p>如果要将压缩文件解压到指定的目录，可以使用 <code>-d</code> 选项指定目标目录，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip file.zip -d /path/to/destination<br></code></pre></td></tr></table></figure><p>这会将压缩文件解压到指定的目标目录中。</p><p>另外，系统中没有安装 <code>unzip</code> 命令可以通过包管理器安装它。例如，在 Ubuntu 上，可以使用以下命令安装 <code>unzip</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install unzip<br></code></pre></td></tr></table></figure><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="1-查看端口占用情况"><a href="#1-查看端口占用情况" class="headerlink" title="1.查看端口占用情况"></a>1.查看端口占用情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -aon | findstr 4000 <span class="hljs-comment"># 固定端口</span><br>netstat -ano <span class="hljs-comment"># 所有端口占用情况</span><br></code></pre></td></tr></table></figure><h2 id="2-杀死某个进程"><a href="#2-杀死某个进程" class="headerlink" title="2. 杀死某个进程"></a>2. 杀死某个进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskkill /PID &lt;进程号&gt; /F<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署springboot+前端</title>
    <link href="/2024/11/26/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/11/26/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="部署springboot-前端"><a href="#部署springboot-前端" class="headerlink" title="部署springboot+前端"></a>部署springboot+前端</h1><h1 id="1、配置java环境"><a href="#1、配置java环境" class="headerlink" title="1、配置java环境"></a>1、配置java环境</h1><ol><li>下载<code>linux</code>版本的<code>jdk</code>，在服务其中使用命令</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -zxvf jdk-17_linux-x64_bin.tar.gz<br></code></pre></td></tr></table></figure><p>解压下载的<code>jdk</code>压缩包，</p><ol start="2"><li><p>配置环境变量</p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/profile<br><br><span class="hljs-comment"># 在该文件的末尾添加一下代码</span><br>JAVA_HOME=/home/uftp/jdk-17.0.2<br>CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/lib<br>PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$JAVA_HOME</span>/jre/bin<br><span class="hljs-built_in">export</span> PATH CLASSPATH JAVA_HOME<br><br><span class="hljs-comment"># 其中，/home/uftp/jdk-17.0.2 为解压后的jdk路径</span><br><br></code></pre></td></tr></table></figure></blockquote></li><li><p>重新加载配置文件</p><blockquote><p>输入命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure></blockquote></li><li><p>查看是否配置成功</p></li></ol><blockquote><p>输入命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -version<br></code></pre></td></tr></table></figure><p>查看到相应的<code>jdk</code>版本即可</p></blockquote><h1 id="2、启动上传好的springboot的jar包"><a href="#2、启动上传好的springboot的jar包" class="headerlink" title="2、启动上传好的springboot的jar包"></a>2、启动上传好的springboot的jar包</h1><ol><li>创建文件（与<code>jar</code>包同一目录）</li></ol><blockquote><ol><li><p><code>start.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">nohup</span> java -jar classRoomAppointment-0.0.1-SNAPSHOT.jar  &amp;<br></code></pre></td></tr></table></figure></li><li><p><code>stop.sh</code></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">PID=$(ps -ef | grep classRoomAppointment-0.0.1-SNAPSHOT.jar | grep -v grep | awk <span class="hljs-string">&#x27;&#123; print $2 &#125;&#x27;</span>)<br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$PID</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> Application is already stopped<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">kill</span> <span class="hljs-variable">$PID</span><br><span class="hljs-built_in">kill</span> <span class="hljs-variable">$PID</span><br></code></pre></td></tr></table></figure><ol start="3"><li><code>log.sh</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> -f nohup.out<br></code></pre></td></tr></table></figure><ol start="4"><li><p>赋予以上文件的执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x start.sh<br></code></pre></td></tr></table></figure></li></ol></blockquote><ol start="2"><li>启动与停止</li></ol><blockquote><p>直接在上面3个文件的路径下输入<code>./start.sh</code>即可启动成功，同理输入<code>./stop.sh</code>即为停止，输入<code>./log.sh</code>即为显示日志</p></blockquote><h1 id="3、前端项目的部署"><a href="#3、前端项目的部署" class="headerlink" title="3、前端项目的部署"></a>3、前端项目的部署</h1><ol><li>安装<code>nginx</code></li></ol><ul><li>ubuntu</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get update<br>sudo apt-get install nginx<br></code></pre></td></tr></table></figure><ul><li><p>CentOS </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum update<br>sudo yum install nginx<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>启动<code>nginx</code></li></ol><ul><li>ubuntu</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl start nginx<br></code></pre></td></tr></table></figure><ul><li><p>CentOS </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl start nginx<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>配置<code>nginx</code></li></ol><p>​使用<code>whereis nginx</code>可以查看<code>nginx</code>的安装路径（有的可能有很多路径），找到<code>nginx.conf</code>文件，我的是在<code>/ect/nginx</code>中，新增一下内容：</p><blockquote><p><code>listen</code>监听的端口</p><p><code>server_name</code>请求路径</p><p><code>root</code> 定位根路径（就是前端代码的路径）</p><p><code>index</code>首页</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">http &#123;<br>    server &#123;<br>        listen 80;<br>        server_name adressTest;<br><br>        location / &#123;<br>            root /var/www/example/dist;<br>            index index.html;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>检查方法</li></ol><blockquote><p>使用命令<code>sudo nginx -t</code>可以检查有没有语法错误</p><p><code>sudo systemctl reload nginx</code>重新启动<code>ngnix</code>服务</p><p><code>sudo systemctl status nginx</code> 查看状态</p></blockquote><h1 id="4-可能遇到的问题"><a href="#4-可能遇到的问题" class="headerlink" title="4.可能遇到的问题"></a>4.可能遇到的问题</h1><ol><li><blockquote><p><code>start.sh</code>等文件中的回车问题：</p><p>使用命令 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i <span class="hljs-string">&#x27;s/\r$//&#x27;</span> start.sh<br></code></pre></td></tr></table></figure><p>即可</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java杂项（I/O、线程）</title>
    <link href="/2024/11/26/java/java%E6%9D%82%E9%A1%B9/"/>
    <url>/2024/11/26/java/java%E6%9D%82%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="1、IO"><a href="#1、IO" class="headerlink" title="1、IO"></a>1、IO</h1><p>本节的输入输出是相对于运行的<code>java文件</code></p><h2 id="1-字节流"><a href="#1-字节流" class="headerlink" title="1.字节流"></a>1.字节流</h2><p><code>FileInputStream</code> : 字节输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">FileInputStream stream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&#x27;文件路径&#x27;</span>);<br><br>stream.read(); <span class="hljs-comment">// 一个字节一个字节读取  英文：1个  汉字：3个</span><br><span class="hljs-comment">// 他的返回值为 int 类型</span><br><span class="hljs-comment">// 如果读取到最后一个的下一个，返回 -1</span><br><br><span class="hljs-type">byte</span>[] bytes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 三个字节的读取方式</span><br>stream.read(bytes); <br><span class="hljs-comment">// 如果文件有内容，则一直读取，如果不足三个字节，仍可继续读取，如果没有，则返回  -1</span><br><span class="hljs-comment">// 可用 stream.available() 获取该文件的字节数</span><br><br><br><span class="hljs-comment">// 注意：每次读取后要进行 close() ，否则该文件后续将由于占有进程而无法操作</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">可以使用 try-with-resouse 写法</span><br></code></pre></td></tr></table></figure><p><code>FileOutputStream</code> : 字节输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputStream stream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&#x27;文件路径&#x27;</span>); <span class="hljs-comment">// 每次重新将文件内容更新</span><br><br><span class="hljs-comment">// 追加模式： new FileOutputStream(&#x27;文件路径&#x27;，true);</span><br><br>stream.write(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// 可以直接写入内容</span><br>stream.write(<span class="hljs-string">&#x27;a&#x27;</span>.getBytes()); <span class="hljs-comment">// 也可转为 byte[] 写入</span><br>stream.write(<span class="hljs-string">&#x27;abcde&#x27;</span>.getBytes(),<span class="hljs-number">2</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 从字符串的第2个位置开始，写入一个字符</span><br>stream.flush(); <span class="hljs-comment">// 最后要进行刷新操作 ！！！！！！</span><br><br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>         <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test_copy.txt&quot;</span>)) &#123;<br><br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> ((len = fis.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>            fos.write(buffer, <span class="hljs-number">0</span>, len);<span class="hljs-comment">// 写入的是读取的长度，而非 1024</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br><br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-字符流"><a href="#2-字符流" class="headerlink" title="2.字符流"></a>2.字符流</h2><p><code>FileReader</code>：输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">FileReader reader=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&#x27;文件路径&#x27;</span>);<br><br>reader.read(); <span class="hljs-comment">// 读取的是一个字符！！！！ </span><br></code></pre></td></tr></table></figure><p><code>FileWriter</code>: 输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">FileWriter writer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&#x27;路径&#x27;</span>);<br><br>writer.append(<span class="hljs-string">&#x27;a&#x27;</span>)<br>    .append(<span class="hljs-string">&quot;adfad&quot;</span>); <span class="hljs-comment">// 允许链式写法</span><br><br><span class="hljs-comment">// 也有 flush()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">也可这样写入文件</span><br><span class="hljs-comment">writer.write(&quot;dad&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">同时也可以开启追加，开启方法和字节流，一样的方式</span><br></code></pre></td></tr></table></figure><blockquote><p>字符流只支持<code>char[]</code> 类型作为存储</p></blockquote><h2 id="3-文件对象"><a href="#3-文件对象" class="headerlink" title="3.文件对象"></a>3.文件对象</h2><p><code>File</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">File file=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&#x27;路径文件 / 文件夹名字&#x27;</span>);<br><br><span class="hljs-comment">// 创建文件夹，返回 boolean</span><br>file.mkdir()<br>file.mkdirs() <span class="hljs-comment">// 创建多级文件夹 比如  controller/index/map</span><br><span class="hljs-comment">// 创建文件</span><br>file.createNewFile(); <span class="hljs-comment">// 注意，创建的时候路径必须存在，否则会失败</span><br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">方法有很多，需要可以查找</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">可将 file 作为读取文件写入 FileReader 等方法中例如：</span><br><span class="hljs-comment">new FileReader(file)</span><br></code></pre></td></tr></table></figure><h2 id="4-缓冲流"><a href="#4-缓冲流" class="headerlink" title="4.缓冲流"></a>4.缓冲流</h2><p><code>BufferedInputStream</code>:</p><p><code>BufferedOutputStream</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> BufferedInputStream buff=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test_copy.txt&quot;</span>),index);<br><span class="hljs-comment">// 可以填参 index  意义为 缓冲区有几个字节</span><br></code></pre></td></tr></table></figure><blockquote><p> 认为：自来水 &#x3D;&#x3D;&#x3D;&gt; 自来水厂  &#x3D;&#x3D;&#x3D;&gt; 用户</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">可以倒回去读取数据，使用  buff.mark() 和 buff.reset(); 倒回到 mark 所在的位置</span><br><span class="hljs-comment">mark中可以填参数，参数（int） 为：从这里开始最多可以读取重新几个字 符</span><br><span class="hljs-comment">**/</span><br><br>.line() <span class="hljs-comment">// 可以读取一行</span><br>    <br>    <br> <span class="hljs-comment">/** </span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">   api 很多，比较方便吧</span><br></code></pre></td></tr></table></figure><h2 id="5-转换流"><a href="#5-转换流" class="headerlink" title="5.转换流"></a>5.转换流</h2><p><code>InputStreamReader</code> :  可以使用 <code>Reader</code>的方式读取</p><p><code>OutputStreamWriter</code>: 可以使用<code>writer</code> 的方式写入</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">OutputStreamWriter writer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test_copy.txt&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>InputStreamReader reader=<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(buff,<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="6-打印流"><a href="#6-打印流" class="headerlink" title="6.打印流"></a>6.打印流</h2><p><code>PrintStream</code>:</p><p>·Scanner·</p><p>用法和上述几种大同小异</p><p>所用的<code>sout</code>（简写）也是这种类型</p><h2 id="7-数据流"><a href="#7-数据流" class="headerlink" title="7.数据流"></a>7.数据流</h2><p><code>DataInputStream</code></p><p><code>DataOutputStream</code></p><h2 id="8-对象流"><a href="#8-对象流" class="headerlink" title="8.对象流"></a>8.对象流</h2><p><code>ObjectOutputStream</code></p><p>不仅支持基本数据类型，而且通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的 IO ，注意：他不是继承<code>FilterInputStream</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;person.text&quot;</span>));<br>             <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;person.text&quot;</span>)))&#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>);<br><br>            ois.writeObject(p1);<br>            ois.writeObject(p2);<br>            Object object ;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-keyword">while</span>((object = ois2.readObject())!= <span class="hljs-literal">null</span>) &#123;<br>                   System.out.println(object);<br>               &#125;<br>           &#125;<span class="hljs-keyword">catch</span> (EOFException e)&#123;<span class="hljs-comment">// 读取到文件末尾时抛出EOFException异常</span><br>               System.out.println(<span class="hljs-string">&quot;EOF&quot;</span>);<br>           &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 序列化版本号, 用于反序列化, 必须为static final long类型, 且唯一, 一般为类的全限定名的hash值,</span><br>        <span class="hljs-keyword">private</span> String name;<br>        Person(String name) &#123;<br>            <span class="hljs-built_in">this</span>.name =name;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2.多线程"></a>2.多线程</h1><p>进程含有多个线程</p><p>注意：是并发操作，不是并行</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;子线程&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>            &#125;<br>        &#125;);<br>        t.start();<br>        System.out.println(<span class="hljs-string">&quot;主线程&quot;</span>);<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">输出结果可能为：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">主线程</span><br><span class="hljs-comment">子线程</span><br><span class="hljs-comment">Hello World</span><br></code></pre></td></tr></table></figure><p>也可使用 <strong>lambda</strong> 表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         System.out.println(<span class="hljs-string">&quot;子线程&quot;</span>);<br>         System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>     &#125;,<span class="hljs-string">&quot;线程名字&quot;</span>);<br>       t.start();<br>       System.out.println(<span class="hljs-string">&quot;主线程&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\QD\AppData\Roaming\Typora\typora-user-images\image-20240824004411370.png" alt="image-20240824004411370"></p><h2 id="1-线程休眠和中断、优先级"><a href="#1-线程休眠和中断、优先级" class="headerlink" title="1.线程休眠和中断、优先级"></a>1.线程休眠和中断、优先级</h2><p><code>Thread.interrupt();</code> : 使线程中断</p><p><code>Thread.interrupted();</code> ：使线程中断回复原来的状态（即：不中断）</p><p><code>.yield()</code> :线程的让位，尽可能执行其他的</p><p><code>.join()</code>: 线程的加入，先执其行他的</p><hr><p>当 <code>i==3</code> 之后，尽可能执行 <strong>t1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程 t 启动&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程t &quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span>)<br>            Thread.<span class="hljs-keyword">yield</span>();<br>        &#125;<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程 t1 启动&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程t1 &quot;</span>+i);<br>        &#125;<br>    &#125;);<br><br>    t.start();<br>    t1.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>同时开始，但是当 <strong>t1</strong> 中 <code>i == 5</code> 的时候，只执行 <strong>t</strong> ，<strong>t</strong> 结束后才执行 <strong>t1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程 t 启动&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程t &quot;</span>+i);<br><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程 t 结束&quot;</span>);<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程 t1 启动&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程t1 &quot;</span>+i);<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) &#123;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程 t1 等待 t 结束&quot;</span>);<br>                    t.join();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;&#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程 t1 结束&quot;</span>);<br>    &#125;);<br><br>    t.start();<br>    t1.start();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-线程锁和线程同步"><a href="#2-线程锁和线程同步" class="headerlink" title="2.线程锁和线程同步"></a>2.线程锁和线程同步</h2><p>有下面这个例子引出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            p++;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            p++;<br>        &#125;<br>    &#125;);<br>    t.start();<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(p);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输出本该是 10000+10000=20000</span><br><span class="hljs-comment">   但是由于线程的同步进行则可能会导致线程 t ，t1 在执行 ++ 操作的时候，是同时进行的，那么此时就会导致本该加两次的 p </span><br><span class="hljs-comment">只加了一次</span><br></code></pre></td></tr></table></figure><blockquote><p>高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会<strong>发生冲突</strong>，这就是引入高速缓存引发的新问题，称之为：<strong>缓存一致性</strong>。</p></blockquote><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><blockquote><p>该关键字，可以通过给变量，或者方法加锁，使得不能同时操作同一个方法或者变量</p></blockquote><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>    p++;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                p++;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                p++;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t.start();<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">100</span>);<br>    System.out.println(p);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">那么，对 i 进行加锁操作后，就不会出现两个线程同时操作 i </span><br><span class="hljs-comment">同时的  对于 add() 方法加锁后，也是一样的，不会同时被两个线程调用</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">对于   synchronized () 中的形参，他是一个 Object 类型，可以 new 一个空的 Object放进去，也可以使用本类写入</span><br><span class="hljs-comment"> （例如类名为Main，则上述两个位置的形参可以写为 Main.class ）</span><br><span class="hljs-comment">注意: 如果说，两个线程中的形参不是同一个 Object ，那么同样会导致可能出现同时操作 i 的情况，</span><br><span class="hljs-comment">  对于成员方法来讲，默认是本类的 Object， 如果说在 new 一个本类的对象的话，会导致同时操作该方法</span><br></code></pre></td></tr></table></figure><h2 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h2><blockquote><p>两个线程互相卡锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">死锁的检查</span><br><span class="hljs-comment">*/</span><br><br>jps  <span class="hljs-comment">// 查看要检查的程序的线程</span><br>jstack processID  <span class="hljs-comment">// 检查id为 processID 的进程的死锁情况</span><br>    <br>    <br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">死锁的检查可视化</span><br><span class="hljs-comment">*/</span><br>   <br> jconsloe<br>    <br></code></pre></td></tr></table></figure><p><code>.wait()</code>： 使当前进程进入等待，同时释放当前的锁，可以让其他进程获取</p><blockquote><p>可输入一个形参变量，用于设置最大等待时间 单位 ms</p></blockquote><p><code>.notify()</code> :  唤醒刚才等待的进程（此时并没有立即释放锁），等待当前进程结束，才会执行刚才等待的进程</p><p><code>.notifyAll()</code> : 释放所有等待的进程，上面的为随机选取一个释放  </p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>    p++;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            System.out.println(<span class="hljs-string">&quot;进程1开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.wait();<br>                System.out.println(<span class="hljs-string">&quot;进程1结束&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            lock.notify();<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;进程2开始&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">5000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;进程2结束&quot;</span>);<br><br>        &#125;<br>    &#125;);<br><br>    t.start();<br>    t1.start();<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">虽然线程是并发的，但是根据线程的创建先后，先创建的线程开始的肯定早一点  ！！！！！！！！！！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">进程1开始</span><br><span class="hljs-comment">进程2开始</span><br><span class="hljs-comment">进程2结束</span><br><span class="hljs-comment">进程1结束</span><br></code></pre></td></tr></table></figure><h2 id="4-定时任务"><a href="#4-定时任务" class="headerlink" title="4.定时任务"></a>4.定时任务</h2><p><code>Timer</code> </p><h2 id="5-守护进程"><a href="#5-守护进程" class="headerlink" title="5. 守护进程"></a>5. 守护进程</h2><blockquote><p>在主进程结束的时候，子线程也结束。</p><p>如果不使用的话，当主进程结束后，子进程没有结束的条件下，该进程仍然在执行</p><p><strong>守护进程必须在进程开始之前！！！！！</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">//            设置子进程为死循环</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;我是守护线程&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 防止测试的时候，输出过多</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t.setDaemon(<span class="hljs-literal">true</span>);   <span class="hljs-comment">// 设置为守护线程</span><br>    Thread.sleep(<span class="hljs-number">3000</span>);<br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-生产者和消费者"><a href="#6-生产者和消费者" class="headerlink" title="6.生产者和消费者"></a>6.生产者和消费者</h2><blockquote><p>大概就是使用线程来进行操作，设置一个死循环用于不断地执行。</p><p>不妨令A、B分别为生产者和消费者</p><p>则A、B分别开启一个线程，并不断执行，当A生产出东西的时候，B才可以调用,其他时间一直等待，具体的可以参考下面的例子（<strong>仅供参考，考虑可能真的不够周全！！！</strong>）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Queue&lt;Object&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Main::add,<span class="hljs-string">&quot;add-thread-1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Main::add,<span class="hljs-string">&quot;add-thread-2&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Main::take,<span class="hljs-string">&quot;take-thread-1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Main::take,<span class="hljs-string">&quot;take-thread-2&quot;</span>).start();<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">synchronized</span> (queue)&#123;<br>                    String name=Thread.currentThread().getName();<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString()+<span class="hljs-string">&quot; &quot;</span>+name+<span class="hljs-string">&quot; add &quot;</span>);<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>                    queue.notifyAll();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">take</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">synchronized</span> (queue)&#123;<br>                  <span class="hljs-keyword">while</span>(queue.isEmpty()) queue.wait();<br>                  String name=Thread.currentThread().getName();<br>                  Object obj=queue.poll();<br>                  System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString()+<span class="hljs-string">&quot; &quot;</span>+name+<span class="hljs-string">&quot; take &quot;</span>+obj);<br>              &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaweb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vite中自动生成路由</title>
    <link href="/2024/11/26/vue/vite%E4%B8%AD%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E8%B7%AF%E7%94%B1/"/>
    <url>/2024/11/26/vue/vite%E4%B8%AD%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="根据目录自动生成路由"><a href="#根据目录自动生成路由" class="headerlink" title="根据目录自动生成路由"></a>根据目录自动生成路由</h2><p><strong>关键字</strong>：<code>import.meta.glob</code></p><blockquote><p>常用的路由配置方式已经满足使用，但是为了追求更好的路由配置方式，减少繁琐的配置方式，可以将路由和文件夹关联起来</p></blockquote><ol><li>使用此方法可以让路由随着文件夹的创建而创建（根据微信小程序开发的思想，注意，每个文件夹下必须有一个<code>.vue</code>和<code>.js</code> 文件，而且名字必须一致，生成的路由就是改名字的路由）</li><li>例如：在<code>views</code>下（因为以下的代码是由<code>views</code>目录下的文件产生的路由），</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">- views<br>    - index<br>    - index.<span class="hljs-property">vue</span><br>    - index.<span class="hljs-property">js</span><br>    - second<br>    - second.<span class="hljs-property">vue</span><br>    - second.<span class="hljs-property">js</span><br><span class="hljs-comment">// 以上产生的路由有 &#x27;/index&#x27;  &#x27;/second&#x27; 这两个路由</span><br><span class="hljs-comment">// 当然也可以产生子路由</span><br>- views<br>    - index<br>    - index.<span class="hljs-property">vue</span><br>    - index.<span class="hljs-property">js</span><br>    - son<br>    - son.<span class="hljs-property">vue</span><br>    - son.<span class="hljs-property">js</span><br>    - second<br>    - second.<span class="hljs-property">vue</span><br>    - second.<span class="hljs-property">js</span><br><span class="hljs-comment">// 以上产生的路由有 &#x27;/index&#x27; &#x27;/index/son&#x27; &#x27;/second&#x27; 这三个路由  </span><br> <br><span class="hljs-comment">// 如果有更多的子路由，可以无限的嵌套文件夹</span><br><br>    <br> <span class="hljs-comment">// 当然我们希望有时候，在切换路由的时候，该路由可以携带一些参数，.js文件就是用来写携带的参数，可以使用一下模版</span><br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">meta</span>: &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;通知&#x27;</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// 一般情况下，title 参数用于给不同的路由设置不同的标题，其他的参数可根据自己需求而定，</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pages = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;../views/**/*.js&#x27;</span>, &#123;<br>  <span class="hljs-attr">eager</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">import</span>:<span class="hljs-string">&#x27;default&#x27;</span><br>&#125;);<br><br><span class="hljs-keyword">const</span> components = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;../views/**/*.vue&#x27;</span>);<br><span class="hljs-comment">// 上一行的配置是由于在生产环境中文件夹的路径变化，要映射</span><br><br><span class="hljs-keyword">const</span> routes = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(pages).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[path, mate]</span>) =&gt;</span> &#123; <br>  <span class="hljs-keyword">const</span> pathRealy = path.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;../views&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\/[^/]*\.js$/</span>, <span class="hljs-string">&#x27;&#x27;</span>) || <span class="hljs-string">&#x27;/&#x27;</span>;<br>  <span class="hljs-keyword">const</span> nameRealy = path.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>).<span class="hljs-title function_">pop</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> componentRealy = components[path.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.vue&#x27;</span>)];<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">path</span>: pathRealy,<br>    <span class="hljs-attr">name</span>: nameRealy,<br>    <span class="hljs-attr">component</span>: componentRealy,<br>    <span class="hljs-attr">meta</span>: mate.<span class="hljs-property">meta</span><br>  &#125;<br>&#125;);<br><span class="hljs-comment">// console.log(routes);</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">BASE_URL</span>),<br>  <span class="hljs-attr">routes</span>: routes<br>&#125;)<br><span class="hljs-comment">// 一下是用来从跟路由跳转第一个路由（因为没有设置跟路由），同时修改页面的标题（也就是 .js 文件中，title 变量）</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br><br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/&#x27;</span>) &#123; <span class="hljs-comment">// 因为没有 / 路由的存在 </span><br>    <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/first&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span>) &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;默认标题&#x27;</span>;<br>    &#125;<br>  &#125;);<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>看了上面这多代码，的确比较难懂，其实在自己调试的手可以打印出来，看看每一步处理的什么东西</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue总结</title>
    <link href="/2024/11/26/vue/vue/"/>
    <url>/2024/11/26/vue/vue/</url>
    
    <content type="html"><![CDATA[<h1 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">-build    ------------&gt; 使用webpack打包使用的build依赖<br>-config<br>-node_modules --------&gt; 项目依赖<br>- src  ---------------&gt; 源码<br>+assets  ---------&gt; 静态资源<br>-components   ----&gt; vue组件<br>-router  ---------&gt; 项目路由<br>-App.vue  --------&gt; 根组件<br>-main.js  --------&gt; 项目主入口<br>-static  -------------&gt; 其他静态资源<br>-.babelrc  -----------&gt; 就爱那个es6转es5运行<br>-.editorconfig  ------&gt; 项目编译配置<br>-.gitignore  ---------&gt; git版本控制忽略文件<br>-package.json --------&gt; 类似于 pom.xml<br>-package-lock.json  --&gt; 对package.json加锁<br>-index.html  ---------&gt; 项目主页<br></code></pre></td></tr></table></figure><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>管理员<code>cmd</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">vue create test_vue<br></code></pre></td></tr></table></figure><p><code>vue3.x</code> 项目直接确定即可，</p><p><code>vue2.x</code> 需要选择所使用的工具然后创建</p><h1 id="1、组件"><a href="#1、组件" class="headerlink" title="1、组件"></a>1、组件</h1><blockquote><p>通信是由单个组件发出的</p><p>在由一个路由的子路由发送请求后，将会跳转到父路由，在此过程中，父路由不会重新请求数据，那么，就需要监听一下由子路由跳转到父路由的方法：用于重新发送请求更新数据</p></blockquote><p>切换路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">/// 跳转到子路由</span><br></code></pre></td></tr></table></figure><p>父路由监听子路由跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 和methods同级</span><br><span class="hljs-attr">watch</span>:&#123;<br>    <span class="hljs-attr">$route</span>:&#123;<br>      <span class="hljs-title function_">handler</span>(<span class="hljs-params">val,oldval</span>)&#123;<br>          <br>          <span class="hljs-comment">// 在这里处理相关操作</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<span class="hljs-comment">//新路由信息</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oldval);<span class="hljs-comment">//老路由信息</span><br>      &#125;,<br>      <span class="hljs-comment">// 深度观察监听</span><br>      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="2、基础知识"><a href="#2、基础知识" class="headerlink" title="2、基础知识"></a>2、基础知识</h1><ol><li><ul><li><p><code>v-bind:value=&#39;name&#39;</code>简写：<code>:value=&#39;name&#39;</code>  </p></li><li><p><code>v-model:value=&#39;name&#39;</code> 简写: <code>v-model=&#39;name&#39;</code>  只用于文本框类的数据绑定</p></li><li><p><code>v-on:click=&#39;函数名&#39;</code> 简写 <code>@click=&#39;函数名&#39;</code> 当点击的时候触发，<strong>绑定一个事件</strong>，是否传参，取决于函数是否通过小括号传参</p><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- vue 中的事件修饰符 --&gt;</span><br><span class="hljs-comment">&lt;!-- 阻止默认事件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 阻止事件冒泡--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 只能触发一次，在一次加载后，只能点击一次--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用事件的捕获模式，也就是说，在进行事件捕获的时候触发，冒泡的时候不触发--&gt;</span><br><span class="hljs-comment">&lt;!-- 一下三个都不常用！！！ --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> @<span class="hljs-attr">click.capture</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 只有 even.target 是当前操作的元素才触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> @<span class="hljs-attr">click.self</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 事件的默认行为立即执行，无需等待事件回调完毕 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> @<span class="hljs-attr">click.passive</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote></li></ul></li><li><ul><li>关于<code>vue</code> 中的 <code>data</code> ，在不是组件开发的时候，<code>data</code> 写成对象式、函数式都可以；组件开发的时候，<strong>必须使用函数式</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;app&#x27;</span>,  <span class="hljs-comment">// el 挂载或者 使用 .$mount(&#x27;app&#x27;)  挂载到 vue 实例上面</span><br>    <span class="hljs-comment">// 对象式</span><br>    <span class="hljs-attr">data</span>:&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;wang&#x27;</span><br>    &#125;<br>    <span class="hljs-comment">/* // 函数式</span><br><span class="hljs-comment">    data:function()&#123;</span><br><span class="hljs-comment">    return&#123;</span><br><span class="hljs-comment">    name:&#x27;wang&#x27;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    // 或者写成：</span><br><span class="hljs-comment">    data()&#123;</span><br><span class="hljs-comment">    return&#123;</span><br><span class="hljs-comment">    name:&#x27;wang&#x27;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    */</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><ul><li><p><code>MVVM模型</code> ：</p><blockquote><p> M :  model 指的是<code>data</code>中的数据</p><p> V : view  指的是 DOM</p><p> VM :  viewModel 指的是 vue 实例对象</p><p> <strong>注意：v 中的插值法，可以绑定vm中的所有属性</strong></p></blockquote></li></ul></li><li><ul><li>计算属性<code>computed:&#123; &#125;</code>  <strong>当监听和计算属性都可以实现，有限计算属性</strong><blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    ...<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <br>&#125;,<br>     <span class="hljs-attr">computed</span>:&#123; <span class="hljs-comment">// 在使用比较复杂的属性运算的时候，由于差值语法写的过于复杂，故可用该属性进行计算</span><br>     <span class="hljs-attr">name</span>:&#123;<br>        <span class="hljs-comment">// get 属性在读取 name 的时候，会被调用，并且有返回值，作为 name 的值</span><br><span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 计算值</span><br>&#125;，<br>            <span class="hljs-title function_">set</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 计算值</span><br>&#125;<br>        &#125;   <br>     &#125;<br>&#125;)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// 当 name 只获取而不修改的时候，可以简写：</span><br><span class="hljs-comment">name()&#123;</span><br><span class="hljs-comment">    // 计算值</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></blockquote></li></ul></li><li><ul><li><p>监视  <code>watch</code></p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>...<br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zs&#x27;</span><br>&#125;,<br><span class="hljs-attr">computed</span>:&#123; <span class="hljs-comment">// 在使用比较复杂的属性运算的时候，由于差值语法写的过于复杂，故可用该属性进行计算</span><br>&#125;,<br> <span class="hljs-attr">watch</span>:&#123;<br>     <span class="hljs-comment">// 监听data中的数据name，也可监听计算属性</span><br>     <span class="hljs-comment">// 最原始的写法 name 要加 单引号！！！！ 下面的是简写</span><br>     <span class="hljs-attr">name</span>:&#123;<br>         <span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">// 初始化的时候让 handler 调用一下</span><br>         <span class="hljs-title function_">handler</span>(<span class="hljs-params">newValue,oldValue</span>)&#123; <span class="hljs-comment">// 当name的值改变的时候，会调用该函数</span><br>             <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name 被修改了：&#x27;</span> ,newValue,oldValue);<br>         &#125;<br>     &#125;<br> &#125;<br>&#125;);<br><br><span class="hljs-comment">//或者监听写为：</span><br><span class="hljs-comment">// 注意监听的变量要使用 引号引起来</span><br>vm.$watch(<span class="hljs-string">&#x27;name&#x27;</span>,&#123;<br> <span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">// 初始化的时候让 handler 调用一下</span><br> <span class="hljs-title function_">handler</span>(<span class="hljs-params">newValue,oldValue</span>)&#123; <span class="hljs-comment">// 当name的值改变的时候，会调用该函数</span><br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name 被修改了：&#x27;</span> ,newValue,oldValue);<br> &#125;<br>&#125;);<br><span class="hljs-comment">// ==================================================================================================</span><br><span class="hljs-comment">// ==================================================================================================</span><br><span class="hljs-comment">//简写：当只考虑handler，其他的都不考虑，为默认的时候可以写为</span><br><span class="hljs-attr">watch</span>:&#123;<br>    <span class="hljs-title function_">name</span>(<span class="hljs-params">newValue,oldValue</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name 被修改了：&#x27;</span> ,newValue,oldValue);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><font color='skyblue'>深度监视</font> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>...<br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zs&#x27;</span>,<br> <span class="hljs-attr">student</span>:&#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;ls&#x27;</span>,<br> <span class="hljs-attr">socre</span>:<span class="hljs-number">90</span><br>&#125;<br>&#125;,<br><span class="hljs-attr">computed</span>:&#123; <span class="hljs-comment">// 在使用比较复杂的属性运算的时候，由于差值语法写的过于复杂，故可用该属性进行计算</span><br>&#125;,<br> <span class="hljs-attr">watch</span>:&#123;<br>     <span class="hljs-comment">// 监听data中的数据name，也可监听计算属性</span><br>     <span class="hljs-comment">// 最原始的写法 name 要加 单引号！！！！ 下面的是简写</span><br>     <span class="hljs-attr">name</span>:&#123;<br>         <span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">// 初始化的时候让 handler 调用一下</span><br>         <span class="hljs-title function_">handler</span>(<span class="hljs-params">newValue,oldValue</span>)&#123; <span class="hljs-comment">// 当name的值改变的时候，会调用该函数</span><br>             <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name 被修改了：&#x27;</span> ,newValue,oldValue);<br>         &#125;<br>     &#125;,<br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">     当监听对象的是一个对象的时候，直接写监听student里面的name和socre，比如：</span><br><span class="hljs-comment">     name:&#123;&#125;,</span><br><span class="hljs-comment">     socre:&#123; &#125;,</span><br><span class="hljs-comment">     这样是不行的，vue检测不到该属性，因为他不属于vue中的属性</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     可以写为：</span><br><span class="hljs-comment">     &#x27;student.name&#x27;:&#123; &#125;</span><br><span class="hljs-comment">     但是如果里面的属性值很多的时候，这样子远无法满足需求，那么就需要开启深度监听比如：</span><br><span class="hljs-comment">     student:&#123;</span><br><span class="hljs-comment">     deep:true,  // 因为该属性默认关闭 </span><br><span class="hljs-comment">     handler()&#123;</span><br><span class="hljs-comment">     console.log(&#x27;改变了&#x27;);</span><br><span class="hljs-comment">     &#125;</span><br><span class="hljs-comment">     &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     这样子，当student中的某一个属性改变的时候，都会监听到变化</span><br><span class="hljs-comment">     */</span><br> &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></blockquote></li></ul></li><li><ul><li><p>动态样式绑定<code>:class=&#39;&#39;</code> </p><blockquote><p>适用于样式的类名不确定，需要动态改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">   &gt;&lt;input  class=&#x27;&#x27; :class=&#x27;changeStyle&#x27; @click=&#x27;change&#x27;&gt;<br><br>   &gt;&lt;script&gt;<br> new Vue(&#123;<br>     ...<br>     <br>     data:&#123;<br>     changeStyle:&#x27;normal&#x27;    <br>     &#125;,<br>     methods:&#123;<br>change()&#123;<br>             const arr=[&#x27;happy&#x27;,&#x27;sad&#x27;]; // 里面为写好的样式名字<br>           index=1;// 可以根据逻辑进行计算第几个样式，或者其他操作进行样式改变<br>             this.changeStyle=arr[index];<br>         &#125;<br>     &#125;<br> &#125;)<br><br>   &gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>也可以给<code>stye</code> 进行绑定<code>:style=&#39;object&#39;</code>，这样子也可以在<code>vue</code>中进行操作对象<strong>object</strong> </p></blockquote></li></ul></li><li><ul><li><p>列表筛选 </p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--<br>filter()<br>--&gt;<br><br>&lt;script&gt;<br>new Vue(&#123;<br>   ...<br><br>   data:&#123;<br>        person:[<br>            &#123;id:&#x27;1&#x27;,name:&#x27;zs&#x27;&#125;<br>        ]<br>       ,filePerson:[]<br>       <br>   &#125;,<br>   methods:&#123;   &#125;,<br>    watch:&#123;<br>        filePerson:&#123;<br>            immediate:true, // 开启首次加载执行，此时筛选的是字符串内是否有空，因为每个字符串都包含空，故可以等同于在data中  filePerson = person<br>            handler(val)&#123;<br>                this.filePerson = this.filePerson.filter((p)=&gt;&#123;<br>                    return p.name.indexOf(&#x27;val&#x27;) !== -1; // 因为 -1 表示 val 不在该字符串内<br>                &#125;)<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;)<br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></blockquote></li></ul></li><li><ul><li><p>数据更新问题：</p><blockquote><p>有时候跟新的数据vue并没有检测到，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><br>    &gt;<span class="hljs-keyword">const</span> vm=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">list</span>: [<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;首页&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">12</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;问题&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">13</span> &#125;<br>    ]<br>  &#125;<br>&#125;,<br><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-title function_">changeMessage</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-comment">// this.list[0].age = 15;  </span><br>    <span class="hljs-comment">// this.list[1].name =&#x27;zd&#x27;;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]=&#123;<span class="hljs-attr">id</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zd&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">15</span>&#125;<br>  &#125;<br>&#125;<br>    &gt;&#125;)<br><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;这样子更新的数据，虽然<code>vm</code>中的数据<strong>会真的被改变</strong>，但是<code>vue</code>并没有检测到，也就是说，当<code>changeMessage</code>方法被调用后，<code>vm</code>中的<code>list</code>被更新了，页面却没有被渲染（当打开开发者工具的时候，也会出现不同，有点小复杂，不说了）。</p><p>&emsp;&emsp; 但是，被注释掉的可以更新，也就是渲染也没有问题。</p><p><code>vue</code> 监听改变的原理是由<code>get()  , set() </code> 方法的调用实现的，而<code>get()  , set() </code>方法只有单个的属性才有。</p></blockquote></li></ul></li><li><ul><li><p>数据监测</p><blockquote><p>监测对象： <code>Vue.set(b,new,ans)</code> b 为要绑定的属性， new 给绑定的属性添加的变量，ans 变量的值</p></blockquote></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序学习笔记（6）</title>
    <link href="/2024/04/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/"/>
    <url>/2024/04/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1、-movable-view"><a href="#1、-movable-view" class="headerlink" title="1、&lt; movable-view&gt;"></a>1、&lt; movable-view&gt;</h1><blockquote><p>该组件可以在页面中拖拽滑动，不能单独使用，必须放在 &lt; movable-area &gt; 中</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">movable-area 属性：<br>scale-area: <span class="hljs-comment">/* 当 movable-view 支持双指缩放的时候，设置此值可将放缩手势生效为整个 movable-area 区域</span><br><span class="hljs-comment">movable-area 可自定义 宽高 ，默认为10px</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">movable-view：<br><span class="hljs-attribute">direction</span>： <span class="hljs-attribute">all</span> | vertical | <span class="hljs-attribute">none</span> | horizeontal <span class="hljs-comment">/* 移动的方向 */</span><br>scale：是否支持双指缩放<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">movable-area</span> <span class="hljs-attr">scale-area</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">movable-view</span> <span class="hljs-attr">direction</span>=<span class="hljs-string">&quot;all&quot;</span> <span class="hljs-attr">scale</span> <span class="hljs-attr">inertia</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">movable-view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">movable-area</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2、cover-view"><a href="#2、cover-view" class="headerlink" title="2、cover-view"></a>2、cover-view</h1><blockquote><p>可覆盖在原生组件上的视图容器，包括 map 、 video 、canvas 等，</p><p>内部只允许嵌套 cover-view 、 cover-image 、button</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">cover-view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">cover-view</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">cover-view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>tijioa<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">cover-view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="3、icon"><a href="#3、icon" class="headerlink" title="3、icon"></a>3、icon</h1><blockquote><p>图标组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;&quot;</span>  <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;warn&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;success&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;success_no_circle&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;info&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;cancel&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;search&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;clean&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;waiting&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;download&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>对应图标：<img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/100.png"></p><h1 id="4、text"><a href="#4、text" class="headerlink" title="4、text"></a>4、text</h1><blockquote><p>文本组件，除了文本节点以外的其他节点都无法长按选中</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">ensp 中文空格大小的一半<br>emsp 中文空格<br>nbsp 根据字体设置空格大小<br></code></pre></td></tr></table></figure><p>text 组件中只支持 text 嵌套</p><p>可设置属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">user-select</span> <span class="hljs-attr">space</span> <span class="hljs-attr">decode</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span> <br><span class="hljs-comment">&lt;!-- 文本可选 显示连续空格 是否解码（空格解析） --&gt;</span><br></code></pre></td></tr></table></figure><h1 id="5、rich-text"><a href="#5、rich-text" class="headerlink" title="5、rich-text"></a>5、rich-text</h1><blockquote><p>富文本组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">rich-text</span> <span class="hljs-attr">nodes</span>=<span class="hljs-string">&quot;&#123;&#123;node01&#125;&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rich-text</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Page</span>(&#123;<br>    <span class="hljs-attr">data</span>:&#123;<br>        <span class="hljs-attr">node01</span>:[&#123;<br>            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;div&#x27;</span>,<br>            <span class="hljs-attr">attrs</span>:&#123;<br>                <span class="hljs-attr">style</span>:<span class="hljs-string">&#x27;</span><br><span class="hljs-string">                color:red;</span><br><span class="hljs-string">                line-height:60px;</span><br><span class="hljs-string">                &#x27;</span><br>            &#125;,<br>            <span class="hljs-attr">children</span>:[&#123;<br>                <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;text&#x27;</span>,<br>                <span class="hljs-attr">text</span>:<span class="hljs-string">&#x27;hello word&#x27;</span><br>            &#125;]<br>        &#125;]<br>    &#125;<br>&#125;)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">attrs 中也可以写为 class ：&#x27;mystyle&#x27;，指的是本页面中的名为 mystyle 的 css 属性</span><br><span class="hljs-comment">node01 也可写为 html 标签的形式，注意用引号引起来</span><br></code></pre></td></tr></table></figure><blockquote><p>其中，name 指的是标签名字（支持受信任的HTML节点）</p><p>attrs 属性，支持受信任的属性，遵循 Pascal 命名法</p><p>children 子节点列表，结构和 nodes 一致</p></blockquote><h1 id="6、progress"><a href="#6、progress" class="headerlink" title="6、progress"></a>6、progress</h1><blockquote><p>进度条</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">progress</span> <span class="hljs-attr">percent</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">active</span>/&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">percent 0~100 百分比</span><br><span class="hljs-comment">show-info false 在进度条右侧显示百分比</span><br><span class="hljs-comment">storke-width 进度条宽度</span><br><span class="hljs-comment">activeColor 已选择的进度条颜色</span><br><span class="hljs-comment">backgroundColor 未选择的进度条颜色</span><br><span class="hljs-comment">active false 从左往右的动画</span><br><span class="hljs-comment">active-mode backwards|forwards 从头播放|从上次结束的位置播放</span><br></code></pre></td></tr></table></figure><h1 id="7、lable"><a href="#7、lable" class="headerlink" title="7、lable"></a>7、lable</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">lable</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">checkbox</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-attr">checked</span>&gt;</span>admin<br><span class="hljs-tag">&lt;/<span class="hljs-name">lable</span>&gt;</span><br> <br> 和<br>  <span class="hljs-tag">&lt;<span class="hljs-name">checkbox</span> <span class="hljs-attr">valu</span>=<span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-attr">checked</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;app&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">lable</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&#x27;app&#x27;</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">lable</span>&gt;</span><br>    <br>  效果一样<br></code></pre></td></tr></table></figure><h1 id="8、form"><a href="#8、form" class="headerlink" title="8、form"></a>8、form</h1><blockquote><p>三个属性：</p><p>report-submit  boolean：是否返回 formId</p><p>bindsubmit 提交表单时触发 submit 事件，携带的值为 e.detail &#x3D; { value : { ‘ name ‘ : ‘ admin ‘ } ,  formId : ‘ ‘ }</p><p>bindreset 重置时触发的事件</p></blockquote><h1 id="9、picker"><a href="#9、picker" class="headerlink" title="9、picker"></a>9、picker</h1><blockquote><p>从底部弹起的滚动选择器组件，</p><p>目前有，普通选择器，多列选择器，时间选择器，日期选择器，省市区选择器，默认普通选择器</p></blockquote><h2 id="普通选择："><a href="#普通选择：" class="headerlink" title="普通选择："></a>普通选择：</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picker</span>  <span class="hljs-attr">range</span>=<span class="hljs-string">&quot;&#123;&#123;info&#125;&#125;&quot;</span> <span class="hljs-attr">bindchange</span>=<span class="hljs-string">&quot;select&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>选择的内容为:&#123;&#123;opa&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picker</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Page</span>(&#123;<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">info</span>: [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]<br>  &#125;,<br>  <span class="hljs-attr">select</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>    <span class="hljs-keyword">let</span> i = res.<span class="hljs-property">detail</span>.<span class="hljs-property">value</span>;<br>    <span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">info</span>[i];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123; <span class="hljs-attr">opa</span>: value &#125;);<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><hr><h2 id="多列选择："><a href="#多列选择：" class="headerlink" title="多列选择："></a>多列选择：</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picker</span>  <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;multiSelector&quot;</span> <span class="hljs-attr">range</span>=<span class="hljs-string">&quot;&#123;&#123;info&#125;&#125;&quot;</span> <span class="hljs-attr">bindchange</span>=<span class="hljs-string">&quot;select&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>选择了:&#123;&#123;opa&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picker</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">info</span>: [<br>      [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>],<br>      [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">select</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>    <span class="hljs-keyword">let</span> arrSelect = res.<span class="hljs-property">detail</span>.<span class="hljs-property">value</span>; <span class="hljs-comment">//获取选项数组的下标</span><br>    <span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">info</span>; <span class="hljs-comment">//获取原数组</span><br>    <span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(); <span class="hljs-comment">//新建一个空数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arrSelect.<span class="hljs-property">length</span>; j++) &#123;<br>      <span class="hljs-keyword">let</span> k = arrSelect[j]; <span class="hljs-comment">// 获取选择了第 j 个数组，第 arrSelect[j] 个位置的值（也就是第 j 个数组中的位置）</span><br>      <span class="hljs-keyword">let</span> v = value[j][k];<span class="hljs-comment">//在原数组中查找第 j 个数组 第 k 个位置的值</span><br>      arr.<span class="hljs-title function_">push</span>(v);<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>      <span class="hljs-attr">opa</span>: arr<br>    &#125;);<br>  &#125;,    <br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="时间选择"><a href="#时间选择" class="headerlink" title="时间选择"></a>时间选择</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picker</span>  <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;time&quot;</span>  <span class="hljs-attr">bindchange</span>=<span class="hljs-string">&quot;selectTimeHM&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>选择了:&#123;&#123;time&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picker</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Page</span>(&#123;<br>    <span class="hljs-attr">data</span>:&#123;<br>        <span class="hljs-attr">time</span>:<span class="hljs-string">&#x27;&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">selectTimeHM</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<span class="hljs-attr">time</span>:e.<span class="hljs-property">detail</span>.<span class="hljs-property">value</span>&#125;);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="日期选择"><a href="#日期选择" class="headerlink" title="日期选择"></a>日期选择</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picker</span>  <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;date&quot;</span>  <span class="hljs-attr">bindchange</span>=<span class="hljs-string">&quot;selectTimeHM&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>选择了:&#123;&#123;time&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picker</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Page</span>(&#123;<br>    <span class="hljs-attr">data</span>:&#123;<br>        <span class="hljs-attr">time</span>:<span class="hljs-string">&#x27;&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">selectTimeHM</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<span class="hljs-attr">time</span>:e.<span class="hljs-property">detail</span>.<span class="hljs-property">value</span>&#125;);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="省市区选择"><a href="#省市区选择" class="headerlink" title="省市区选择"></a>省市区选择</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picker</span>  <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;region&quot;</span>  <span class="hljs-attr">bindchange</span>=<span class="hljs-string">&quot;selectTimeHM&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>选择了:&#123;&#123;time&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picker</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Page</span>(&#123;<br>    <span class="hljs-attr">data</span>:&#123;<br>        <span class="hljs-attr">time</span>:<span class="hljs-string">&#x27;&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">selectTimeHM</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<span class="hljs-attr">time</span>:e.<span class="hljs-property">detail</span>.<span class="hljs-property">value</span>&#125;);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="10、picker-view"><a href="#10、picker-view" class="headerlink" title="10、picker-view"></a>10、picker-view</h1><blockquote><p>嵌入页面的滚动选择器</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;year&#125;&#125;年&#123;&#123;month&#125;&#125;月&#123;&#123;day&#125;&#125;日<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">picker-view</span> <span class="hljs-attr">indicator-style</span>=<span class="hljs-string">&quot;height: 50px;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100%; height: 300px;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#123;&#123;value&#125;&#125;&quot;</span> <span class="hljs-attr">bindchange</span>=<span class="hljs-string">&quot;bindChange&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">picker-view-column</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;&#123;&#123;years&#125;&#125;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;line-height: 50px&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;年<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">picker-view-column</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">picker-view-column</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;&#123;&#123;months&#125;&#125;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;line-height: 50px&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;月<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">picker-view-column</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">picker-view-column</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;&#123;&#123;days&#125;&#125;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;line-height: 50px&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;日<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">picker-view-column</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">picker-view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br><span class="hljs-keyword">const</span> years = []<br><span class="hljs-keyword">const</span> months = []<br><span class="hljs-keyword">const</span> days = []<br> <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1990</span>; i &lt;= date.<span class="hljs-title function_">getFullYear</span>(); i++) &#123;<br>  years.<span class="hljs-title function_">push</span>(i)<br>&#125;<br> <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">12</span>; i++) &#123;<br>  months.<span class="hljs-title function_">push</span>(i)<br>&#125;<br> <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">31</span>; i++) &#123;<br>  days.<span class="hljs-title function_">push</span>(i)<br>&#125;<br> <br><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">years</span>: years,<br>    <span class="hljs-attr">year</span>: date.<span class="hljs-title function_">getFullYear</span>(),<br>    <span class="hljs-attr">months</span>: months,<br>    <span class="hljs-attr">month</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">days</span>: days,<br>    <span class="hljs-attr">day</span>: <span class="hljs-number">9</span>,<br>    <span class="hljs-attr">value</span>: [<span class="hljs-number">9999</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>],<br>  &#125;,<br>  <span class="hljs-attr">bindChange</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">const</span> val = e.<span class="hljs-property">detail</span>.<span class="hljs-property">value</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>      <span class="hljs-attr">year</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">years</span>[val[<span class="hljs-number">0</span>]],<br>      <span class="hljs-attr">month</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">months</span>[val[<span class="hljs-number">1</span>]],<br>      <span class="hljs-attr">day</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">days</span>[val[<span class="hljs-number">2</span>]]<br>    &#125;)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/101.png"></p>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wxss</tag>
      
      <tag>wxml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序学习笔记（5）</title>
    <link href="/2024/04/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/"/>
    <url>/2024/04/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1、-template-template"><a href="#1、-template-template" class="headerlink" title="1、&lt; template &gt;&lt; &#x2F; template &gt;"></a>1、&lt; template &gt;&lt; &#x2F; template &gt;</h1><p>模板可以重复调用</p><p>首先要定义一个模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;password&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 这里定义了一个模板名字为 test 的模板 ，里面包含了两个 view 组件--&gt;</span><br></code></pre></td></tr></table></figure><p>然后才能应用该模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">is</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;&#123;&#123;username:&#x27;admin&#x27;,password:&#x27;123&#x27;&#125;&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用 is 引用所要使用的模板名字，同时，使用 data 更新模板中的变量的值 --&gt;</span><br><span class="hljs-comment">&lt;!-- 另外，也可以在 Page() 中定义 data 的其中一个变量值，以一个结构体的值为例子：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Page(&#123;</span><br><span class="hljs-comment">    data: &#123;</span><br><span class="hljs-comment">        stu:&#123;</span><br><span class="hljs-comment">            username:&#x27;admin&#x27;,</span><br><span class="hljs-comment">            password:&#x27;123&#x27;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">然后，在引用该模板的时候可以使用</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&lt;template is=&quot;test&quot; data=&quot;&#123;&#123;...stu&#125;&#125;&quot;&gt;</span><br><span class="hljs-comment">&lt;/template&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">来给变量赋值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">其中 “...stu” 表示将 名字为 stu 的变量展开引用</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2、样式导入"><a href="#2、样式导入" class="headerlink" title="2、样式导入"></a>2、样式导入</h1><h2 id="i、wxml"><a href="#i、wxml" class="headerlink" title="i、wxml"></a>i、wxml</h2><blockquote><p>提供了 import 和 include 两种引用方式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;相对路径&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;相对路径&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>import 有作用域的概念，比如，在一个 wxml（记为 A） 文件中引用了另一个 wxml（记为B），同时，在 B 中引用了其他的 wxml （记为C）文件，那么，在 A 中，只能引用 B 中的 内容，而不会引用 C 中，使用 import 导入的内容</p><p>避免了多个页面相互引用，陷入逻辑错误</p></blockquote><blockquote><p>include 只会引入<code> 除了</code> <code>template  style script </code>及其内容，相当于吧代码 copy 过来</p></blockquote><blockquote><ul><li><code>&lt;import&gt;</code>：适用于导入通用的模板、组件等，提高代码的复用性和可维护性。</li><li><code>&lt;include&gt;</code>：适用于将某个文件中的特定部分插入到当前页面中，通常用于模块化开发。</li></ul></blockquote><h2 id="ii、wxss"><a href="#ii、wxss" class="headerlink" title="ii、wxss"></a>ii、wxss</h2><p>尺寸单位：<code>rpx</code>根据指定的屏幕自适应</p><p>样式导入：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;相对路径&quot;</span>;<br></code></pre></td></tr></table></figure><h1 id="3、flex布局"><a href="#3、flex布局" class="headerlink" title="3、flex布局"></a>3、flex布局</h1><blockquote><p>在flex布局中，用于包含内容的组件成为容器，容器内部的组件成为项目，容器允许包含嵌套</p></blockquote><blockquote><p>坐标轴是以容器的左上角为原点，自左向右，自上向下</p><p>也可以通过<code>flex-direction:column</code>将主轴改变为：自上向下，自左向右</p></blockquote><h2 id="i、容器属性"><a href="#i、容器属性" class="headerlink" title="i、容器属性"></a>i、容器属性</h2><p><code>flex-direction</code>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: <span class="hljs-built_in">row</span>(默认) | row-reverse | column | column-reverse<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">row 坐标轴是以容器的左上角为原点，自左向右，自上向下</span><br><span class="hljs-comment">row-reverse  坐标轴是以容器的左上角为原点，自右向左，自上向下</span><br><span class="hljs-comment">column 自上向下，自左向右</span><br><span class="hljs-comment">column-reverse 自下向上，自左向右</span><br></code></pre></td></tr></table></figure><p><code>flex-wrap</code>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-wrap</span>: <span class="hljs-built_in">nowrap</span>(默认) | wrap | wrap-reverse<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">nowrap 不换行，如果单行内容过多，项目宽度会被压缩</span><br><span class="hljs-comment">wrap 当容器单行容不下所有项目时，允许换行</span><br><span class="hljs-comment">wrap-reverse 与 wrap 相同，只不过，换行方向为 wrap 的反方向</span><br></code></pre></td></tr></table></figure><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/100.png"></p><p><code>justify-content</code>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around | space-evenly ;<br></code></pre></td></tr></table></figure><blockquote><ul><li>flex-start（默认值）：左对齐，没有空隙</li><li>flex-end：右对齐，没有空隙</li><li>center： 居中，没有空隙</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：项目之间的间隔比 开始和末尾 与边框的间隔大一倍，开始 和末尾与边框相同</li><li>space-evenly: 开始和末尾，与项目之间的间隔相同</li></ul></blockquote><p>还有 <code>align-items</code>（项目在行中的对齐方式）</p><p><code>align-content</code>（项目在非主轴的对齐方式）</p><h2 id="ii、项目属性"><a href="#ii、项目属性" class="headerlink" title="ii、项目属性"></a>ii、项目属性</h2><p><code>order</code>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span>&#123;<br>    <span class="hljs-attribute">order</span>: <span class="hljs-number">0</span>（默认）;<span class="hljs-comment">/* 一个整数，表示排列的位置，数值越小越靠前  */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code> flex-shrink</code>:（收缩因子）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span>&#123;<br>    <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>（默认）;<span class="hljs-comment">/* 一个非负数 ，也称为 收缩因子*/</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小</p><p>计算公式：最终长度&#x3D; 原长 x （1 - 溢出长度 x 收缩因子 &#x2F; 压缩权重 ）向下取整</p><p>上述公式只适用于 所有收缩因子的总和大于 1 的情况</p><p>压缩权重 &#x3D; 长度1 x 收缩因子1 + 长度2 x 收缩因子2 + …</p><p>长度指的是主轴上的长度</p></blockquote><p><code>flex-grow</code>:定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 非负数 */</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>最终长度 &#x3D; 原长度 + 扩张单位 x 扩张因子 （向下取整）</p><p>扩张单位 &#x3D; 剩余空间 &#x2F; 扩张因子的总和</p><p>长度指的是主轴上的长度</p></blockquote><p><code>flex-basis</code>：根据主轴的方向代替，主轴上的宽或者高</p><p>默认 auto（其优先级比数值低）如果，不是 auto 而是数字，则优先级大于 项目的宽或者高</p>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wxss</tag>
      
      <tag>wxml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet-01</title>
    <link href="/2024/03/24/Servlet-01/"/>
    <url>/2024/03/24/Servlet-01/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Q：它能做什么呢？</p><p>A：我们可以通过实现Servlet来进行动态网页响应，使用Servlet，不再是直接由Tomcat服务器发送我们编写好的静态网页内容（HTML文件），而是由我们通过Java代码进行动态拼接的结果，它能够很好地实现动态网页的返回。</p><p>当然，Servlet并不是专用于HTTP协议通信，也可以用于其他的通信，但是一般都是用于HTTP。</p><hr><h2 id="创建Servlet"><a href="#创建Servlet" class="headerlink" title="创建Servlet"></a>创建Servlet</h2><p>我们只需要实现<code>Servlet</code>类即可，并添加注解<code>@WebServlet</code>来进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br>...实现接口方法<br>&#125;<br></code></pre></td></tr></table></figure><p>除了直接编写一个类，我们也可以在<code>web.xml</code>中进行注册，现将类上<code>@WebServlet</code>的注解去掉：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.example.webtest.TestServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/test<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样的方式也能注册Servlet</p><hr><p>实际上，Tomcat服务器会为我们提供一些默认的Servlet，也就是说在服务器启动后，即使我们什么都不编写，Tomcat也自带了几个默认的Servlet，他们编写在conf目录下的web.xml中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- The mapping for the default servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- The mappings for the JSP servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jspx<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>我们发现，默认的Servlet实际上可以帮助我们去访问一些静态资源，这也是为什么我们启动Tomcat服务器之后，能够直接访问webapp目录下的静态页面。</p><hr><h2 id="探究Servlet的生命周期"><a href="#探究Servlet的生命周期" class="headerlink" title="探究Servlet的生命周期"></a>探究Servlet的生命周期</h2><p>Q：一个Servlet是如何运行的。</p><p>A：首先我们需要了解，Servlet中的方法各自是在什么时候被调用的，我们先编写一个打印语句来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestServlet</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是构造方法！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是init&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是getServletConfig&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是service&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是getServletInfo&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是destroy&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先启动一次服务器，然后访问我们定义的页面，然后再关闭服务器，得到如下的顺序：</p><blockquote><p>我是构造方法！<br>我是init<br>我是service<br>我是service（出现两次是因为浏览器请求了2次，是因为有一次是请求favicon.ico，浏览器通病）</p><p>我是destroy</p></blockquote><p>我们可以多次尝试去访问此页面，但是init和构造方法只会执行一次，而每次访问都会执行的是<code>service</code>方法，因此，一个Servlet的生命周期为：</p><ul><li>首先执行构造方法完成 Servlet 初始化</li><li>Servlet 初始化后调用 <strong>init ()</strong> 方法。</li><li>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li><li>Servlet 销毁前调用 <strong>destroy()</strong> 方法。</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li></ul><p>现在我们发现，实际上在Web应用程序运行时，每当浏览器向服务器发起一个请求时，都会创建一个线程执行一次<code>service</code>方法，来让我们处理用户的请求，并将结果响应给用户。</p><hr><p>我们发现<code>service</code>方法中，还有两个参数，<code>ServletRequest</code>和<code>ServletResponse</code>，实际上，用户发起的HTTP请求，就被Tomcat服务器封装为了一个<code>ServletRequest</code>对象，我们得到是其实是Tomcat服务器帮助我们创建的一个实现类，HTTP请求报文中的所有内容，都可以从<code>ServletRequest</code>对象中获取，同理，<code>ServletResponse</code>就是我们需要返回给浏览器的HTTP响应报文实体类封装。</p><p>那么我们来看看<code>ServletRequest</code>中有哪些内容，我们可以获取请求的一些信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">//首先将其转换为HttpServletRequest（继承自ServletRequest，一般是此接口实现）</span><br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        <br>        System.out.println(request.getProtocol());  <span class="hljs-comment">//获取协议版本</span><br>        System.out.println(request.getRemoteAddr());  <span class="hljs-comment">//获取访问者的IP地址</span><br>    System.out.println(request.getMethod());   <span class="hljs-comment">//获取请求方法</span><br>        <span class="hljs-comment">//获取头部信息</span><br>        Enumeration&lt;String&gt; enumeration = request.getHeaderNames();<br>        <span class="hljs-keyword">while</span> (enumeration.hasMoreElements())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> enumeration.nextElement();<br>            System.out.println(name + <span class="hljs-string">&quot;: &quot;</span> + request.getHeader(name));<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，整个HTTP请求报文中的所有内容，都可以通过<code>HttpServletRequest</code>对象来获取，当然，它的作用肯定不仅仅是获取头部信息</p><p>那么我们再来看看<code>ServletResponse</code>，这个是服务端的响应内容，我们可以在这里填写我们想要发送给浏览器显示的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转换为HttpServletResponse（同上）</span><br><span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse) servletResponse;<br><span class="hljs-comment">//设定内容类型以及编码格式（普通HTML文本使用text/html，之后会讲解文件传输）</span><br>response.setHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br><span class="hljs-comment">//获取Writer直接写入内容</span><br>response.getWriter().write(<span class="hljs-string">&quot;我是响应内容！&quot;</span>);<br><span class="hljs-comment">//所有内容写入完成之后，再发送给浏览器</span><br></code></pre></td></tr></table></figure><p>现在我们在浏览器中打开此页面，就能够收到服务器发来的响应内容了。其中，响应头部分，是由Tomcat帮助我们生成的一个默认响应头。</p><hr><p><img src="/../img/Servlet-01/111.png"></p><hr><h1 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h1><p><code>Servlet</code>有一个直接实现抽象类<code>GenericServlet</code>，那么我们来看看此类做了什么事情。</p><p>我们发现，这个类完善了配置文件读取和Servlet信息相关的的操作，但是依然没有去实现service方法，因此此类仅仅是用于完善一个Servlet的基本操作，那么我们接着来看<code>HttpServlet</code>，它是遵循HTTP协议的一种Servlet，继承自<code>GenericServlet</code>，它根据HTTP协议的规则，完善了service方法。</p><p>在阅读了HttpServlet源码之后，我们发现，其实我们只需要继承HttpServlet来编写我们的Servlet就可以了，并且它已经帮助我们提前实现了一些操作，这样就会给我们省去很多的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        resp.getWriter().write(<span class="hljs-string">&quot;&lt;h1&gt;恭喜你解锁了全新玩法&lt;/h1&gt;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们只需要重写对应的请求方式，就可以快速完成Servlet的编写。</p><hr><h2 id="WebServlet注解详解"><a href="#WebServlet注解详解" class="headerlink" title="@WebServlet注解详解"></a>@WebServlet注解详解</h2><p>我们接着来看WebServlet注解，我们前面已经得知，可以直接使用此注解来快速注册一个Servlet，那么我们来想细看看此注解还有什么其他的玩法。</p><p>首先name属性就是Servlet名称，而urlPatterns和value实际上是同样功能，就是代表当前Servlet的访问路径，它不仅仅可以是一个固定值，还可以进行通配符匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/test/*&quot;)</span><br></code></pre></td></tr></table></figure><p>上面的路径表示，所有匹配<code>/test/随便什么</code>的路径名称，都可以访问此Servlet，我们可以在浏览器中尝试一下。</p><p>也可以进行某个扩展名称的匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;*.js&quot;)</span><br></code></pre></td></tr></table></figure><p>这样的话，获取任何以js结尾的文件，都会由我们自己定义的Servlet处理。</p><p>那么如果我们的路径为<code>/</code>呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/&quot;)</span><br></code></pre></td></tr></table></figure><p>此路径和Tomcat默认为我们提供的Servlet冲突，会直接替换掉默认的，而使用我们的，此路径的意思为，如果没有找到匹配当前访问路径的Servlet，那么久会使用此Servlet进行处理。</p><p>我们还可以为一个Servlet配置多个访问路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&#123;&quot;/test1&quot;, &quot;/test2&quot;&#125;)</span><br></code></pre></td></tr></table></figure><p>我们接着来看loadOnStartup属性，此属性决定了是否在Tomcat启动时就加载此Servlet，默认情况下，Servlet只有在被访问时才会加载，它的默认值为-1，表示不在启动时加载，我们可以将其修改为大于等于0的数，来开启启动时加载。并且数字的大小决定了此Servlet的启动优先级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(value = &quot;/test&quot;, loadOnStartup = 1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        <span class="hljs-built_in">super</span>.init();<br>        log.info(<span class="hljs-string">&quot;我被初始化了！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        resp.getWriter().write(<span class="hljs-string">&quot;&lt;h1&gt;balbalaba&lt;/h1&gt;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="重定向与请求转发"><a href="#重定向与请求转发" class="headerlink" title="重定向与请求转发"></a>重定向与请求转发</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">resp.sendRedirect(<span class="hljs-string">&quot;time&quot;</span>);<span class="hljs-comment">//重定向</span><br>req.getRequestDispatcher(<span class="hljs-string">&quot;/time&quot;</span>).forward(req, resp);<span class="hljs-comment">//请求转发</span><br></code></pre></td></tr></table></figure><hr><p>Q：请求转发有什么好处呢？</p><p>A：它可以携带数据！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">req.setAttribute(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;我是请求转发前的数据&quot;</span>);<br>req.getRequestDispatcher(<span class="hljs-string">&quot;/time&quot;</span>).forward(req, resp);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(req.getAttribute(<span class="hljs-string">&quot;test&quot;</span>));<br></code></pre></td></tr></table></figure><p>通过<code>setAttribute</code>方法来给当前请求添加一个附加数据，在请求转发后，我们可以直接获取到该数据。</p><p>两者的区别为：</p><ul><li>请求转发是一次请求，重定向是两次请求</li><li>请求转发地址栏不会发生改变， 重定向地址栏会发生改变</li><li>请求转发可以共享请求参数 ，重定向之后，就获取不了共享参数了</li><li>请求转发只能转发给内部的Servlet</li></ul><p><img src="/../img/Servlet-01/12.png"></p><h1 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h1><p>ServletContext<strong>全局唯一</strong>，它是属于整个Web应用程序的，我们可以通过<code>getServletContext()</code>来获取到此对象。</p><p>此对象也能设置附加值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> getServletContext();<br>context.setAttribute(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;我是重定向之前的数据&quot;</span>);<br>resp.sendRedirect(<span class="hljs-string">&quot;time&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(getServletContext().getAttribute(<span class="hljs-string">&quot;test&quot;</span>));<br></code></pre></td></tr></table></figure><p>因为无论在哪里，无论什么时间，获取到的ServletContext始终是同一个对象，因此我们可以随时随地获取我们添加的属性。</p><p>它不仅仅可以用来进行数据传递，还可以做一些其他的事情，比如请求转发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">context.getRequestDispatcher(<span class="hljs-string">&quot;/time&quot;</span>).forward(req, resp);<br></code></pre></td></tr></table></figure><p>它还可以获取根目录下的资源文件（注意是webapp根目录下的，不是resource中的资源）</p><h2 id="ServletContext中的接口"><a href="#ServletContext中的接口" class="headerlink" title="ServletContext中的接口"></a>ServletContext中的接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Enumeration&lt;String&gt; enumeration = getServletContext().getAttributeNames();<span class="hljs-comment">//包含了ServletContext中的所有域属性名</span><br>Object object=getServletContext().getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//返回与之匹配的域属性值</span><br>getServletContext().removeAttribute(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//删除该属性名对应的域属性</span><br>getServletContext().setAttribute(<span class="hljs-string">&quot;la&quot;</span>,<span class="hljs-string">&quot;巴拉巴拉&quot;</span>);<span class="hljs-comment">//设置ServletContext的域属性，前者为属性名，后者为域属性值</span><br></code></pre></td></tr></table></figure><p>上面的为全局的属性，也可以通过请求转发来实现一写信息的转发（下面还有解释）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">req.setAttribute(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<span class="hljs-comment">//设置域属性</span><br>String name=req.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//获取域属性值</span><br></code></pre></td></tr></table></figure><hr><p>也可以获取web应用下的资源文件</p><p>其他方法遇到了再查，再记录</p><hr><h1 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h1><ul><li><p>HttpServletRequest 对象代表客户端的请求</p></li><li><p>当客户端&#x2F;浏览器通过 HTTP 协议访问服务器时，HTTP 请求头中的所有信息都封装在这个对象中</p></li></ul><p>HttpServletRequest 常用方法：</p><ol><li><p>getRequestURI() 获取请求的资源路径</p></li><li><p>getRequestURL() 获取请求的统一资源定位符（绝对路径</p></li><li><p>getRemoteHost() 获取客户端的 主机, getRemoteAddr()</p></li><li><p>getHeader() 获取请求头</p></li><li><p>getParameter() 获取请求的参数</p></li><li><p>getParameterValues() 获取请求的参数（多个值的时候使用）, 比如 checkbox, 返回的数组</p></li><li><p>getMethod() 获取请求的方式 GET 或 POST</p></li><li><p>setAttribute(key, value); 设置域数据</p></li><li><p>getAttribute(key); 获取域数据</p></li><li><p>getRequestDispatcher() 获取请求转发对象, 请求转发的核心对象</p></li></ol><p><font color="red">因为浏览器地址栏会停止在第一个 servlet ,如果你刷新页面，会再次发出请求(并且会 带数据), 所以在支付页面情况下，不要使用请求转发，否则会造成重复支付</font></p><hr><h1 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h1><blockquote><p>他是通过流来给客户端传递数据的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">字节流getOutputStream()常用于下载(传递二进制数据)<br>字符流getWriter()常用于回传字符串(非常常用)<br><span class="hljs-comment">// 两个流同时只能使用一个，也就是用了字节流就不能用字符流了，用了字符流就不能用字节流了</span><br></code></pre></td></tr></table></figure><p>对于<code>getWriter</code>：</p><p>他获取的对象为<code>PrintWriter</code>类型的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">resp.getWriter().write(<span class="hljs-string">&quot;hello servlet&quot;</span>);<br><span class="hljs-comment">//或者</span><br>PrintWriter writer=resp.getWriter();<br>writer.write(<span class="hljs-string">&quot;hello &quot;</span>);<br></code></pre></td></tr></table></figure><p>在向客户端写入东西时，要设置编码规则！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>还有一种方法：<code>setHeader()</code>,应该没上面的好用，就不写了</p><hr><h1 id="状态码解释"><a href="#状态码解释" class="headerlink" title="状态码解释"></a>状态码解释</h1><table><thead><tr><th>状态码</th><th>状态码描述</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。</td></tr><tr><td>302</td><td>Move temporarily</td><td>重定向，请求的资源临时从不同的 地址响应请求。</td></tr><tr><td>304</td><td>Not Modified</td><td>从浏览器缓存中读取数据，不从服务器重新获取数据。例如，用户第一次从浏览器访问服务器端图片资源，以后在访问该图片资源的时候就不会再从服务器上加载而直接到浏览器缓存中加载，这样效率更高。</td></tr><tr><td>404</td><td>Not Found</td><td>请求资源不存在。通常是用户路径编写错误，也可能是服务器资源已删除。</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器已经理解请求，但是拒绝执行它</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求行中指定的请求方法不能被用于请求相应的资源</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误。通常程序抛异常</td></tr></tbody></table><hr><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>什么是Cookie？它可以在浏览器中保存一些信息，并且在下次请求时，请求头中会携带这些信息。</p><p>我们可以编写一个测试用例来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;yyds&quot;</span>);<br>resp.addCookie(cookie);<br>resp.sendRedirect(<span class="hljs-string">&quot;time&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Cookie cookie : req.getCookies()) &#123;<br>    System.out.println(cookie.getName() + <span class="hljs-string">&quot;: &quot;</span> + cookie.getValue());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>javaweb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaweb</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven项目的创建</title>
    <link href="/2024/03/22/maven%E5%9F%BA%E7%A1%8001/"/>
    <url>/2024/03/22/maven%E5%9F%BA%E7%A1%8001/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Maven简介"><a href="#1、Maven简介" class="headerlink" title="1、Maven简介"></a>1、Maven简介</h1><p>Q:什么是？</p><p>A：全称是<a href="https://maven.apache.org/">Apache Maven</a>。专门用于管理和构建项目的<strong>工具</strong></p><hr><p>Q：有什么用？？</p><p>A：就是用meven后，不管用什么编译器，项目结构都一样通用了</p><p>A：项目写好后，不知道怎么打包之类的，使用maven对应的一个命令就可以帮你完成这些工作了</p><hr><p><strong>依赖管理：</strong></p><p>管理你项目所依赖的第三方资源（jar包、插件） </p><p><strong>不用maven使用jar包的步骤：</strong></p><p>网上去寻找下载jar包–&gt;复制jar包到项目–&gt;将jar包加入到工作环境</p><p><strong>用maven后步骤：</strong></p><p>使用简单的几行命令坐标就可以从<strong>仓库</strong>里面调你需要的jar包给你直接用上</p><hr><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote><p>只对<code>conf/settings.xml</code>文件的配置说明（以下文件不特别说明，均是该文件）</p></blockquote><p>首先，该文件中本身就存在很多配置，但是很多都是注释掉的</p><h2 id="（1）设置本地仓库"><a href="#（1）设置本地仓库" class="headerlink" title="（1）设置本地仓库"></a>（1）设置本地仓库</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.2.0&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- localRepository</span><br><span class="hljs-comment">   | The path to the local repository maven will use to store artifacts.</span><br><span class="hljs-comment">   |</span><br><span class="hljs-comment">   | Default: $&#123;user.home&#125;/.m2/repository --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:/Maven/apache-maven-3.8.4/repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个要将<code> &lt;localRepository&gt; &lt;/localRepository&gt;</code>标签写出来，地址为本地仓库名字，后续的查找相关的<code>jar</code>包会现在本地仓库寻找（由于第一次要从中央仓库中下载，所以加载的速慢点是正常的）</p><h2 id="（2）修改Maven的jdk版本"><a href="#（2）修改Maven的jdk版本" class="headerlink" title="（2）修改Maven的jdk版本"></a>（2）修改Maven的jdk版本</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>     <br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>JDK-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>       <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>       <br>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>       <br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span>       <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>       <br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>       <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>       <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>       <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>       <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>       <br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br></code></pre></td></tr></table></figure><p>找到<code>&lt;profiles&gt;&lt;/profiles&gt; </code>标签写在里面即可</p><h2 id="（3）添加国内镜像源"><a href="#（3）添加国内镜像源" class="headerlink" title="（3）添加国内镜像源"></a>（3）添加国内镜像源</h2><p>写到<code>&lt;mirrors&gt;&lt;/mirrors&gt;</code>标签中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 阿里云仓库 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 中央仓库1 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>repo1<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 中央仓库2 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>repo2<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure><p>这样对于文件的配置进本完成，后续有需要可以在添加修改</p><h2 id="添加到idea中"><a href="#添加到idea中" class="headerlink" title="添加到idea中"></a>添加到idea中</h2><p>注意设置到 IDEA 的全局中</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/11.jpg" alt="image-20240322133501676"></p><p>直接搜索<code>maven</code>即可</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/12.png" alt="image-20240322134855545"></p><p> i ： Maven主路径设置为自己的安装路径</p><p>ii ：用户设置文件设置为Maven的<code>conf</code>文件夹下的<code>settings.xml</code> 文件，并注意后面打上对号</p><p>iii ：本地仓库注意看看是否是自己设置的仓库，不是的话，修改下即可</p><h1 id="2、常用命令"><a href="#2、常用命令" class="headerlink" title="2、常用命令"></a>2、常用命令</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 显示版本信息</span><br><span class="hljs-string">mvn</span> <span class="hljs-string">-version</span> <br><span class="hljs-comment"># 清理项目产生的临时文件，一般是模块下的target目录</span><br><span class="hljs-string">mvn</span> <span class="hljs-string">clean</span><br><span class="hljs-comment"># 编译源代码，一般是模块下的 src/main/java目录</span><br><span class="hljs-string">mvn</span> <span class="hljs-string">compile</span><br><span class="hljs-comment"># 项目打包工具 ，会在模块下的target目录生成jar或war等文件</span><br><span class="hljs-string">mvn</span> <span class="hljs-string">package</span><br><span class="hljs-comment"># 测试命令，或执行sec/test/java/下的junit的测试用例</span><br><span class="hljs-string">mvn</span> <span class="hljs-string">test</span><br><span class="hljs-comment"># 将打包的jar/war的文件复制到本地仓库中，供其他模块使用</span><br><span class="hljs-string">mvn</span> <span class="hljs-string">install</span><br><span class="hljs-comment"># 将打包的文件发布到远程参考，供其他人进行下载依赖</span><br><span class="hljs-string">mvn</span> <span class="hljs-string">deploy</span><br><span class="hljs-comment"># 生成项目相关信息的网站</span><br><span class="hljs-string">mvn</span> <span class="hljs-string">site</span><br><span class="hljs-comment"># 打印出项目的整个依赖树</span><br><span class="hljs-string">mvn</span> <span class="hljs-string">dependency:tree</span><br><span class="hljs-comment"># 创建maven的普通java项目</span><br><span class="hljs-string">mvn</span> <span class="hljs-string">archetype:generate</span><br><span class="hljs-comment"># 在Tomcat容器中运行web项目</span><br><span class="hljs-string">mvn</span> <span class="hljs-string">tomca7:run</span><br></code></pre></td></tr></table></figure><h1 id="3、IDEA2023创建Maven项目"><a href="#3、IDEA2023创建Maven项目" class="headerlink" title="3、IDEA2023创建Maven项目"></a>3、IDEA2023创建Maven项目</h1><h2 id="（1）Maven和Maven-Archetype区别"><a href="#（1）Maven和Maven-Archetype区别" class="headerlink" title="（1）Maven和Maven Archetype区别"></a>（1）Maven和Maven Archetype区别</h2><p> Maven：普通工程</p><p>Maven Archetype：模板工程</p><h2 id="（1-1）Maven"><a href="#（1-1）Maven" class="headerlink" title="（1-1）Maven"></a>（1-1）Maven</h2><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/13.png" alt="image-20240322141143569"></p><p>创建好之后如下</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/14.png" alt="image-20240322141340671"></p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/15.png" alt="image-20240322141458549"></p><h2 id="（1-2）Maven-Archetype"><a href="#（1-2）Maven-Archetype" class="headerlink" title="（1-2）Maven Archetype"></a>（1-2）Maven Archetype</h2><p>注意图片中的选择！！！</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/16.png" alt="image-20240322141714387"></p><p>Archetype选择第一个即可，创建普通的Maven项目，以后会新建Maven的web项目，选择第二个</p><p>第一个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">org.apache.maven.archetypes:maven-archetype-archetype<br></code></pre></td></tr></table></figure><p>第二个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">org.apache.maven.archetypes:maven-archetype-webapp<br></code></pre></td></tr></table></figure><p>选择的时候看清楚就行了</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/17.png" alt="image-20240322142310162"></p><p>可能会少一些文件夹，自己手动创建即可</p><h1 id="4、创建Maven的web项目"><a href="#4、创建Maven的web项目" class="headerlink" title="4、创建Maven的web项目"></a>4、创建Maven的web项目</h1><h2 id="（1-1）Maven-1"><a href="#（1-1）Maven-1" class="headerlink" title="（1-1）Maven"></a>（1-1）Maven</h2><p>①、创建方法和上面的（1-1）一样，然后在<code>test</code>下创建<code>resources</code>文件夹（新建时会有提示）</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/18.png" alt="image-20240322144443701"></p><p>②、接下来可以在main下创建一个空目录<a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=webapp&spm=1001.2101.3001.7020">webapp</a>，作为web目录</p><p>③、选择项目结构<img src="/../img/maven%E5%9F%BA%E7%A1%8001/19.png" alt="image-20240322145006175"></p><p>选择模块中的<code>web</code></p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/20.png" alt="image-20240322145102480"></p><p>然后按图示操作，然后确定即可</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/21.png" alt="image-20240322145657336"></p><p>上面操作之后</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/22.png" alt="image-20240322150104561"></p><p>然后，点击左边的工作，然后点击加号选择如图所示</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/23.png" alt="image-20240322150347703"></p><p>最后，点击应用即可<img src="/../img/maven%E5%9F%BA%E7%A1%8001/24.png" alt="image-20240322150505138"></p><p>如下图就算将web项目的maven就完成了</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/25.png" alt="image-20240322150930219"></p><p><font color="red">注意 : 创建的项目中可能没有 <code>.iml</code> 文件，在项目的根目录下使用终端命令即可创建</font></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">mvn idea:module<br></code></pre></td></tr></table></figure><p><font color="red">另外，在配置 tomcat 后仍出现 404 页面，在 <code>.xml</code> 文件中粘贴下面代码即可</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FacetManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">facet</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;web&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Web&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">descriptors</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">deploymentDescriptor</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;web.xml&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file://$MODULE_DIR$/src/main/webapp/WEB-INF/web.xml&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">descriptors</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">webroots</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file://$MODULE_DIR$/src/main/webapp&quot;</span> <span class="hljs-attr">relative</span>=<span class="hljs-string">&quot;/&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">webroots</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sourceRoots</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file://$MODULE_DIR$/src/main/resources&quot;</span> /&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file://$MODULE_DIR$/src/main/java&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">sourceRoots</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">facet</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="pink">还有 ： 运行之后可能仍是 404 ，则查看自己配置的 tomcat 中的 URL 是否包含了 ” 部署 “ 中 “ 应用上下文 ” 中的内容，如果没有 cv 到 URL 中去 </font></p><p><font color="skyblue">如果还有 404 那你真惨，请移步到别的DL的文章下吧</font></p><p>最后的文件如下：</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/26.png" alt="image-20240322164201237"></p><h2 id="（1-2）Maven-Archetype（推荐）"><a href="#（1-2）Maven-Archetype（推荐）" class="headerlink" title="（1-2）Maven Archetype（推荐）"></a>（1-2）Maven Archetype（推荐）</h2><p>注意 Archetype 的选择</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/27.png" alt="image-20240322164558913"></p><p>然后点击创建后，即可，最后的文件夹如下：</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/28.png"></p><p>如果没有 <code>src/main</code>下的 <code> java</code> 和 <code>resources</code>文件夹，手动创建即可，会有提示的，如下（都创建即可）：</p><p><img src="/../img/maven%E5%9F%BA%E7%A1%8001/29.png" alt="image-20240322165238188"></p><p>注意本方法在配置 tomcat 进行修复时，选择带有 <code>exploded</code>的那个就行了</p><p>本方法没有<code>.iml</code>文件</p><h1 id="5、普通的web项目"><a href="#5、普通的web项目" class="headerlink" title="5、普通的web项目"></a>5、普通的web项目</h1><p><a href="https://blog.csdn.net/weixin_72330417/article/details/135269540?spm=1001.2014.3001.5502">Javaweb实训——web项目的创建_新建javaweb项目-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaweb</tag>
      
      <tag>xml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序学习笔记（4）</title>
    <link href="/2024/03/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/"/>
    <url>/2024/03/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1-wxss"><a href="#1-wxss" class="headerlink" title="1.wxss"></a>1.wxss</h1><p>和<code>css</code>基本一样， <code>rpx</code>和<code>@import</code>是<code>wxss</code>专有的</p><h2 id="（1）、rpx"><a href="#（1）、rpx" class="headerlink" title="（1）、rpx"></a>（1）、rpx</h2><p>解决适配的问题的单位尺寸</p><h2 id="（2）、-import"><a href="#（2）、-import" class="headerlink" title="（2）、@import"></a>（2）、@import</h2><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;相对路径&quot;</span>;<br></code></pre></td></tr></table></figure><h1 id="2、app-json中的用法"><a href="#2、app-json中的用法" class="headerlink" title="2、app.json中的用法"></a>2、app.json中的用法</h1><blockquote><p>注意：页面中无 window 的标签，需要属性直接写进去即可，他只能配置与 window 相关的配置项</p></blockquote><h2 id="（1）、window用法"><a href="#（1）、window用法" class="headerlink" title="（1）、window用法"></a>（1）、window用法</h2><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/100.png"></p><h1 id="3、全局配置tabBar"><a href="#3、全局配置tabBar" class="headerlink" title="3、全局配置tabBar"></a>3、全局配置tabBar</h1><blockquote><p>在 window 中设置的</p></blockquote><p>用于实现多页面的切换，小程序中分为：“底部tabBar”，“顶部tabBar”</p><p>一般来讲，<code>tabBar</code>中只能包含最少两个，最多五个的<code>tab</code>标签</p><p>当<code>tab</code>为顶部时，不显示<code>icon</code></p><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/102.png"></p><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/101.png"></p><h1 id="4、请求方法"><a href="#4、请求方法" class="headerlink" title="4、请求方法"></a>4、请求方法</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">post</span>(<span class="hljs-params"></span>)&#123;<br>    wx.<span class="hljs-title function_">request</span>(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;url&#x27;</span>,<span class="hljs-comment">//请求接口地址，必须基于 https 协议</span><br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<span class="hljs-comment">//请求方式 post get</span><br>        <span class="hljs-attr">data</span>:&#123;<br>            <span class="hljs-comment">// 发送到后端的数据</span><br>        &#125;,<br>        <span class="hljs-attr">success</span>:<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>            <span class="hljs-comment">//成功回调函数</span><br>        &#125;<br>    &#125;)<br>&#125;,<br></code></pre></td></tr></table></figure><p>在页面刚加载的时候请求数据，：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生命周期函数--监听页面加载</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">onLoad</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">btn</span>(<span class="hljs-number">123</span>);<span class="hljs-comment">//在本函数中调用方法即可</span><br>&#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wxss</tag>
      
      <tag>wxml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux笔记（1）</title>
    <link href="/2024/03/19/linux/Linux%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <url>/2024/03/19/linux/Linux%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1、进入-root-用户"><a href="#1、进入-root-用户" class="headerlink" title="1、进入 root 用户"></a>1、进入 root 用户</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">sudo</span> <span class="hljs-string">-i</span><br></code></pre></td></tr></table></figure><p>输入后，输入密码即可</p><h1 id="2、解压文件"><a href="#2、解压文件" class="headerlink" title="2、解压文件"></a>2、解压文件</h1><p><code>unzip</code>解压文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip file.zip<br></code></pre></td></tr></table></figure><p>如果要将压缩文件解压到指定的目录，可以使用 <code>-d</code> 选项指定目标目录，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip file.zip -d /path/to/destination<br></code></pre></td></tr></table></figure><p>这会将压缩文件解压到指定的目标目录中。</p><p>另外，系统中没有安装 <code>unzip</code> 命令可以通过包管理器安装它。例如，在 Ubuntu 上，可以使用以下命令安装 <code>unzip</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install unzip<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hustoj二开（1）</title>
    <link href="/2024/03/19/hustoj%E4%BA%8C%E5%BC%80%EF%BC%881%EF%BC%89/"/>
    <url>/2024/03/19/hustoj%E4%BA%8C%E5%BC%80%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>啊啊啊啊！！！难崩：</p><p>路径问题搞了好长时间才明白了该项目的路径如何设置的 &gt;_&lt; ,，本文就路径问题，前端页面修改问题进行解析</p></blockquote><h1 id="1、路径问题"><a href="#1、路径问题" class="headerlink" title="1、路径问题"></a>1、路径问题</h1><p>​      路径问题绝对是我解决时间最长的一部分，他对于每一个项目的参考不同，虽有一些东西是相似的（可以在网上找到参考），但是治标不治本（我真菜，了解不了大佬们的笔记）</p><p>​     就本项目而言、他的路径通过一些引用，在代码部分很难看出来，所以，可以打开前端的调试工具（F12）<strong>注意：在主页打开调试工具能更好的看到路径问题的反应</strong> （不要问早干嘛去了！！！！！）</p><p><img src="/../img/hustoj%E4%BA%8C%E5%BC%80%EF%BC%881%EF%BC%89/100.png"></p><p>   这样就一目了然了，如果仍不清楚，在后端新建测试文件试试路径即可</p><h1 id="2、开发问题"><a href="#2、开发问题" class="headerlink" title="2、开发问题"></a>2、开发问题</h1><h2 id="（1）、mysql"><a href="#（1）、mysql" class="headerlink" title="（1）、mysql"></a>（1）、mysql</h2><p>清除表中所有的数据，无法回滚，更快。</p><blockquote><p>在设计表和测试时，清除杂乱数据、对完善后的代码在次测试</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysq">TRUNCATE TABLE table_name;<br></code></pre></td></tr></table></figure><h2 id="（2）、php"><a href="#（2）、php" class="headerlink" title="（2）、php"></a>（2）、php</h2><p>如果文件夹要写入信息，使用命令.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">chmod</span> <span class="hljs-string">-R</span> <span class="hljs-number">777</span> <span class="hljs-string">文件夹</span><br></code></pre></td></tr></table></figure><p>赋予权限，一般设置完成为绿色</p>]]></content>
    
    
    <categories>
      
      <category>oj</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo更新注意事项</title>
    <link href="/2024/02/28/hexo/hexo%E6%9B%B4%E6%96%B0%E6%B3%A8%E6%84%8F/"/>
    <url>/2024/02/28/hexo/hexo%E6%9B%B4%E6%96%B0%E6%B3%A8%E6%84%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><h2 id="1、关于中括号的问题"><a href="#1、关于中括号的问题" class="headerlink" title="1、关于中括号的问题"></a>1、关于中括号的问题</h2><p>不在代码块中的 <code>&#123;</code> 不能出现一对，否则不能渲染页面</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序学习笔记（3）</title>
    <link href="/2024/02/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <url>/2024/02/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本文中的<code>html</code>和<code>css</code>对应<code>wxml</code>和<code>wxss</code></p><h1 id="1、数据绑定"><a href="#1、数据绑定" class="headerlink" title="1、数据绑定"></a>1、数据绑定</h1><p><code>Mustache</code>语法（双大括号）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;info&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><br>//同时在本文件的 .js文件中写入数据<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Page</span>(&#123;<br><br>  <span class="hljs-attr">data</span>: &#123;<br>     <span class="hljs-attr">info</span>:<span class="hljs-string">&#x27;hello world&#x27;</span>,<br>    <span class="hljs-attr">randomNum</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(),<span class="hljs-comment">//随机生成数字</span><br>    <span class="hljs-attr">randomNumFixed</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//随机生成2位小数的小数  </span><br>  &#125;<br>          <br>&#125;)<br></code></pre></td></tr></table></figure><p> 通过该语法可以动态绑定属性</p><p>在<code>data</code>中也可以写入图片链接，然后通过该语法写入<code>wxml</code>中</p><h1 id="2、事件绑定"><a href="#2、事件绑定" class="headerlink" title="2、事件绑定"></a>2、事件绑定</h1><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/100.jpg" alt="常用事件"></p><p><code>target</code>和<code>currentTarget</code>：</p><ul><li>前者是触发事件的源头组件</li><li>后者是当前时间所绑定的组件</li><li>例如：<code>view</code> 中存在一个 <code>button</code> 给<code>view</code>绑定一个<code>bindtap</code>，点击 <code>button</code> 后，<code>e.target</code>指向是<code>button</code>，<code>e.currentTarget</code>是<code>view</code></li></ul><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">bind:tap</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span><br>点击<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>别忘了在 <code>js</code>中写入<code>btn</code>的函数</p><hr><hr><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">通过 this.setData(&#123;&#125;) 给 data 中的数据赋新值<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">btn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">count</span>+<span class="hljs-number">1</span> <span class="hljs-comment">//count是data中的数据</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><hr><hr><p><code>bindinput</code>: 相应文本框输入事件</p><p>绑定方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">bindinput</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span><br>点击<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">btn</span>(<span class="hljs-params">e</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">detail</span>.<span class="hljs-property">value</span>);<span class="hljs-comment">//获取文本框最新的值</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="3、事件传参"><a href="#3、事件传参" class="headerlink" title="3、事件传参"></a>3、事件传参</h1><p>不能再绑定事件的<strong>同时</strong>传递参数</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">bind:tap</span>=<span class="hljs-string">&quot;find(123)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>123</strong>不能作参数传到 <code>js</code>中</p><p>可以用以下方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">bind:tap</span>=<span class="hljs-string">&quot;find&quot;</span> <span class="hljs-attr">data-info</span>=<span class="hljs-string">&quot;&#123;&#123;2&#125;&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><code>info</code>可以随便命名，格式为<code>data-*</code></p><ul><li>注意传入数字式建议写为 <code>&#123;&#123;数字&#125;&#125;</code>形式，不然传进去的为文本类型</li></ul><p>传到<code>js</code>中的<code>find</code>函数中时，形参获取方式为：<code>e.target.dataset.参数名字</code>（和<code>data-*</code>中的<code>*</code>的名字一样）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">find</span>(<span class="hljs-params">e</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">count</span>+e.<span class="hljs-property">target</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">info</span> <span class="hljs-comment">//count是data中的数据</span><br>        <span class="hljs-comment">// 在 input 标签中可以用 value=&quot;&quot; 为文本框赋初始值</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><hr><hr><h1 id="4、条件渲染"><a href="#4、条件渲染" class="headerlink" title="4、条件渲染"></a>4、条件渲染</h1><h2 id="1-wx-if-duge"><a href="#1-wx-if-duge" class="headerlink" title="(1) wx:if=&quot;((duge))&quot;"></a>(1) <code>wx:if=&quot;((duge))&quot;</code></h2><p>注意上一行的 小括号应为中括号 <code>&#123;</code>(由于渲染问题不能写中括号)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:if</span>=<span class="hljs-string">&quot;&#123;&#123;pad === 1&#125;&#125;&quot;</span>&gt;</span>值等于1<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:elif</span>=<span class="hljs-string">&quot;&#123;&#123;pad === 2&#125;&#125;&quot;</span>&gt;</span>值等于2<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:else</span>&gt;</span>值等于3<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>注意：</strong> 在写入差值语法时，双大括号外不要有多余的空格！！！！！！！</li></ul><hr><p>结合 <code>&lt;block&gt;</code> 使用 <code>wx:if</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">block</span> <span class="hljs-attr">wx:if</span>=<span class="hljs-string">&quot;&#123;&#123;true&#125;&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span> 999 <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span> 888 <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">block</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：<code>&lt;block&gt;</code>只是起到包裹作用，不会在渲染时候进行渲染</p><hr><h2 id="2-hidden"><a href="#2-hidden" class="headerlink" title="(2) hidden"></a>(2) hidden</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">hidden</span>=<span class="hljs-string">&quot;&#123;&#123;pad&#125;&#125;&quot;</span>&gt;</span>等于 true 是显示，等于false时隐藏<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="前两者区别"><a href="#前两者区别" class="headerlink" title="前两者区别"></a>前两者区别</h2><ul><li><code>wx:if</code>以<code>动态创建和移除元素</code>的方式控制</li><li><code>hidden</code>以<code>切换样式</code>的方式控制（display:none &#x2F; block;）</li><li>频繁切换时，使用<code>hidden</code></li><li>控制条件复杂时，使用<code>wx:if</code></li></ul><hr><h2 id="3-wx-for"><a href="#3-wx-for" class="headerlink" title="(3) wx:for"></a>(3) wx:for</h2><blockquote><p>循环渲染</p></blockquote> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">// arr 是 data 中的数组<br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;&#123;&#123;arr&#125;&#125;&quot;</span>&gt;</span><br>索引值：&#123;&#123;index&#125;&#125; ， item : &#123;&#123;item&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>结果为：</p><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/101.png"></p><h2 id="4-wx-key"><a href="#4-wx-key" class="headerlink" title="(4) wx:key"></a>(4) wx:key</h2><p>在实现列表渲染时，设置 键值可以提高渲染效率</p><p><code>wx:for</code>中也可以使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;&#123;&#123;arr&#125;&#125;&quot;</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>索引值：&#123;&#123;index&#125;&#125; ， item : &#123;&#123;item&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>wx:key</code>中不要用差值语法！！！！！</li><li>键值一定要唯一</li></ul>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wxss</tag>
      
      <tag>wxml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序学习笔记（2）</title>
    <link href="/2024/02/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <url>/2024/02/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1、view"><a href="#1、view" class="headerlink" title="1、view"></a>1、view</h1><p>相当于<code>div</code> ，是一个块级元素</p><h1 id="2、scroll-view"><a href="#2、scroll-view" class="headerlink" title="2、scroll-view"></a>2、scroll-view</h1><ul><li>可滚动的试图区域</li><li>常用来实现滚动列表</li></ul><p><font color="skyblue">由于代码高亮的显示,本文中 <code>html</code> 代表 <code>wxml</code> ，<code>wxss</code> 代表 <code>wxss</code></font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--pages/list/list.wxml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scroll-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container1&quot;</span> <span class="hljs-attr">scroll-y</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>&lt;/scroll-view &gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* pages/list/list.wxss */</span><br><span class="hljs-selector-class">.container1</span> view&#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<span class="hljs-attribute">text-align</span>: center;<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.container1</span> view<span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-attribute">background-color</span>: aqua;<br>&#125;<br><span class="hljs-selector-class">.container1</span> view<span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>)&#123;<br><span class="hljs-attribute">background-color</span>: blueviolet;<br>&#125;<br><span class="hljs-selector-class">.container1</span> view<span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>)&#123;<br><span class="hljs-attribute">background-color</span>: chartreuse;<br>&#125;<br><br><span class="hljs-selector-class">.container1</span>&#123;<br><span class="hljs-attribute">display</span>: flex;<br><span class="hljs-attribute">justify-content</span>: space-around;<br>&#125;<br><span class="hljs-selector-class">.container1</span>&#123;<br><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">120px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">scroll-x <span class="hljs-comment">/* 允许横向滚动 */</span><br>scroll-x <span class="hljs-comment">/* 允许纵向滚动 */</span><br></code></pre></td></tr></table></figure><h1 id="3、swiper-和-swiper-item"><a href="#3、swiper-和-swiper-item" class="headerlink" title="3、swiper 和 swiper-item"></a>3、swiper 和 swiper-item</h1><ul><li>轮播图容器组件 和 轮播图 <code>item</code> 组件</li><li>轮播图是<code>滑动转换</code>的</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">swiper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-container&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">swiper</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.swiper-container</span>&#123;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>&#125;<br><span class="hljs-selector-class">.item</span>&#123;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">150px</span>;<br><span class="hljs-attribute">text-align</span>: center;<br>&#125;<br>swiper-item<span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) <span class="hljs-selector-class">.item</span>&#123;<br><span class="hljs-attribute">background-color</span>: brown;<br>&#125;<br>swiper-item<span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) <span class="hljs-selector-class">.item</span>&#123;<br><span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br>swiper-item<span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) <span class="hljs-selector-class">.item</span>&#123;<br><span class="hljs-attribute">background-color</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/100.png" alt="其他属性"></p><h1 id="4、text"><a href="#4、text" class="headerlink" title="4、text"></a>4、text</h1><p>添加 <code>selectable</code> 属性即可，是布尔值，默认 false</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br>    长按选中效果<br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">selectable</span>&gt;</span>123456678<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>rich-text</code>：通过<code>nodes</code>属性节点，将<code>THML</code>标签渲染为对应的<code>UI结构</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">rich-text</span> <span class="hljs-attr">nodes</span>=<span class="hljs-string">&quot;&lt;h1 style=&#x27;color:red;&#x27;&gt;标题&lt;/h1&gt;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">rich-text</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="5、button"><a href="#5、button" class="headerlink" title="5、button"></a>5、button</h1><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/101.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>普通按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>主色调按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;warn&quot;</span>&gt;</span>警告按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 小尺寸  size --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;mini&quot;</span>&gt;</span>普通按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;mini&quot;</span>&gt;</span>主色调按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;warn&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;mini&quot;</span>&gt;</span>警告按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 镂空 plain --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;mini&quot;</span> <span class="hljs-attr">plain</span>&gt;</span>普通按钮镂空<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;mini&quot;</span> <span class="hljs-attr">plain</span>&gt;</span>主色调按钮镂空<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;warn&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;mini&quot;</span> <span class="hljs-attr">plain</span>&gt;</span>警告按钮镂空<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="6、image"><a href="#6、image" class="headerlink" title="6、image"></a>6、image</h1><p>图片属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/102.png"></p>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wxss</tag>
      
      <tag>wxml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序学习笔记（1）</title>
    <link href="/2024/02/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <url>/2024/02/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、文件作用"><a href="#一、文件作用" class="headerlink" title="一、文件作用"></a>一、文件作用</h1><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/100.jpg" alt="根目录"></p><h2 id="app-json："><a href="#app-json：" class="headerlink" title="app.json："></a><code>app.json</code>：</h2><p>当前小程序的<strong>全局配置</strong>，包括所有页面路径、窗口外观、界面表现、底部tab</p><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/101.jpg" alt="app.json"></p><p><code>pages</code>：当前小程序的所有页面路径</p><p><code>window</code>：全局定义小程序的背景色、文字色等可以设置如下：</p><p><img src="/../img/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/102.png" alt="app.json"></p><p>更多用法：<a href="微信小程序学习笔记（4）.md">window用法</a></p><p><code>style</code>：全局定义小程序组件所使用的样式版本</p><p><code>sitemapLocation</code>：指定<code>sitemap.json</code>的路径</p><h2 id="project-config-json"><a href="#project-config-json" class="headerlink" title="project.config.json:"></a><code>project.config.json</code>:</h2><p>项目配置文件，记录对小程序开发工具所做的个性化配置</p><p><code>setting</code>：保存了编译相关的配置</p><p><code>appid</code>：小程序的账号 ID</p><h2 id="sitemap-json"><a href="#sitemap-json" class="headerlink" title="sitemap.json"></a><code>sitemap.json</code></h2><p>微信现已开放小程序内搜索，效果类似于PC网页的SEO。sitemap.json文件用来配置小程序页面是否允许<br>微信索引。<br>当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索关键字和页面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。</p><h2 id="页面中-json"><a href="#页面中-json" class="headerlink" title="页面中.json"></a>页面中<code>.json</code></h2><p>和<code>app.json</code>一样，但是页面中的配置会覆盖<code>app.json</code>中<code>相同</code>的<code>window</code>配置</p><h1 id="二、项目首页"><a href="#二、项目首页" class="headerlink" title="二、项目首页"></a>二、项目首页</h1><p><code>app.json</code>中<code>pages</code>的前后顺序，默认<code>第一个是首页</code></p><h1 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h1><h2 id="WXML和HTML"><a href="#WXML和HTML" class="headerlink" title="WXML和HTML"></a><strong>WXML</strong>和<strong>HTML</strong></h2><ul><li><p>标签名称不同<br>HTML ( div, span, img, a )<br>WXML ( view, text, image, navigator)</p><p>(上面的是一一对应的类似用法比较)</p></li><li><p>属性节点不同</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>超链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">navigator</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/ pages/home/home&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">navigato</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>提供了类似于Vue中的模板语法<br>数据绑定<br>列表渲染</p><p>条件渲染</p></li></ul><h2 id="WXSS-和CSS的区别"><a href="#WXSS-和CSS的区别" class="headerlink" title="WXSS 和CSS的区别"></a>WXSS 和CSS的区别</h2><p>① 新增了rpx尺寸单位</p><ul><li>cSS中需要手动进行像素单位换算，例如 rem</li><li>wXSS在底层支持新的尺寸单位 rpx，在不同大小的屏幕上小程序会自动进行换算</li></ul><p>② 提供了全局的样式和局部样式</p><ul><li>项目根目录中的app.wxSs会作用于所有小程序页面</li><li>局部页面的.wxSS样式仅对当前页面生效</li></ul><p>③ WxSS仅支持部分CSS选择器</p><ul><li>.class和#id</li><li>element</li><li>并集选择器、后代选择器</li><li>::after和 ::before等伪类选择器</li></ul><h2 id="小程序中-js文件的分类"><a href="#小程序中-js文件的分类" class="headerlink" title="小程序中.js文件的分类"></a>小程序中.js文件的分类</h2><p>小程序中的JS文件分为三大类，分别是:</p><p>① <code>appg.js</code></p><ul><li>是整个小程序项目的入口文件，通过调用<code>App()</code>函数来启动整个小程序</li></ul><p>② 页面的<code>.js </code>文件</p><ul><li>是页面的入口文件，通过调用Page()函数来创建并运行页面</li></ul><p>③ 普通的<code>.js </code>文件</p><ul><li>是普通的功能模块文件，用来封装<code>公共的函数或属性</code>供页面使用</li></ul>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wxss</tag>
      
      <tag>wxml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用记事本打开大文本文件</title>
    <link href="/2024/02/27/%E8%AE%B0%E4%BA%8B%E6%9C%AC%E6%89%93%E5%BC%80%E5%A4%A7%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6/"/>
    <url>/2024/02/27/%E8%AE%B0%E4%BA%8B%E6%9C%AC%E6%89%93%E5%BC%80%E5%A4%A7%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>Q：使用记事本打开大文件出现了记事本卡死情况</p><p>A：将文件放入<code>VS</code>中打开即可</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>txt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oj数据库名字总结</title>
    <link href="/2024/02/03/oj%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D%E5%AD%97%E6%80%BB%E7%BB%93/"/>
    <url>/2024/02/03/oj%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D%E5%AD%97%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-oj数据库名字解析"><a href="#1-oj数据库名字解析" class="headerlink" title="1.   oj数据库名字解析"></a>1.   oj数据库名字解析</h1><h2 id="1-compileinfo"><a href="#1-compileinfo" class="headerlink" title="1. compileinfo"></a>1. compileinfo</h2><p><strong>编译信息</strong>存储的地方，例如</p><p>报错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">Main.c: In function <span class="hljs-string">&#x27;main&#x27;</span>:<br>Main.c:<span class="hljs-number">11</span>:<span class="hljs-number">9</span>: error: <span class="hljs-string">&#x27;b&#x27;</span> undeclared (first use in this function)<br>   <span class="hljs-number">11</span> |         b=b/<span class="hljs-number">2</span>;<br>      |         ^<br>Main.c:<span class="hljs-number">11</span>:<span class="hljs-number">9</span>: note: each undeclared identifier is reported only once <span class="hljs-keyword">for</span> each function it appears in<br>Main.c:<span class="hljs-number">19</span>:<span class="hljs-number">17</span>: error: expected <span class="hljs-string">&#x27;;&#x27;</span> before <span class="hljs-string">&#x27;return&#x27;</span><br>   <span class="hljs-number">19</span> |     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>      |                 ^<br>      |                 ;<br>   <span class="hljs-number">20</span> |     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      |     ~~~~~~       <br>Main.c:<span class="hljs-number">5</span>:<span class="hljs-number">5</span>: warning: ignoring <span class="hljs-keyword">return</span> value of <span class="hljs-string">&#x27;scanf&#x27;</span>, declared with attribute warn_unused_result [-Wunused-result]<br>    <span class="hljs-number">5</span> |     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>      |     ^~~~~~~~~~~~~~<br></code></pre></td></tr></table></figure><p>这种信息都存在这里</p><h2 id="2-contest"><a href="#2-contest" class="headerlink" title="2.  contest"></a>2.  contest</h2><p><strong>比赛目录</strong>的存储的地方</p><p>里面的信息都是比赛当时的记录，比赛结束后的题目记录不存在</p><h2 id="3-loginlog"><a href="#3-loginlog" class="headerlink" title="3. loginlog"></a>3. loginlog</h2><p><strong>登录日志</strong>即用户登录时间、IP的记录</p><h2 id="4-news"><a href="#4-news" class="headerlink" title="4. news"></a>4. news</h2><p><strong>前端新闻</strong>的存储记录</p><h2 id="5-online"><a href="#5-online" class="headerlink" title="5. online"></a>5. online</h2><h2 id="6-privilege"><a href="#6-privilege" class="headerlink" title="6. privilege"></a>6. privilege</h2><p><strong>用户权限</strong>存储的地方</p><h2 id="7-problem"><a href="#7-problem" class="headerlink" title="7. problem"></a>7. problem</h2><p><strong>题目的创建时间</strong>的储存处</p><h2 id="8-runmtimeinfo"><a href="#8-runmtimeinfo" class="headerlink" title="8. runmtimeinfo"></a>8. runmtimeinfo</h2><p><strong>运行时间信息</strong></p><p>例如：类似这种信息的存储</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">答案错误的样例：<br>    ========[test1.out]=========<br>Expected      |Yours<br>This is not a quadratic equation      |-nan -inf<br><br>==============================<br>time_space_table:<br>/<span class="hljs-number">1023</span>/sample.in:AC mem=<span class="hljs-number">2184</span>k time=<span class="hljs-number">4</span>ms<br>/<span class="hljs-number">1023</span>/sample1.in:AC mem=<span class="hljs-number">2184</span>k time=<span class="hljs-number">4</span>ms<br>/<span class="hljs-number">1023</span>/sc.in:AC mem=<span class="hljs-number">2184</span>k time=<span class="hljs-number">4</span>ms<br>/<span class="hljs-number">1023</span>/test0.in:AC mem=<span class="hljs-number">2184</span>k time=<span class="hljs-number">5</span>ms<br>/<span class="hljs-number">1023</span>/test1.in:WA mem=<span class="hljs-number">2184</span>k time=<span class="hljs-number">4</span>ms<br>/<span class="hljs-number">1023</span>/test2.in:AC mem=<span class="hljs-number">2184</span>k time=<span class="hljs-number">5</span>ms<br><br>    答案正确的样例：<br>    time_space_table:<br>/<span class="hljs-number">1043</span>/sample.in:AC mem=<span class="hljs-number">1200</span>k time=<span class="hljs-number">4</span>ms<br>/<span class="hljs-number">1043</span>/test0.in:AC mem=<span class="hljs-number">1200</span>k time=<span class="hljs-number">5</span>ms<br>/<span class="hljs-number">1043</span>/test1.in:AC mem=<span class="hljs-number">1200</span>k time=<span class="hljs-number">4</span>ms<br>/<span class="hljs-number">1043</span>/test2.in:AC mem=<span class="hljs-number">1200</span>k time=<span class="hljs-number">4</span>ms<br></code></pre></td></tr></table></figure><h2 id="9-solution"><a href="#9-solution" class="headerlink" title="9. solution"></a>9. solution</h2><p><strong>用户的提交信息</strong>的存储</p><h2 id="10-source-code-和-source-code-user"><a href="#10-source-code-和-source-code-user" class="headerlink" title="10. source_code 和  source_code_user"></a>10. source_code 和  source_code_user</h2><p><strong>提交的源代码</strong>的存储</p><p>可能两者有区别！！！但是我不知道 &gt;_&lt;</p><h2 id="11-user"><a href="#11-user" class="headerlink" title="11. user"></a>11. user</h2><p><strong>用户信息的存储</strong></p><hr><h1 id="2-删除账户"><a href="#2-删除账户" class="headerlink" title="2. 删除账户"></a>2. 删除账户</h1><h2 id="1-信息删除（不删除其做题数据）"><a href="#1-信息删除（不删除其做题数据）" class="headerlink" title="1.信息删除（不删除其做题数据）"></a>1.信息删除（不删除其做题数据）</h2><p>进到数据库<code>user</code>表里直节删除用户</p><p>该方法删除之后，用户在次用同样的用户id注册时，会自动连接到原来的数据；</p><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">开始存在了用户 A ，他做了一些题目<br>将他信息删除后，又重新注册了和用户 A 删除之前同样的用户id <br>那么，第二次注册的用户会获取 A 原本的数据，即 A 的所有做题数目<br></code></pre></td></tr></table></figure><h2 id="2-彻底删除（包括做题数据）"><a href="#2-彻底删除（包括做题数据）" class="headerlink" title="2.彻底删除（包括做题数据）"></a>2.彻底删除（包括做题数据）</h2><p>字面意思hhh</p><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">开始存在了用户 A ，他做了一些题目<br>将他信息删除后，又重新注册了和用户 A 删除之前同样的用户id <br>那么，第二次注册的用户，就是等同于白版，不会继承 A 的题目信息<br></code></pre></td></tr></table></figure><h1 id="3、删除步骤"><a href="#3、删除步骤" class="headerlink" title="3、删除步骤"></a>3、删除步骤</h1><p><strong>在删除之前一定要先进行该步骤</strong></p><p>要考虑到删除一个用户之后，题目的通过量，没通过量的数据的修改！！！！！</p><p>通过表<code>solution</code> 中的<code>pass_rate</code> 来得出用户对某个题目的通过与否？？，，<code>pass_rate==1.0</code>表示这道题目通过，由于题目统计只有通过和没通过，所以不必考虑没通过的原因</p><hr><p><strong>影响其他表中的删除：</strong></p><p>要先将 <strong>1</strong> 中的信息删除完，才能删除 <strong>4</strong> 中的</p><p>1： <code>compileinfo  和  runtimeinfo 和 source_code 和 source_code_user</code> 表中的<code>solution_id</code>要删除对应人的 “ 提交编号 ”（有点复杂，要找到对应人的提交编号）</p><p>4： <code>solution</code> 表中存储的所有通过与不通过的提交记录不要在第一个删除的前面，提前删除）</p><hr><p><strong>不影响其他表：</strong></p><p>2： <code>loginlog</code>表中的用户登录日志要 通过对应的<code>user_id</code> 删除(简单，不影响其他的删除，可以提前删除)</p><p>3： <code>privilege</code>表中的权限 通过对应的 <code>user_id</code> 删除（简单，不影响其他的删除，可以提前删除）</p><p> 5： <code>users</code> 表中的用户可以删除，（简单可以提前删除）</p><hr><h1 id="4、修改用户-id步骤"><a href="#4、修改用户-id步骤" class="headerlink" title="4、修改用户 id步骤"></a>4、修改用户 id步骤</h1><p><strong>注意修改语句写法</strong></p><p><code>loginlog</code>   、<code>privilege</code>  、<code>solution</code> 、<code>users</code> 表中的 <code>user_id</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 上述表 <span class="hljs-keyword">SET</span> `user_id`<span class="hljs-operator">=</span>要修改的值 <span class="hljs-keyword">WHERE</span> `user_id`<span class="hljs-operator">=</span>要修改的用户;<br></code></pre></td></tr></table></figure><p><code>solution</code> 、<code>users</code> 表中的 <code>nick</code>  ： 这是 <strong>用户名</strong> 建议修改，否则会导致以前的名字修改过之后，不同名字对应同一个用户id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 上述表 <span class="hljs-keyword">SET</span> `nick`<span class="hljs-operator">=</span>要修改的值 <span class="hljs-keyword">WHERE</span> `user_id`<span class="hljs-operator">=</span>要修改的用户;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>oj</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html补充</title>
    <link href="/2024/02/03/html%E8%A1%A5%E5%85%85/"/>
    <url>/2024/02/03/html%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="1-opacity-透明度"><a href="#1-opacity-透明度" class="headerlink" title="1.opacity(透明度)"></a>1.opacity(透明度)</h1><p><code>不仅对颜色有效，对图像或者页面中其它的元素也有效。</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">opacity</span>: value|inherit;<br></code></pre></td></tr></table></figure><p><font color="skyblue"> <strong>value</strong> 规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）。</font> <br> <strong>inherit</strong> 应该从父元素继承 opacity 属性的值。</p><p>注意： 当opacity属性的值应用于某个元素上时，是把这个元素（包括它的内容）当成一个整体看待，即使这个值没有被子元素继承。<br > &emsp;因此，一个元素和它包含的子元素都会具有和元素背景相同的透明度，哪怕这个元素和它的子元素有不同的opacity属性值。</p><hr><h1 id="2-cursor-鼠标形式"><a href="#2-cursor-鼠标形式" class="headerlink" title="2.cursor(鼠标形式)"></a>2.cursor(鼠标形式)</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>. <span class="hljs-attribute">cursor</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;img/sanchaji.png&#x27;</span>),pointer;//自定义图标的时候，后面必须加上一个普通光标<br><br><span class="hljs-number">2</span>. <span class="hljs-attribute">cursor</span><span class="hljs-selector-pseudo">:default</span>;<br></code></pre></td></tr></table></figure><p><img src="/../img/html%E8%A1%A5%E5%85%85/cur1.png"></p><p><img src="/../img/html%E8%A1%A5%E5%85%85/cur2.png"><br><img src="/../img/html%E8%A1%A5%E5%85%85/cur3.png"><br>cursor属性的默认值为 auto， 它表示由浏览器根据当前上下文，自动确定最适合的光标类型。auto 与 default 不同，default 表示使用客户端操作系统默认的光标类型。</p><hr><h1 id="4-display-flex-类似于行内块元素"><a href="#4-display-flex-类似于行内块元素" class="headerlink" title="4. display: flex (类似于行内块元素)"></a>4. display: flex (类似于行内块元素)</h1><p><a href="https://blog.csdn.net/qq_46048008/article/details/126406331?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169606027516777224439343%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169606027516777224439343&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-126406331-null-null.142%5Ev94%5Einsert_down28v1&utm_term=flex&spm=1018.2226.3001.4187">felx 详解</a></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">全称为 “Flexible <span class="hljs-built_in">Box</span> Layout”，即 “弹性盒布局”，旨在提供一种更有效的方式来<br>布局对齐和分配容器中项目之间的空间，即使它们的大小未知或动态变化<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex | inline-flex;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="5、justify-content-（弹性容器中对齐和分布子元素的水平位置）"><a href="#5、justify-content-（弹性容器中对齐和分布子元素的水平位置）" class="headerlink" title="5、justify-content （弹性容器中对齐和分布子元素的水平位置）"></a>5、justify-content （弹性容器中对齐和分布子元素的水平位置）</h1><p>该属性可应用于具有 <code>display: flex</code> 或 <code>display: inline-flex</code> 的父容器。以下是 <code>justify-content</code> 属性的几个常用取值：</p><ol><li><code>flex-start</code>: 默认值，子元素靠左对齐。</li><li><code>flex-end</code>: 子元素靠右对齐。</li><li><code>center</code>: 子元素在容器内居中对齐。</li><li><code>space-between</code>: 子元素平均分布在容器内，首尾子元素靠边。</li><li><code>space-around</code>: 子元素平均分布在容器内，包括首尾子元素。</li></ol><h1 id="6"><a href="#6" class="headerlink" title="6.###"></a>6.###</h1><h2 id="（1）定位：position"><a href="#（1）定位：position" class="headerlink" title="（1）定位：position"></a>（1）定位：position</h2><p>一般：子级元素用绝对定位，父级元素用相对定位</p><p><code>relative</code> 相对定位，移动的时候相对原来的定位，原来的位置不脱离标准流</p><p><code>absolute</code> 绝对定位，现对于他的父元素来说，如果最近的，没有祖元素或者祖元素没有定位，那么，就相当于浏览器为定位标准，定位之后，原来的位置不在占有空间</p><p><code>fixed</code> 固定定位,：是固定于浏览器可视的位置，即，浏览器滚动时，页面的元素的位置不改变</p><p><code>sticky</code> 粘性定位，浏览器的可视为参照点，占有原来的位置，必须有 <code>top  bottom right left </code> 其中的一个，兼容性不太好</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.op</span>&#123;<br>    <span class="hljs-attribute">position</span>: relative/absolute/fixed/sticky;<br>    <span class="hljs-attribute">top</span>:<span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">bottom</span>:<span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">right</span>:<span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">left</span>:<span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-叠放次序"><a href="#2-叠放次序" class="headerlink" title="(2)叠放次序"></a>(2)叠放次序</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.op</span>&#123;<br><span class="hljs-attribute">z-index</span>:<span class="hljs-number">1</span>;//可以是正数，负数，<span class="hljs-number">0</span>，默认auto<br>&#125;<br></code></pre></td></tr></table></figure><p>比说：两张图片在同一位置，那么，谁在上，谁的<code>z-index</code>值大，</p><p>注意：只有定位 <code>position</code> 的盒子才有用</p><h2 id="3-元素的隐藏和显示"><a href="#3-元素的隐藏和显示" class="headerlink" title="(3) 元素的隐藏和显示"></a>(3) 元素的隐藏和显示</h2><p><code>display</code> :</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">类似于网页中的广告，点击关闭，在此刷新会显示出来<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.op</span>&#123;<br><span class="hljs-attribute">display</span>: none;//隐藏， 不在占有原来的位置<br>    <span class="hljs-attribute">display</span>: block;//除了转化为块级元素之外，还可显示元素，重新占有原来的位置<br>&#125;<br></code></pre></td></tr></table></figure><p><code>visibility</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.op</span>&#123;    <br><span class="hljs-attribute">visibility</span>: hidden;//隐藏， 占有原来的位置   <br><span class="hljs-attribute">visibility</span>: visible;//显示元素，占有原来的位置   <br>&#125;<br></code></pre></td></tr></table></figure><p><code>overflow</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.op</span>&#123;    <br><span class="hljs-attribute">overflow</span>: scroll; //溢不溢出都显示滚动条<br>    <span class="hljs-attribute">overflow</span>: auto; // 需要才显示滚动条<br>     <span class="hljs-attribute">overflow</span>: hidden;//溢出的部分隐藏起来<br>     <span class="hljs-attribute">overflow</span>: visible;//默认的，超出的部分显示 <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-字体图标"><a href="#4-字体图标" class="headerlink" title="(4)字体图标"></a>(4)字体图标</h2><p><code>iconfont.cn</code>  阿里的</p><p><code>icomoon.io</code>  github的</p><p>下载之后，点击 <code>demo.html</code> 文件，找到要添加的图标，下面有个小方框的东西，虽然看起来都一样，复制下来，放到 <strong>html</strong> 文件中即可</p><p>举例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">span</span>&gt; □ &lt;/<span class="hljs-selector-tag">span</span>&gt;   //注意，这个方块是复制相应的图标的方块<br></code></pre></td></tr></table></figure><p>但是css中要使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span>&#123;<br><span class="hljs-attribute">font-family</span>:<span class="hljs-string">&#x27;icommon&#x27;</span>; //这个可以复制前面的<br>//其他的样式 大小，颜色。。。。<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs css">// 该文件就是前面下载的  这个是 style文件， <span class="hljs-keyword">@font-face</span> 里面的内容要复制到html页面中，主页面里 放到 css标签的里面，然后后面的要根据上面的 span 里面的写法<br><br>@font-face &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;icomoon&#x27;</span>;//复制这个到 <span class="hljs-selector-tag">span</span><br>  <span class="hljs-attribute">src</span>:  <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.eot?9gijve&#x27;</span>);<br>  <span class="hljs-attribute">src</span>:  <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.eot?9gijve#iefix&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;embedded-opentype&#x27;</span>),<br>    <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.ttf?9gijve&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;truetype&#x27;</span>),<br>    <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.woff?9gijve&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff&#x27;</span>),<br>    <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.svg?9gijve#icomoon&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;svg&#x27;</span>);<br>  <span class="hljs-attribute">font-weight</span>: normal;<br>  <span class="hljs-attribute">font-style</span>: normal;<br>  <span class="hljs-attribute">font-display</span>: block;<br>&#125;<br><br><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;icon-&quot;</span>]</span>, <span class="hljs-selector-attr">[class*=<span class="hljs-string">&quot; icon-&quot;</span>]</span> &#123;<br>  <span class="hljs-comment">/* use !important to prevent issues with browser extensions that change fonts */</span><br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;icomoon&#x27;</span> <span class="hljs-meta">!important</span>;<br>  <span class="hljs-attribute">speak</span>: never;<br>  <span class="hljs-attribute">font-style</span>: normal;<br>  <span class="hljs-attribute">font-weight</span>: normal;<br>  <span class="hljs-attribute">font-variant</span>: normal;<br>  <span class="hljs-attribute">text-transform</span>: none;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">/* Better Font Rendering =========== */</span><br>  -webkit-<span class="hljs-attribute">font-smoothing</span>: antialiased;<br>  -moz-osx-<span class="hljs-attribute">font-smoothing</span>: grayscale;<br>&#125;<br><br><span class="hljs-selector-class">.icon-pencil</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;\e905&quot;</span>;<br>&#125;<br><span class="hljs-selector-class">.icon-pencil2</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;\e906&quot;</span>;<br>&#125;<br><span class="hljs-selector-class">.icon-quill</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;\e907&quot;</span>;<br>&#125;<br><span class="hljs-selector-class">.icon-pen</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;\e908&quot;</span>;<br>&#125;<br><span class="hljs-selector-class">.icon-blog</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;\e909&quot;</span>;<br>&#125;<br><span class="hljs-selector-class">.icon-eyedropper</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;\e90a&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>追加时，在网址里有个按钮 <code>import icons</code>  选择 <code>.josn</code> 后缀的文件，在添加新的即可</p><p>三角形的做法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.op</span>&#123;<br><span class="hljs-attribute">margin-top</span>-<span class="hljs-attribute">color</span>: blue; //这个是下三角，其他的同理<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-文本域取消用户拉大效果"><a href="#4-文本域取消用户拉大效果" class="headerlink" title="(4)文本域取消用户拉大效果"></a>(4)文本域取消用户拉大效果</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">inptu&#123;<br><span class="hljs-attribute">outline</span>: none;//取消表单轮廓<br>&#125;<br><br><span class="hljs-selector-tag">textarea</span>&#123;<br><span class="hljs-attribute">resize</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-vertical-align"><a href="#5-vertical-align" class="headerlink" title="(5) vertical-align"></a>(5) vertical-align</h2><p>实现行内块元素和文字垂直对齐，具体可参考《浏览器搜索框》</p><p>一般属性值多用: <code>midddle</code> </p><p>也可解决图片下部分会有默认的白色空隙的问题</p><h2 id="6-对于-超链接打开方式的追加解析"><a href="#6-对于-超链接打开方式的追加解析" class="headerlink" title="(6)对于 超链接打开方式的追加解析"></a>(6)对于 超链接打开方式的追加解析</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">对于该问题的来源，是由于导航栏和主界面分开写而导致的问题<br></code></pre></td></tr></table></figure><p><code>_top</code>、<code>_parent</code>、<code>_self</code> 和 <code>_blank</code> 都是 HTML 中使用的 <code>&lt;a&gt;</code> 标签的 <code>target</code> 属性值，用于指定链接在何处打开。</p><ul><li><p><code>_top</code>：在整个窗口中加载目标页面。如果当前页面在一个框架集内，将会在顶层框架中加载目标页面，并且会取消所有已有的框架集。</p></li><li><p><code>_parent</code>：在父级框架中加载目标页面。如果当前页面不在框架集中，那么该属性与 <code>_self</code> 等同，即在当前窗口中打开目标页面。</p></li><li><p><code>_self</code>：在当前窗口中打开目标页面，默认值。</p></li><li><p><code>_blank</code>：在新窗口中打开目标页面。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js语法基础</title>
    <link href="/2024/02/03/js%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/02/03/js%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><hr><p>（在这里，单引号和双引号表示一样，但是不能混用）</p><hr><h2 id="1-弹出窗口"><a href="#1-弹出窗口" class="headerlink" title="1. 弹出窗口"></a>1. 弹出窗口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;弹出窗口&#x27;</span>)<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;直接显示在页面的用法&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;使用检查时，控制台输出&#x27;</span>)<span class="hljs-comment">//用于后台测试</span><br><span class="hljs-title function_">confirm</span>(<span class="hljs-string">&#x27;确定框&#x27;</span>) <span class="hljs-comment">// 对弹出窗口进行选择后，在次确定 </span><br><br><span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;提示框&#x27;</span>)  <span class="hljs-comment">//取回的值都是字符串类型</span><br><span class="hljs-comment">// prompt(&#x27;提示信息（弹出窗口的提示文字）&#x27; , &#x27;默认值（文本框的内容，可以修改）&#x27;)</span><br><span class="hljs-comment">//默认值也可以不写，当弹出来时，文本框是空的</span><br></code></pre></td></tr></table></figure><p>对于 <code>prompt</code> ，如果写为注释中的形式，并且前面有变量，那么，这个变量会获取默认值，即弹出框输入的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p1=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;弹出&#x27;</span>,<span class="hljs-string">&#x27;发生的就看看&#x27;</span>) <br><span class="hljs-comment">// &#x27;发生的就看看&#x27; 可以在弹出的文本框输入内容，输入的内容即被 p1 获取，然后输出到web页面</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(p1)<br></code></pre></td></tr></table></figure><p>对于 <code>confirm</code>() ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> tf=<span class="hljs-title function_">confirm</span>(<span class="hljs-string">&#x27;选择&#x27;</span>)<span class="hljs-comment">//第一层窗口显示的文字，&#x27;确定&#x27;的话 tf=true  &#x27;取消&#x27;的话 tf=false</span><br><span class="hljs-keyword">if</span>(tf)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;确定 &#x27;</span>) <br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;取消&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>和 <code>alert()</code> 区别是：前者会再次弹出条件语句中的提示，进行再次确定</p><hr><h2 id="2-var-关键字，旧版不建议使用，改用-let-更好"><a href="#2-var-关键字，旧版不建议使用，改用-let-更好" class="headerlink" title="2.   var(关键字，旧版不建议使用，改用 let 更好)"></a>2.   var(关键字，旧版不建议使用，改用 let 更好)</h2><p>定义局部变量，不建议写成全局（即不用类似的关键字修饰）</p><p>var 在定义变量之前用不会报错（区别之一）</p><p>例如（ var 不会报错）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">num=<span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> num=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-循环语句：for…in…"><a href="#3-循环语句：for…in…" class="headerlink" title="3.  循环语句：for…in…"></a>3.  循环语句：for…in…</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> arr<br>&#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(a+<span class="hljs-string">&#x27;  &#x27;</span>+ arr[a])<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;&lt;br/&gt;&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> a 可以是变量名、数组元素或对象属性</span><br><span class="hljs-comment">arr 可以是对象名或者计算结果为对象的表达式</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">每次循环，arr对象的每一个属性或每一元素都执行一次循环，</span><br><span class="hljs-comment">！！！另：arr可以看做c++里的 map ，每次循环会将 key 值复制给 a ， arr[a] 就是 value 值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">用于不确定的数组，比如从页面获得一些数据，不知道是什么，也不知道是多少；但是对于类似以 c 的数组，也可用for去遍历，长度为 arr.length</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h2><p>声明：  <code>let a = []</code> </p><p>写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;rening&#x27;</span>,<span class="hljs-string">&#x27;fasdf&#x27;</span>,<span class="hljs-string">&#x27;fasd&#x27;</span>]<br></code></pre></td></tr></table></figure><p>和 <strong>c</strong> 中的数组遍历方法一样，下标从0开始</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> m = arr.<span class="hljs-property">length</span> <span class="hljs-comment">//数组长度 </span><br></code></pre></td></tr></table></figure><h3 id="数组的新增："><a href="#数组的新增：" class="headerlink" title="数组的新增："></a>数组的新增：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">push</span>(元素<span class="hljs-number">1</span>, 元素<span class="hljs-number">2.</span>....);<br><span class="hljs-comment">//将变量放到数组的后面，并返回数组的长度 !!!需要的时候注意！！！</span><br><br>arr.<span class="hljs-title function_">unshift</span>()<span class="hljs-comment">//开头添加一个元素，并返回数组的长度</span><br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">pop</span>()<span class="hljs-comment">//删除最后一个元素，并返回该元素的值</span><br>arr.<span class="hljs-title function_">shift</span>()<span class="hljs-comment">//删除第一个元素，并返回该元素的值</span><br>arr.<span class="hljs-title function_">splice</span>(起始位置（数组下标从<span class="hljs-number">0</span>开始），删除几个元素)<span class="hljs-comment">//不写第二个参数值，默认从该位置删除到最后</span><br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-keyword">return</span> a-b&#125;)<span class="hljs-comment">//升序</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;retrun b-a&#125;)<span class="hljs-comment">//降序</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-常量、变量、数据存储"><a href="#5-常量、变量、数据存储" class="headerlink" title="5.常量、变量、数据存储"></a>5.常量、变量、数据存储</h2><p>关键字： <code>const</code> </p><p>用法： (相关性质和 <strong>c</strong> 一样)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure><p> <code>undefined</code> 声明但是没有赋值的变量，都是未定义类型（语义理解，不是用于定义的）</p><p>关键字：<code>typeof</code> 检测变量是什么类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num=<span class="hljs-number">10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> num)<br><span class="hljs-comment">//  控制台输出 number 数字类型</span><br><span class="hljs-comment">// string 字符型  boolean 布尔类型  undefined 未知类型</span><br></code></pre></td></tr></table></figure><p>​隐式转换：</p><ul><li><p>运算符 <strong>+</strong> 只要有一个是字符串，那么所有变量是字符串相拼</p></li><li><p>有其他的四则运算符之后，字符串与数字相运算会转换为数字型</p></li><li><p>+’ 312 ‘ 会将字符串转换为数字型</p></li><li><p>显式转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&#x27;123&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(str)) <span class="hljs-comment">//使用Number转换为数字型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12px&#x27;</span>)) <span class="hljs-comment">// 采用 paiseInt从字符串开始截取数字，只能是截取整型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;12.231px&#x27;</span>) ) <span class="hljs-comment">//浮点数截取</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 确定了数字类型，一般直接转换</span><br><br><span class="hljs-keyword">let</span> num = +<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;输入东西&#x27;</span>) <span class="hljs-comment">// 使用前置 + 直接转换</span><br></code></pre></td></tr></table></figure></li></ul><p>存放内存解释：</p><ul><li>简单数据（一般指本身储存值）直接放到 <strong>栈</strong> 里</li><li>复杂数据（对象，数组等），数据内容放到 <strong>堆</strong> 里，在 <strong>堆内</strong> 的地址放到栈里，引用时，<strong>先去栈中</strong> 获取堆地址，<strong>然后去堆中</strong>查找值</li></ul><p><strong>注意</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num1=<span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> num2 = num1<br>num2=<span class="hljs-number">20</span><br><span class="hljs-comment">//结果  num1=10 num2=20</span><br><br><span class="hljs-keyword">let</span> ha=&#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">10</span><br>&#125;<br><span class="hljs-keyword">let</span> hb=ha<br>hb.<span class="hljs-property">age</span>=<span class="hljs-number">20</span><br><span class="hljs-comment">//结果 age 都为20</span><br><br><span class="hljs-comment">//原因：</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">前者是存放到栈中的数据，通过 num2 = num1 只是把num1 的数据拷贝了一份到 num2 修改 num2 不会改变 num1 ，因为地址不一样。</span><br><span class="hljs-comment">后者是存放到堆中的数据，堆中的地址放到了栈中， hb=ha 是拷贝了一份堆中的地址到 hb 中，修改 hb 中的数据会改变 ha 的数据，因为他们的地址都是指向了同一个地方</span><br></code></pre></td></tr></table></figure><hr><h2 id="6-模板字符串"><a href="#6-模板字符串" class="headerlink" title="6.模板字符串"></a>6.模板字符串</h2><p>写法： <code>$&#123;变量名&#125;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> age=<span class="hljs-number">19</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`我是<span class="hljs-subst">$&#123;age&#125;</span>碎了`</span>)  <span class="hljs-comment">// 引号是反引号，不能改变</span><br><br><span class="hljs-comment">//相比</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;我是&#x27;</span>+age+<span class="hljs-string">&#x27;碎了&#x27;</span>)<br><span class="hljs-comment">//更为简洁清晰</span><br></code></pre></td></tr></table></figure><hr><h2 id="7-运算符"><a href="#7-运算符" class="headerlink" title="7.运算符"></a>7.运算符</h2><p><code>==</code>  只判断值是否相等</p><p><code>===</code> 判断 <strong>值</strong> <strong>数据类型</strong> 是否都一样 </p><p><code>!== </code> 左右两边是否不全等</p><hr><h2 id="8、函数"><a href="#8、函数" class="headerlink" title="8、函数"></a>8、函数</h2><h4 id="（1）有函数名的函数（必须调用才能执行）"><a href="#（1）有函数名的函数（必须调用才能执行）" class="headerlink" title="（1）有函数名的函数（必须调用才能执行）"></a>（1）有函数名的函数（必须调用才能执行）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> 函数名(形参<span class="hljs-number">1</span>，形参<span class="hljs-number">2.</span>..)&#123;<br>    <br>    <span class="hljs-comment">//可以有返回值，也可以没有</span><br>    <span class="hljs-comment">//可以有参数也可没有</span><br>&#125;<br><br><span class="hljs-comment">//如果又返回值： let na=函数名(参数...)</span><br><span class="hljs-comment">//返回值是多个的时候，写成数组的形式  return [变量1 , 变量2 ,  ....... ]</span><br><br></code></pre></td></tr></table></figure><p><strong>该函数可以在函数的上面调用该函数</strong> </p><h4 id="（2）无函数名的函数（需要调用）"><a href="#（2）无函数名的函数（需要调用）" class="headerlink" title="（2）无函数名的函数（需要调用）"></a>（2）无函数名的函数（需要调用）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-keyword">function</span> (<span class="hljs-params">形参.....</span>)&#123;   <br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>该函数只能在其定义的下面调用</strong> </p><h4 id="（4）-无函数名的函数（无序任何操作，直接运行）"><a href="#（4）-无函数名的函数（无序任何操作，直接运行）" class="headerlink" title="（4） 无函数名的函数（无序任何操作，直接运行）"></a>（4） 无函数名的函数（无序任何操作，直接运行）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//写法 一</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">形参.....</span>)&#123;<br>    <span class="hljs-comment">//代码块</span><br>&#125;)( 实参 ); <span class="hljs-comment">//分号一定要加，避免有两个该函数而导致报错</span><br><br><span class="hljs-comment">//写法 二</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">形参...</span>)&#123;<br>    <span class="hljs-comment">//代码块</span><br>&#125;(实参) );<br><br></code></pre></td></tr></table></figure><p>理解方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">num</span>(<span class="hljs-params">形参....</span>)&#123;<br>    <span class="hljs-keyword">let</span> num=<span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">//调用：</span><br><span class="hljs-title function_">num</span>(实参...)<br><br><span class="hljs-comment">//直接函数对比理解</span><br>(函数整体)(实参...);<span class="hljs-comment">//注意该方式的函数写法，要加分号</span><br><br></code></pre></td></tr></table></figure><hr><h2 id="9-对象"><a href="#9-对象" class="headerlink" title="9.对象"></a>9.对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> 对象名 = &#123;<br>    变量名 : 值 , <span class="hljs-comment">//冒号，逗号不能缺少</span><br>    <span class="hljs-comment">//变量名也可以写成字符串的形式如：&#x27;name-opa&#x27;</span><br>&#125;<br><br><span class="hljs-comment">//例如：</span><br><span class="hljs-keyword">let</span> ha=&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;fasd&#x27;</span>,<br>    <span class="hljs-attr">soce</span>: <span class="hljs-number">19</span><br>&#125;<br><br><span class="hljs-comment">//增加不存在的变量名：</span><br>ha.<span class="hljs-property">adress</span>=<span class="hljs-string">&#x27;dongJie&#x27;</span><br><span class="hljs-comment">//删除</span><br><span class="hljs-keyword">delete</span> ha.<span class="hljs-property">adress</span><br><span class="hljs-comment">//修改</span><br>ha.<span class="hljs-property">name</span>=<span class="hljs-string">&#x27;fasdfa&#x27;</span><br><span class="hljs-comment">//引用</span><br><span class="hljs-keyword">let</span> num=ha.<span class="hljs-property">soce</span><br><br><span class="hljs-comment">//另一种访问方式 对象名[&#x27;变量名&#x27;]  注意引号一定要有</span><br><br><span class="hljs-comment">// 如果变量名是字符串的形式必须用 对象名[&#x27;变量名&#x27;] 的形式进行操作</span><br><br><span class="hljs-comment">//总结：如果引用的变量不存在，那么就是增加 ； 如果存在，就是修改</span><br></code></pre></td></tr></table></figure><p><strong>方法</strong> （ java 中的类里面的方法同理 ）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//例如：</span><br><span class="hljs-keyword">let</span> ha=&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;fasd&#x27;</span>,<br>    <span class="hljs-attr">soce</span>: <span class="hljs-number">19</span><br>    <br>    <span class="hljs-attr">sing</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">形参...</span>)&#123;<br>        <span class="hljs-comment">//代码块</span><br>    &#125; , <span class="hljs-comment">//注意和函数一样，方法之间要用逗号隔开</span><br>     song : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>         <span class="hljs-comment">//代码块</span><br>     &#125;<br>&#125;<br><br><span class="hljs-comment">//调用时</span><br>ha.<span class="hljs-title function_">sing</span>(实参....)<br><br></code></pre></td></tr></table></figure><p><strong>遍历：</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> ha)&#123;<br><span class="hljs-comment">//遍历的时候只能用 对象名[&#x27;变量名&#x27;] 的方法</span><br>  <span class="hljs-comment">//因为 k 值是字符串形式</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
      <category>Js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux知识汇总</title>
    <link href="/2024/02/03/linux/linux%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <url>/2024/02/03/linux/linux%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-文件管理"><a href="#1-文件管理" class="headerlink" title="1.文件管理"></a>1.文件管理</h1><p>(1)<code>ctrl c</code>: 取消命令，并且换行 <br><br>(2) <code>ctrl u</code>: 清空本行命令<br><br>(3)<code> tab键</code>：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项<br><br>(4)<code> ls</code>: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件<br><br>(5) <code>pwd</code>-: 显示当前路径<br><br>(6) <code>cd XXX</code>: 进入 XXX 目录下, cd .. 返回上层目录<br><br>(7) <code>cp XXX YYY</code>: 将 XXX 文件复制成 YYY，XXX 和 YYY 可以是一个路径，比如 ..&#x2F;dir_c&#x2F;a.txt，表示上层目录下的dir_c文件夹下的文件a.txt <br><br>(8) <code>mkdir XXX</code>: 创建目录 XXX<br><br>(9) <code>rm XXX</code>: 删除普通文件;  rm XXX -r: 删除文件夹<br><br>(10) <code>mv XXX YYY</code>: 将 XXX 文件移动到 YYY，和cp命令一样，XXX 和 YYY 可以是一个路径；重命名也是用这个命令<br><br>(11) <code>touch XXX</code>: 创建一个文件<br><br>(12) <code>cat XXX</code>: 展示文件XXX中的内容<br><br>(13) 复制文本<br><br>   &emsp; windows&#x2F;Linux下：<code>Ctrl + insert</code>，Mac下：<code>command + c</code> <br><br>(14) 粘贴文本<br><br>   &emsp; windows&#x2F;Linux下：<code>Shift + insert</code>，Mac下：<code>command + v </code><br></p><hr><h1 id="2-tmux"><a href="#2-tmux" class="headerlink" title="2.tmux"></a>2.tmux</h1><p>功能：<br><br>    (1) 分屏。<br><br>    (2) 允许断开Terminal连接后，继续运行进程。<br><br>结构：<br><br>    一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。<br><br>    实例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">tmux:<br>    session 0:<br>        window 0:<br>            pane 0<br>            pane 1<br>            pane 2<br>            ...<br>        window 1<br>        window 2<br>        ...<br>    session 1<br>    session 2<br>    ...<br></code></pre></td></tr></table></figure><br>操作：<br>    (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。<br>    (2) 按下 Ctrl + a 后手指松开，然后按%：将当前pane左右平分成两个pane。<br>    (3) 按下 Ctrl + a 后手指松开，然后按"（注意是双引号"）：将当前pane上下平分成两个pane。<br>    (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。<br>    (5) 鼠标点击可以选pane。<br>    (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。<br>    (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。<br>    (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。<br>    (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。<br>    (10) 按下ctrl + a后手指松开，然后按d：挂起当前session。<br>    (11) tmux a：打开之前挂起的session。<br>    (12) 按下ctrl + a后手指松开，然后按s：选择其它session。<br>    <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">方向键 —— 上：选择上一项 session/window/pane<br>方向键 —— 下：选择下一项 session/window/pane<br>方向键 —— 右：展开当前项 session/window<br>方向键 —— 左：闭合当前项 session/window<br></code></pre></td></tr></table></figure><p>d(无意义分割行)<br><br><br>    (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。<br><br>    (14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。<br><br>    (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。<br><br>    (16) 鼠标滚轮：翻阅当前pane内的内容。<br><br>    (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）<br><br>    (18) tmux中复制&#x2F;粘贴文本的通用方式：<br></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">(1) 按下 Ctrl + a 后松开手指，然后按 [<br>(2) 用鼠标选中文本，被选中的文本会被自动复制到 tmux 的剪贴板<br>(3) 按下Ctrl + a 后松开手指，然后按 ] ，会将剪贴板中的内容粘贴到光标处<br></code></pre></td></tr></table></figure><h1 id="3-VIM"><a href="#3-VIM" class="headerlink" title="3.VIM"></a>3.VIM</h1><p>功能：<br>    (1) 命令行模式下的文本编辑器。<br>    (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。<br>    (3) 使用方式：vim filename<br>        如果已有该文件，则打开它。<br>        如果没有该文件，则打开个一个新的文件，并命名为filename<br>模式：<br>    (1) 一般命令模式<br>        默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。<br>    (2) 编辑模式<br>        在一般命令模式里按下i，会进入编辑模式。<br>        按下ESC会退出编辑模式，返回到一般命令模式。<br>    (3) 命令行模式<br>        在一般命令模式里按下:&#x2F;?三个字母中的任意一个，会进入命令行模式。命令行在最下面。<br>        可以查找、替换、保存、退出、配置编辑器等。<br>操作：<br>    (1) <code>i</code> ：进入编辑模式<br>    (2) <code> ESC</code>：进入一般命令模式<br>    (3) <code>h </code>或 左箭头键：光标向左移动一个字符<br>    (4) <code>j</code> 或 向下箭头：光标向下移动一个字符<br>    (5) <code>k</code> 或 向上箭头：光标向上移动一个字符<br>    (6) <code>l</code> 或 向右箭头：光标向右移动一个字符<br>    (7) <code>n&lt;Space&gt;</code>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符<br>    (8) <code>0 </code>或 <code>功能键[Home]</code>：光标移动到本行开头<br>    (9) <code>$ </code>或 <code>功能键[End]</code>：光标移动到本行末尾<br>    (10)<code> G</code>：光标移动到最后一行<br>    (11) <code>:n </code>或 <code>nG：</code>n为数字，光标移动到第n行<br>    (12) <code>gg：</code>光标移动到第一行，相当于1G<br>    (13) <code>n&lt;Enter&gt;</code>：n为数字，光标向下移动n行<br>    (14) <code>/word</code> ：向光标之下寻找第一个值为word的字符串。<br>    (15) <code>?word</code>：向光标之上寻找第一个值为word的字符串。<br>    (16) <code>n</code>：重复前一个查找操作<br>    (17) <code>N</code>：反向重复前一个查找操作<br>    (18) <code>:n1,n2s/word1/word2/g</code>：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2<br>    (19) <code>:1,$s/word1/word2/g</code>：将全文的word1替换为word2<br>    (20) <code>:1,$s/word1/word2/gc</code>：将全文的word1替换为word2，且在替换前要求用户确认。<br>    (21) <code>v</code>：选中文本<br>    (22) <code>d</code>：删除选中的文本<br>    (23) <code>dd</code>: 删除当前行<br>    (24) <code>y</code>：复制选中的文本<br>    (25) <code>yy</code>: 复制当前行<br>    (26) <code>p</code>: 将复制的数据在光标的下一行&#x2F;下一个位置粘贴<br>    (27) <code>u</code>：撤销<br>    (28) <code>Ctrl + r</code>：取消撤销<br>    (29) 大于号 &gt;：将选中的文本整体向右缩进一次<br>    (30) 小于号 &lt;：将选中的文本整体向左缩进一次<br>    (31)<code> :w</code> 保存<br>    (32) <code>:w!</code> 强制保存<br>    (33) <code>:q </code>退出<br>    (34) <code>:q!</code> 强制退出<br>    (35) <code>:wq </code>保存并退出<br>    (36) <code>:set paste</code> 设置成粘贴模式，取消代码自动缩进<br>    (37) <code>:set nopaste</code> 取消粘贴模式，开启代码自动缩进<br>    (38) <code>:set nu</code> 显示行号<br>    (39) <code>:set nonu</code> 隐藏行号<br>    (40) <code>gg=G</code>：将全文代码格式化<br>    (41) <code>:noh</code> 关闭查找关键词高亮<br>    (42) <code>Ctrl + q</code>：当vim<strong>卡死时</strong>，可以取消当前正在执行的命令<br>异常处理：<br>    每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。<br>    如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：<br>        (1) 找到正在打开该文件的程序，并退出<br>        (2) 直接删掉该swp文件即可</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php常用数据库操作</title>
    <link href="/2024/02/03/PHP%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/02/03/PHP%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="PHP操作"><a href="#PHP操作" class="headerlink" title="PHP操作"></a>PHP操作</h1><h2 id="1-mysqli-connect-连接数据库"><a href="#1-mysqli-connect-连接数据库" class="headerlink" title="1. mysqli_connect() 连接数据库"></a>1. <code>mysqli_connect()</code> 连接数据库</h2><h2 id="2-mysqli-close-关闭数据库"><a href="#2-mysqli-close-关闭数据库" class="headerlink" title="2. mysqli_close() 关闭数据库"></a>2. <code>mysqli_close()</code> 关闭数据库</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$servername</span> = <span class="hljs-string">&quot;localhost&quot;</span>;  <span class="hljs-comment">// MySQL 服务器地址</span><br><span class="hljs-variable">$username</span> = <span class="hljs-string">&quot;root&quot;</span>;         <span class="hljs-comment">// 数据库用户名</span><br><span class="hljs-variable">$password</span> = <span class="hljs-string">&quot;password&quot;</span>;     <span class="hljs-comment">// 数据库密码</span><br><span class="hljs-variable">$dbname</span> = <span class="hljs-string">&quot;mydatabase&quot;</span>;     <span class="hljs-comment">// 数据库名</span><br><br><span class="hljs-comment">// 建立与 MySQL 数据库服务器的连接</span><br><span class="hljs-variable">$conn</span> = <span class="hljs-title function_ invoke__">mysqli_connect</span>(<span class="hljs-variable">$servername</span>, <span class="hljs-variable">$username</span>, <span class="hljs-variable">$password</span>, <span class="hljs-variable">$dbname</span>);<br><br><span class="hljs-comment">// 检查连接是否成功</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-variable">$conn</span>) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;连接失败: &quot;</span> . <span class="hljs-title function_ invoke__">mysqli_connect_error</span>());<br>&#125;<br><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;连接成功！&quot;</span>;<br><br><span class="hljs-comment">// 在这里可以执行数据库操作</span><br><br><span class="hljs-comment">// 关闭与 MySQL 数据库服务器的连接</span><br><span class="hljs-title function_ invoke__">mysqli_close</span>(<span class="hljs-variable">$conn</span>);<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure><p><code>mysqli_num_rows()</code> 是 PHP 中用于获取查询结果中行数的函数，它是 MySQLi（MySQL Improved Extension）扩展库的一部分。MySQLi 是 PHP 提供的一个强大且面向对象的扩展，用于与 MySQL 数据库进行交互。</p><p><code>mysqli_num_rows</code> 函数的语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">mysqli_num_rows</span>(<span class="hljs-variable">$result</span>);<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>$result</code> 是一个结果对象，它表示从数据库中返回的查询结果集。</li></ul><h2 id="3-mysqli-num-rows-查询结果集中的行数"><a href="#3-mysqli-num-rows-查询结果集中的行数" class="headerlink" title="3. mysqli_num_rows 查询结果集中的行数"></a>3. <code>mysqli_num_rows</code> 查询结果集中的行数</h2><p>函数返回查询结果集中的行数，即结果集中包含多少条记录。如果查询失败或返回的结果集为空，则该函数返回 0。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 创建数据库连接</span><br><span class="hljs-variable">$connection</span> = <span class="hljs-title function_ invoke__">mysqli_connect</span>(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>);<br><br><span class="hljs-comment">// 检查连接是否成功</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">mysqli_connect_errno</span>()) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;连接数据库失败: &#x27;</span> . <span class="hljs-title function_ invoke__">mysqli_connect_error</span>());<br>&#125;<br><br><span class="hljs-comment">// 执行查询</span><br><span class="hljs-variable">$query</span> = <span class="hljs-string">&quot;SELECT * FROM users&quot;</span>;<br><span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysqli_query</span>(<span class="hljs-variable">$connection</span>, <span class="hljs-variable">$query</span>);<br><br><span class="hljs-comment">// 获取查询结果中的行数</span><br><span class="hljs-variable">$num_rows</span> = <span class="hljs-title function_ invoke__">mysqli_num_rows</span>(<span class="hljs-variable">$result</span>);<br><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查询结果中共有 <span class="hljs-subst">&#123;$num_rows&#125;</span> 条记录\n&quot;</span>;<br><br><span class="hljs-comment">// 关闭数据库连接</span><br><span class="hljs-title function_ invoke__">mysqli_close</span>(<span class="hljs-variable">$connection</span>);<br><br></code></pre></td></tr></table></figure><h2 id="4-mysqli-select-db-选择数据库的函数"><a href="#4-mysqli-select-db-选择数据库的函数" class="headerlink" title="4. mysqli_select_db 选择数据库的函数"></a>4. <code>mysqli_select_db</code> 选择数据库的函数</h2><p>是 PHP 中用于选择数据库的函数。它用于在连接到 MySQL 数据库后，选择要操作的特定数据库。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">bool</span> <span class="hljs-title function_ invoke__">mysqli_select_db</span> ( mysqli <span class="hljs-variable">$link</span> , <span class="hljs-keyword">string</span> <span class="hljs-variable">$dbname</span> )<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$link</code>：必需，一个有效的 MySQL 连接对象。</li><li><code>$dbname</code>：必需，要选择的数据库名称。</li></ul><p>返回值：</p><ul><li>如果选择数据库成功，则返回 true。</li><li>如果选择数据库失败，则返回 false。</li></ul><hr><h2 id="5-mysqli-query-常规的插入查找等"><a href="#5-mysqli-query-常规的插入查找等" class="headerlink" title="5. mysqli_query  常规的插入查找等"></a>5. mysqli_query  常规的插入查找等</h2><p> 是 PHP 中用于执行 SQL 查询的函数，它是 MySQLi（MySQL Improved Extension）扩展库的一部分。MySQLi 是 PHP 提供的一个强大且面向对象的扩展，用于与 MySQL 数据库进行交互。</p><p><code>mysqli_query</code> 函数的语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">mysqli_query</span>(<span class="hljs-variable">$connection</span>, <span class="hljs-variable">$query</span>);<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>$connection</code> 是一个数据库连接对象，它表示与 MySQL 数据库建立的连接。通常通过 <code>mysqli_connect</code> 或 <code>mysqli_init</code> 函数创建连接对象。</li><li><code>$query</code> 是要执行的 SQL 查询语句。</li></ul><p><code>mysqli_query</code> 函数执行指定的 SQL 查询，并返回一个结果对象或布尔值，具体取决于查询的类型和执行结果。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 创建数据库连接</span><br><span class="hljs-variable">$connection</span> = <span class="hljs-title function_ invoke__">mysqli_connect</span>(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>);<br><br><span class="hljs-comment">// 检查连接是否成功</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">mysqli_connect_errno</span>()) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;连接数据库失败: &#x27;</span> . <span class="hljs-title function_ invoke__">mysqli_connect_error</span>());<br>&#125;<br><br><span class="hljs-comment">// 执行查询</span><br><span class="hljs-variable">$query</span> = <span class="hljs-string">&quot;SELECT * FROM users&quot;</span>;<br><span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysqli_query</span>(<span class="hljs-variable">$connection</span>, <span class="hljs-variable">$query</span>);<br><br><span class="hljs-comment">// 处理查询结果</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$result</span>) &#123;<br>    <span class="hljs-comment">// 读取结果集中的数据</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable">$row</span> = <span class="hljs-title function_ invoke__">mysqli_fetch_assoc</span>(<span class="hljs-variable">$result</span>)) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;username&#x27;</span>] . <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;查询失败: &#x27;</span> . <span class="hljs-title function_ invoke__">mysqli_error</span>(<span class="hljs-variable">$connection</span>);<br>&#125;<br><br><span class="hljs-comment">// 关闭数据库连接</span><br><span class="hljs-title function_ invoke__">mysqli_close</span>(<span class="hljs-variable">$connection</span>);<br><br></code></pre></td></tr></table></figure><h2 id="6-header"><a href="#6-header" class="headerlink" title="6. header( )"></a>6. header( )</h2> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"> <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;script&gt;window.location.href = &quot;../index.php&quot;;&lt;/script&gt;&#x27;</span>;<br><span class="hljs-comment">// 上面的语句可以替代下面的转向</span><br> <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Location:  ../index.php&#x27;</span>);<br></code></pre></td></tr></table></figure><p>产生原因：由于想在进行数据库的读写之后，从 <code>php</code> 页面转到前端页面，使用 <code>header()</code> 不会执行他前面的 <code>echo</code> 语句，故此</p><h2 id="7-防止-sql-注入"><a href="#7-防止-sql-注入" class="headerlink" title="7.防止 sql 注入"></a>7.防止 sql 注入</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include_once</span> <span class="hljs-string">&quot;../variable.php&quot;</span>;<br><br><span class="hljs-variable">$conn</span> = <span class="hljs-title function_ invoke__">mysqli_connect</span>(<span class="hljs-variable">$mysql_hostname</span>, <span class="hljs-variable">$mysql_username</span>, <span class="hljs-variable">$mysql_password</span>, <span class="hljs-variable">$mysql_database</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-variable">$conn</span>)&#123;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;数据库&quot;</span>.<span class="hljs-variable">$mysql_database</span>.<span class="hljs-string">&quot;连接失败&quot;</span>;<br>  <span class="hljs-keyword">exit</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;连接数据库&quot;</span>.<span class="hljs-variable">$mysql_database</span>.<span class="hljs-string">&quot;成功&quot;</span>;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;text&#x27;</span>]) &amp;&amp; <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;input&#x27;</span>]))&#123;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;script&gt;alert(&#x27;提交&#x27;);&lt;/script&gt;&quot;</span>;<br>  <span class="hljs-variable">$cont1</span> = <span class="hljs-title function_ invoke__">mysqli_real_escape_string</span>(<span class="hljs-variable">$conn</span>, <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;text&#x27;</span>]);<br>  <span class="hljs-variable">$cont2</span> = <span class="hljs-title function_ invoke__">mysqli_real_escape_string</span>(<span class="hljs-variable">$conn</span>, <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;input&#x27;</span>]);<br>  <br>  <span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;INSERT INTO essy (column1, column2) VALUES (?, ?)&quot;</span>;<br>  <span class="hljs-variable">$stmt</span> = <span class="hljs-title function_ invoke__">mysqli_prepare</span>(<span class="hljs-variable">$conn</span>, <span class="hljs-variable">$sql</span>);<br>  <span class="hljs-title function_ invoke__">mysqli_stmt_bind_param</span>(<span class="hljs-variable">$stmt</span>, <span class="hljs-string">&quot;ss&quot;</span>, <span class="hljs-variable">$cont1</span>, <span class="hljs-variable">$cont2</span>);<br>  <span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysqli_stmt_execute</span>(<span class="hljs-variable">$stmt</span>);<br>  <br>  <span class="hljs-keyword">if</span>(!<span class="hljs-variable">$result</span>)&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;插入数据时发生错误：&quot;</span> . <span class="hljs-title function_ invoke__">mysqli_error</span>(<span class="hljs-variable">$conn</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;插入数据成功&quot;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;script&gt;alert(&#x27;提交错误&#x27;);&lt;/script&gt;&quot;</span>;<br>&#125;<br><br><span class="hljs-title function_ invoke__">mysqli_close</span>(<span class="hljs-variable">$conn</span>);<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure><hr><p><code>mysqli_real_escape_string()</code>: </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">函数的作用就是将字符串中的特殊字符进行转义，使其成为合法的 SQL 字符串。转义后的字符串可以安全地插入到 SQL 查询语句中，而不会引发 SQL 注入问题。<br>该函数接受两个参数：第一个是数据库连接对象，第二个是要转义的字符串。函数会返回转义后的字符串。<br></code></pre></td></tr></table></figure><hr><p><code>mysqli_prepare()</code> :</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">该函数用于准备 SQL 查询语句，返回一个 mysqli_stmt 对象。<br>    <span class="hljs-title function_ invoke__">mysqli_prepare</span>() 接受两个参数：<br>       第一个参数是数据库连接对象，<br>       第二个参数是要执行的 SQL 查询语句（参数使用占位符 <span class="hljs-string">&quot;?&quot;</span> 表示）<br></code></pre></td></tr></table></figure><p>这种格式可以提高执行查询的效率，并提高应用程序的安全性。</p><p>为后面的 <code>mysqli_stmt_bind_param</code>( )  <code>mysqli_stmt_execute()</code> 做准备</p><hr><p><code>mysqli_stmt_bind_param</code>( ) :</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php">用于绑定参数到准备好的查询语句中。<br>    它接受三个参数：<br>        第一个参数是 mysqli_stmt 对象，<br>        第二个参数是参数类型的字符串，<br>        第三个参数是要绑定的参数<br> <br>第二个参数类型：<br>    字符串类型：s<br>    整数类型：i<br>    双精度浮点类型：d<br>    布尔类型：b<br>第二个参数是根据第三个要绑定的来确定的，对应的是相应数据库中的类型，因此易知，第三个三数可以是多个值，即对应表中的不同列<br></code></pre></td></tr></table></figure><p>只是绑定，并没有进行插入等操作，绑定之后通过 <code>mysqli_stmt_execute()</code> 来执行 <strong>sql</strong> 语句中的操作</p><p>具体根据 <code>mysqli_prepare()</code> 中的 <strong>sql</strong> 进行的</p><hr><p><code>mysqli_stmt_execute()</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">用于执行准备好的查询语句。<br>   它接受一个参数，即 mysqli_stmt 对象<br>       <br>   返回布尔值<br></code></pre></td></tr></table></figure><hr><p>以上四者搭配使用，一定程度上减小了一点点 <strong>sql</strong> 注入</p>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2024/02/03/mysql/"/>
    <url>/2024/02/03/mysql/</url>
    
    <content type="html"><![CDATA[<p>一、SQL语句</p><blockquote><p>结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。</p></blockquote><blockquote><p>SQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用<code>;</code>进行结尾！</p></blockquote><blockquote><p>SQL也支持注释，通过使用<code>--</code>或是<code>#</code>来编写注释内容，也可以使用<code>/*</code>来进行多行注释。</p></blockquote><h2 id="1、数据库定义语言（DDL）"><a href="#1、数据库定义语言（DDL）" class="headerlink" title="1、数据库定义语言（DDL）"></a>1、数据库定义语言（DDL）</h2><h3 id="（1）创建数据库"><a href="#（1）创建数据库" class="headerlink" title="（1）创建数据库"></a>（1）创建数据库</h3><p><code>create database</code>创建数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database 数据库名<br></code></pre></td></tr></table></figure><p>为了能够支持中文，我们在创建时可以设定编码格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE<br>IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> 数据库名 <br><span class="hljs-keyword">DEFAULT</span> CHARSET utf8<br><span class="hljs-keyword">COLLATE</span> utf8_general_ci;<br></code></pre></td></tr></table></figure><blockquote><p><code>utf8</code>是字符集，<code>utf8_general_ci</code>是编码规则</p></blockquote><p><code>drop database</code>删除一个数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> database 数据库名<br></code></pre></td></tr></table></figure><h3 id="（2）创建表"><a href="#（2）创建表" class="headerlink" title="（2）创建表"></a>（2）创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(列名 数据类型[列级约束条件],<br>             列名 数据类型[列级约束条件],<br>             ...<br>             [,表级约束条件])<br></code></pre></td></tr></table></figure><h3 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h3><p>用于字符串存储：</p><ul><li>char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。</li><li>varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。</li></ul><p>用于存储数字：</p><ul><li>smallint用于存储小的整数，范围在 (-32768，32767)</li><li>int用于存储一般的整数，范围在 (-2147483648，2147483647)</li><li>bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807)</li><li>float用于存储单精度小数</li><li>double用于存储双精度的小数</li></ul><p>用于存储时间：</p><ul><li>date存储日期</li><li>time存储时间</li><li>year存储年份</li><li>datetime用于混合存储日期+时间</li></ul><h3 id="列级约束条件"><a href="#列级约束条件" class="headerlink" title="列级约束条件"></a>列级约束条件</h3><p>列级约束有六种：主键<code>Primary key</code>、外键<code>foreign key</code> 、唯一 <code>unique</code>、检查 <code>check</code> （MySQL不支持）、默认<code>default</code> 、非空&#x2F;空值 <code>not null/ null</code></p><h3 id="表级约束条件"><a href="#表级约束条件" class="headerlink" title="表级约束条件"></a>表级约束条件</h3><p>表级约束有四种：主键（<code>PRIMARY KEY</code>）、外键、唯一（<code>UNIQUE</code>）、检查（<code>CHECK</code>）</p><p>为表增加外检约束条件的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">[<span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>外键名<span class="hljs-operator">&gt;</span>] <br><span class="hljs-keyword">FOREIGN</span> KEY 字段名 [，字段名<span class="hljs-number">2</span>，…] <br><span class="hljs-keyword">REFERENCES</span> <span class="hljs-operator">&lt;</span>主表名<span class="hljs-operator">&gt;</span> 主键列<span class="hljs-number">1</span> [，主键列<span class="hljs-number">2</span>，…]<br></code></pre></td></tr></table></figure><font color='red'>外键名的作用是在报错时可以更好的检查，可以不写 <br><br>字段名中的内容必须在被绑定的主键列里出现过</font><hr><hr><p><strong>说明</strong>：</p><p>在创建时设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Employees (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">UNIQUE</span>,<br>  department_id <span class="hljs-type">INT</span>,<br>  <span class="hljs-keyword">FOREIGN</span> KEY (department_id) <span class="hljs-keyword">REFERENCES</span> Departments(id),<br>  <span class="hljs-keyword">CHECK</span> (id <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>)<br>);<br></code></pre></td></tr></table></figure><p>创建后追加：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Orders<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_customer<br><span class="hljs-keyword">FOREIGN</span> KEY (customer_id)<br><span class="hljs-keyword">REFERENCES</span> Customers(customer_id);<br></code></pre></td></tr></table></figure><p><strong>引用多个列时，被引用列的顺序和数据类型必须与被引用表格中的列定义相对应</strong></p><h3 id="（3）修改表"><a href="#（3）修改表" class="headerlink" title="（3）修改表"></a>（3）修改表</h3><ul><li>添加列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> 列名 类型（约束条件）;<br></code></pre></td></tr></table></figure><ul><li>修改列名：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 RENAME <span class="hljs-keyword">COLUMN</span> 原列名 <span class="hljs-keyword">TO</span> 新列名;<br></code></pre></td></tr></table></figure><ul><li>修改列的类型</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> 列名 类型（约束条件）;<br></code></pre></td></tr></table></figure><ul><li>删除列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> 被删除的列名;<br></code></pre></td></tr></table></figure><ul><li>删除列的约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> teach <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> KEY 约束名字, <span class="hljs-keyword">DROP</span> INDEX 约束名字;<br></code></pre></td></tr></table></figure><blockquote><p>查看外键约束名字：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span><span class="hljs-keyword">SELECT</span> CONSTRAINT_NAME<br><span class="hljs-operator">&gt;</span><span class="hljs-keyword">FROM</span> INFORMATION_SCHEMA.KEY_COLUMN_USAGE<br><span class="hljs-operator">&gt;</span><span class="hljs-keyword">WHERE</span> TABLE_SCHEMA <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;数据库名字&#x27;</span><br><span class="hljs-operator">&gt;</span><span class="hljs-keyword">AND</span> TABLE_NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;表名&#x27;</span><br><span class="hljs-operator">&gt;</span><span class="hljs-keyword">AND</span> COLUMN_NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;列名&#x27;</span><br><span class="hljs-operator">&gt;</span><span class="hljs-keyword">AND</span> REFERENCED_TABLE_NAME <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure></blockquote><ul><li>删除表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名[restrict<span class="hljs-operator">|</span>cascade]<br></code></pre></td></tr></table></figure><p><code>restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除,表同理</code></p><hr><hr><h2 id="2、数据库操纵语言（DML）"><a href="#2、数据库操纵语言（DML）" class="headerlink" title="2、数据库操纵语言（DML）"></a>2、数据库操纵语言（DML）</h2><h3 id="（1）插入数据"><a href="#（1）插入数据" class="headerlink" title="（1）插入数据"></a>（1）插入数据</h3><p>通过使用<code>insert into</code>语句来向数据库中插入一条数据（一条记录）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, 值<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>一次性向数据库中插入多条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h3 id="（2）修改数据"><a href="#（2）修改数据" class="headerlink" title="（2）修改数据"></a>（2）修改数据</h3><p>我们可以通过<code>update</code>语句来更新表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 列名<span class="hljs-operator">=</span>值,... <span class="hljs-keyword">WHERE</span> 条件<br></code></pre></td></tr></table></figure><p>注意，SQL语句中的等于判断是<code>=</code></p><p><strong>警告：</strong>如果忘记添加<code>WHERE</code>字句来限定条件，将使得整个表中此列的所有数据都被修改！</p><h3 id="（3）删除数据"><a href="#（3）删除数据" class="headerlink" title="（3）删除数据"></a>（3）删除数据</h3><p>我们可以通过使用<code>delete</code>来删除表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名<br></code></pre></td></tr></table></figure><p>通过这种方式，将删除表中全部数据，我们也可以使用<code>where</code>来添加条件，只删除指定的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <br></code></pre></td></tr></table></figure><hr><hr><h2 id="3、数据库查询语言（DQL）"><a href="#3、数据库查询语言（DQL）" class="headerlink" title="3、数据库查询语言（DQL）"></a>3、数据库查询语言（DQL）</h2><h3 id="（1）单表查询"><a href="#（1）单表查询" class="headerlink" title="（1）单表查询"></a>（1）单表查询</h3><p>单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用<code>select</code>语句来进行单表查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 指定查询某一列数据</span><br><span class="hljs-keyword">SELECT</span> 列名[,列名] <span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-comment">-- 会以别名显示此列</span><br><span class="hljs-keyword">SELECT</span> 列名 别名 <span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-comment">-- 查询所有的列数据</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-comment">-- 只查询不重复的值</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 列名 <span class="hljs-keyword">FROM</span> 表名<br></code></pre></td></tr></table></figure><p>可以添加<code>where</code>字句来限定查询目标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件<br></code></pre></td></tr></table></figure><hr><h3 id="（2）排序查询"><a href="#（2）排序查询" class="headerlink" title="（2）排序查询"></a>（2）排序查询</h3><p>我们可以通过<code>order by</code>来将查询结果进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列名 <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure><p>使用<code>ASC</code>表示<code>升序排序</code>，使用<code>DESC</code>表示<code>降序排序</code>，<code>默认为升序</code>。</p><p>我们也可以可以同时添加多个排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列名<span class="hljs-number">1</span> <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>, 列名<span class="hljs-number">2</span> <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure><p>这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。</p><hr><h3 id="（3）聚集函数"><a href="#（3）聚集函数" class="headerlink" title="（3）聚集函数"></a>（3）聚集函数</h3><p>聚集函数一般用作统计，包括：</p><ul><li><code>count([distinct]*)</code>统计所有的行数（distinct表示去重再统计，下同）</li><li><code>count([distinct]列名)</code>统计某列的值总和</li><li><code>sum([distinct]列名)</code>求一列的和（注意必须是数字类型的）</li><li><code>avg([distinct]列名)</code>求一列的平均值（注意必须是数字类型）</li><li><code>max([distinct]列名)</code>求一列的最大值</li><li><code>min([distinct]列名)</code>求一列的最小值</li></ul><p>一般聚集函数是这样使用的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> 列名) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <br></code></pre></td></tr></table></figure><hr><h3 id="分组和分页查询"><a href="#分组和分页查询" class="headerlink" title="分组和分页查询"></a>分组和分页查询</h3><p>通过使用<code>group by</code>来对查询结果进行分组，它需要结合聚合函数一起使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 列名<br></code></pre></td></tr></table></figure><p>我们还可以添加<code>having</code>来限制分组条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 列名 <span class="hljs-keyword">HAVING</span> 约束条件<br></code></pre></td></tr></table></figure><p>我们可以通过<code>limit</code>来限制查询的数量，只取前n个结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 LIMIT 数量<br></code></pre></td></tr></table></figure><p>我们也可以进行分页：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 LIMIT 起始位置,数量<br></code></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件<br></code></pre></td></tr></table></figure><p>这样，只会从笛卡尔积的结果中得到满足条件的数据。</p><p><strong>注意：</strong>如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。</p><h3 id="自身连接查询"><a href="#自身连接查询" class="headerlink" title="自身连接查询"></a>自身连接查询</h3><p>自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 别名<span class="hljs-number">1</span>, 表名 别名<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。</p><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">JOIN</span> ... <span class="hljs-keyword">ON</span> ... <span class="hljs-operator">/</span><span class="hljs-operator">/</span>连接起来之后，表的拼接不是笛卡尔积，效率更高<br></code></pre></td></tr></table></figure><p>外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：</p><ul><li>通过使用<code>inner join</code>进行内连接，只会返回两个表满足条件的交集部分：</li></ul><p><img src="/../img/mysql/1.png" alt="在这里插入图片描述"></p><ul><li>通过使用<code>left join</code>进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用<code>null</code>来代替（右连接<code>right join</code>同理，只是反过来而已，这里就不再介绍了）：</li></ul><p><img src="/../img/mysql/2.png" alt="在这里插入图片描述"></p><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>我们可以将查询的结果作为另一个查询的条件，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 列名 <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> 列名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件)<br></code></pre></td></tr></table></figure><p>我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。</p><hr><h2 id="数据库控制语言（DCL）"><a href="#数据库控制语言（DCL）" class="headerlink" title="数据库控制语言（DCL）"></a>数据库控制语言（DCL）</h2><p>庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>我们可以通过<code>create user</code>来创建用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 用户名 identified <span class="hljs-keyword">by</span> 密码;<br></code></pre></td></tr></table></figure><p>也可以不带密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 用户名;<br></code></pre></td></tr></table></figure><p>我们可以通过@来限制用户登录的登录IP地址，<code>%</code>表示匹配所有的IP地址，默认使用的就是任意IP地址。</p><h3 id="登陆用户"><a href="#登陆用户" class="headerlink" title="登陆用户"></a>登陆用户</h3><p>首先需要添加一个环境变量，然后我们通过cmd去登陆mysql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">login <span class="hljs-operator">-</span>u 用户名 <span class="hljs-operator">-</span>p<br></code></pre></td></tr></table></figure><p>输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure><p>我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！</p><h3 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h3><p>我们可以通过使用<code>grant</code>来为一个数据库用户进行授权：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span><span class="hljs-operator">|</span>权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2.</span>..(列<span class="hljs-number">1</span>,...) <span class="hljs-keyword">on</span> 数据库.表 <span class="hljs-keyword">to</span> 用户 [<span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> option]<br></code></pre></td></tr></table></figure><p>其中all代表授予所有权限，当数据库和表为<code>*</code>，代表为所有的数据库和表都授权。如果在最后添加了<code>with grant option</code>，那么被授权的用户还能将已获得的授权继续授权给其他用户。</p><p>我们可以使用<code>revoke</code>来收回一个权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">all</span><span class="hljs-operator">|</span>权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2.</span>..(列<span class="hljs-number">1</span>,...) <span class="hljs-keyword">on</span> 数据库.表 <span class="hljs-keyword">from</span> 用户<br></code></pre></td></tr></table></figure><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。</p><p>我们可以通过<code>create view</code>来创建视图;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 视图名称(列名) <span class="hljs-keyword">as</span> 子查询语句 [<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION];<br></code></pre></td></tr></table></figure><p>WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用<code>select</code>语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。</p><ol><li>若视图是由两个以上基本表导出的，则此视图不允许更新。</li><li>若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。</li><li>若视图的字段来自集函数，则此视图不允许更新。</li><li>若视图定义中含有GROUP BY子句，则此视图不允许更新。</li><li>若视图定义中含有DISTINCT短语，则此视图不允许更新。</li><li>若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade &gt; (SELECT AVG(Grade) FROM SC); 　　导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。</li><li>一个不允许更新的视图上定义的视图也不允许更新</li></ol><p>通过<code>drop</code>来删除一个视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> apptest<br></code></pre></td></tr></table></figure><hr><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">CREATE</span> INDEX 索引名称 <span class="hljs-keyword">ON</span> 表名 (列名)<br><span class="hljs-comment">-- 查看表中的索引</span><br><span class="hljs-keyword">show</span> INDEX <span class="hljs-keyword">FROM</span> student<br></code></pre></td></tr></table></figure><p>我们也可以通过下面的命令删除一个索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> index 索引名称 <span class="hljs-keyword">on</span> 表名<br></code></pre></td></tr></table></figure><p>虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。</p><hr><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器就像其名字一样，在某种条件下会自动触发，在<code>select</code>&#x2F;<code>update</code>&#x2F;<code>delete</code>时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。</p><p>触发器所依附的表称为基本表，当触发器表上发生<code>select</code>&#x2F;<code>update</code>&#x2F;<code>delete</code>等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用）</p><p>比如在<code>insert</code>操作时，新的内容会被插入到new表中；在<code>delete</code>操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在<code>update</code>操作时，旧的内容会被移到old表中，新的内容会出现在new表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> 触发器名称 [BEFORE<span class="hljs-operator">|</span>AFTER] [<span class="hljs-keyword">INSERT</span><span class="hljs-operator">|</span><span class="hljs-keyword">UPDATE</span><span class="hljs-operator">|</span><span class="hljs-keyword">DELETE</span>] <span class="hljs-keyword">ON</span> 表名<span class="hljs-operator">/</span>视图名 <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> student.sno <span class="hljs-operator">=</span> new.sno<br></code></pre></td></tr></table></figure><p> FOR EACH ROW表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！</p><p>通过下面的命令来查看触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TRIGGERS<br></code></pre></td></tr></table></figure><p>如果不需要，我们就可以删除此触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> 触发器名称<br></code></pre></td></tr></table></figure><hr><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> ENGINES;<br></code></pre></td></tr></table></figure><p>MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。</p><p>事务具有以下特性：</p><ul><li><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>我们通过以下例子来探究以下事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;   #开始事务<br>...<br><span class="hljs-keyword">rollback</span>;  #回滚事务<br><span class="hljs-keyword">savepoint</span> 回滚点;  #添加回滚点<br><span class="hljs-keyword">rollback</span> <span class="hljs-keyword">to</span> 回滚点; #回滚到指定回滚点<br>...<br><span class="hljs-keyword">commit</span>; #提交事务<br><span class="hljs-comment">-- 一旦提交，就无法再进行回滚了！</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js API总结</title>
    <link href="/2024/02/03/js_API/"/>
    <url>/2024/02/03/js_API/</url>
    
    <content type="html"><![CDATA[<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><hr><h2 id="1-变量的定义"><a href="#1-变量的定义" class="headerlink" title="1.变量的定义"></a>1.变量的定义</h2><p>能用 <code>const</code> 就用</p><p>Q：怎么考虑能不能用？</p><p>A：复杂数据可以用<strong>const</strong> ，原理？？？不建议看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">因为复杂数据类型的值是放到堆中的，在栈中的只是该内容的地址，那么修改时，是在堆中修改的，栈中的地址不会改变，所以等同于数组或者对象等没有改变；但是如果直接指向一个新的数组或对象等，那么就不能用 const </span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure><hr><h2 id="2-DOM（文档对象模型）"><a href="#2-DOM（文档对象模型）" class="headerlink" title="2.DOM（文档对象模型）"></a>2.DOM（文档对象模型）</h2><p>是什么：用来呈现以及任意 HTML 或 XML  文档交互的API</p><p>作用：开发网页内容实现用户交互</p><h3 id="1-DOM-树"><a href="#1-DOM-树" class="headerlink" title="1.DOM 树"></a>1.DOM 树</h3><p>​是：将文档以树状结构直观的表现出来的，又称文档树；是描述网页内容关系的名词</p><p>​作用：直观体现了标签与标签之间的关系</p><h3 id="2-DOM对象"><a href="#2-DOM对象" class="headerlink" title="2.DOM对象"></a>2.DOM对象</h3><p>是：浏览器根据 html  标签生成的 <strong>JS对象</strong></p><ul><li>所有的标签属性都可以在这个对象上找到</li><li>修改这个对象的属性会自动映射到标签的身上</li></ul><p><strong>document</strong> 对象：</p><ul><li>他所提供的属性和方法都是用来访问和操作网页内容的</li><li>网页所有的内容都在 document 中</li><li>是 DOM 里提供的一个对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nav=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;css选择器&#x27;</span>)<br><span class="hljs-comment">//将网页内的第一个所选择的css选择器对象 赋值 给 nav ，此时nav是一个 对象</span><br><br><span class="hljs-comment">// 注意选择的是第一个，</span><br><br><span class="hljs-comment">//例如：</span><br>&lt;div&gt;<span class="hljs-number">123</span>&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>456<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="hljs-keyword">const</span> nav=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br><span class="hljs-comment">/*选择的是 123 那个 div</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure><p>获取的样例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><br><span class="hljs-keyword">const</span> l=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul li:first-child&#x27;</span>)<br><span class="hljs-comment">//会只获取第一个 li </span><br><span class="hljs-comment">// 额。。。。不写  &#x27;:first-fhild&#x27; 也会只去第一个 li </span><br><span class="hljs-comment">//  :nth-child(n)   选择第n个 </span><br><span class="hljs-comment">//取所有的用</span><br><span class="hljs-keyword">const</span> l=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;ul li&#x27;</span>)<br><span class="hljs-comment">//得到的是一个伪数组，pop(), push() 等不能用，但是可以遍历，获取长度</span><br><br></code></pre></td></tr></table></figure><h3 id="3-修改对象内容"><a href="#3-修改对象内容" class="headerlink" title="3.修改对象内容"></a>3.修改对象内容</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 页面的内容</span><br><span class="hljs-number">1.</span> 对象名.<span class="hljs-property">innerText</span>=<span class="hljs-string">&#x27;修改内容&#x27;</span><br><span class="hljs-comment">// 不会解析修改内容里面的标签</span><br><br><span class="hljs-number">2.</span> 对象名.<span class="hljs-property">innerHTML</span>=<span class="hljs-string">&#x27;修改内容&#x27;</span><br><span class="hljs-comment">// 会解析标签</span><br></code></pre></td></tr></table></figure><h3 id="4-删除数组的元素"><a href="#4-删除数组的元素" class="headerlink" title="4.删除数组的元素"></a>4.删除数组的元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">数组名.<span class="hljs-title function_">splice</span>(开始的下标，删除几个)<span class="hljs-comment">//包括开开始的标签</span><br></code></pre></td></tr></table></figure><h3 id="5-操作元素的属性"><a href="#5-操作元素的属性" class="headerlink" title="5.操作元素的属性"></a>5.操作元素的属性</h3><h4 id="（1）常用属性"><a href="#（1）常用属性" class="headerlink" title="（1）常用属性"></a>（1）常用属性</h4><ul><li>src  ， herf  等</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">对象.属性 = 值<br><span class="hljs-comment">//修改的方式和对象一样，没有创建，有的修改</span><br></code></pre></td></tr></table></figure><h4 id="（2）元素的样式属性"><a href="#（2）元素的样式属性" class="headerlink" title="（2）元素的样式属性"></a>（2）元素的<strong>样式</strong>属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">对象名.<span class="hljs-property">style</span>.样式属性 = 值<br><br><span class="hljs-comment">//如：</span><br>&lt;script&gt;<br>        <span class="hljs-keyword">const</span> box=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<span class="hljs-comment">//获取div</span><br><span class="hljs-comment">//修改宽 背景颜色 外边框</span><br>        box.<span class="hljs-property">style</span>.<span class="hljs-property">width</span>=<span class="hljs-string">&#x27;400px&#x27;</span><br>        box.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span>=<span class="hljs-string">&#x27;red&#x27;</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box)<br>        box.<span class="hljs-property">style</span>.<span class="hljs-property">border</span>=<span class="hljs-string">&#x27;2px solid green&#x27;</span><br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>特例</strong>：</p><p>因为 body 是唯一的标签，所以改标签不用获取，直接修改即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.样式属性 = 值<br></code></pre></td></tr></table></figure><h4 id="（3）操作类名"><a href="#（3）操作类名" class="headerlink" title="（3）操作类名"></a>（3）操作类名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">元素.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;类名1...&#x27;</span><br><span class="hljs-comment">//用新的类名替换旧的类名 ，类名替换元素 ， 元素是获取的类名，可以用过个类名替换原来的类名</span><br><br><span class="hljs-comment">//用下面的代码做解释</span><br>box.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;avtive&#x27;</span><span class="hljs-comment">//会实现将 .opa 替换掉</span><br>box.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;opa active&#x27;</span><span class="hljs-comment">//添加多个类名，替换 .opa </span><br></code></pre></td></tr></table></figure><p>为了解决 <code>className</code> 容易覆盖类名的问题，衍生出了 <code>classList</code> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.opa</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: black;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.active</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: skyblue;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;opa&quot;</span>&gt;</span><br>        文字颜色<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> box=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.opa&#x27;</span>)<span class="hljs-comment">//类名必须写成相应的格式</span></span><br><span class="language-javascript">        box.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<span class="hljs-comment">//添加一个类</span></span><br><span class="language-javascript">        box.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;opa&#x27;</span>)<span class="hljs-comment">//删除一个类</span></span><br><span class="language-javascript">        box.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;opa&#x27;</span>)<span class="hljs-comment">//有这个类就删除，没有就添加</span></span><br><span class="language-javascript">       </span><br><span class="language-javascript"><span class="hljs-comment">//最终显示的背景颜色是 .active 中的，添加 .opa 并没有覆盖前者，是因为前者距离 body 比较远</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-setInterval-函数，间隔时间"><a href="#6-setInterval-函数，间隔时间" class="headerlink" title="6.setInterval ( 函数，间隔时间 )"></a>6.setInterval ( 函数，间隔时间 )</h3><p>默认时间单位 ms</p><p>函数不能写成调用的格式，比如：有名函数 fn()  ，写的时候不能加 后面的小括号，立即执行函数也是，不能加后面的小括号，除非用引号的情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> n=<span class="hljs-built_in">setInterval</span>(<span class="hljs-string">&#x27;fn()&#x27;</span>,<span class="hljs-number">1000</span>)<br><span class="hljs-comment">//这种的可以加小括号</span><br><span class="hljs-comment">//必须有变量名才能关</span><br><span class="hljs-built_in">clearInterval</span>(n)<span class="hljs-comment">//关闭定时器</span><br></code></pre></td></tr></table></figure><h3 id="7-事件监听"><a href="#7-事件监听" class="headerlink" title="7.事件监听"></a>7.事件监听</h3><blockquote><p>事件：在编程是系统内发生的动作或发生的事情</p><p>比如：在网页上点击一个按钮</p></blockquote><blockquote><p>让程序检测是否有事件发生，一旦有事件触发，就立即调用一个函数做出响应，也称 绑定事件 或 注册事件</p><p>比如：点击可以播放轮播图</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">元素对象.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;事件类型&#x27;</span>,要执行的函数)<br></code></pre></td></tr></table></figure><p>三要素：</p><ul><li>事件源：那个dom元素被时间触发了，要获取dom元素</li><li>事件类型：用什么方式触发，比如：单击（click），鼠标经过（mouseenter），鼠标离开（mouseleave）</li><li>事件调用函数：要做什么事情</li></ul><hr><h2 id="3-BOM-浏览器对象模型"><a href="#3-BOM-浏览器对象模型" class="headerlink" title="3.BOM (浏览器对象模型)"></a>3.BOM (浏览器对象模型)</h2><p>作用：使用 <strong>js</strong> 去操作 <strong>html</strong> 和 <strong>浏览器</strong> </p>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
      <category>Js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo更新流程及解析</title>
    <link href="/2024/02/03/hexo/hexo%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/02/03/hexo/hexo%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">.</span><br><span class="hljs-string">├──</span> <span class="hljs-string">.deploy</span>       <span class="hljs-comment"># 需要部署的文件</span><br><span class="hljs-string">├──</span> <span class="hljs-string">node_modules</span>  <span class="hljs-comment"># 项目所有的依赖包和插件</span><br><span class="hljs-string">├──</span> <span class="hljs-string">public</span>        <span class="hljs-comment"># 生成的静态网页文件</span><br><span class="hljs-string">├──</span> <span class="hljs-string">scaffolds</span>     <span class="hljs-comment"># 文章模板</span><br><span class="hljs-string">├──</span> <span class="hljs-string">source</span>        <span class="hljs-comment"># 博客正文和其他源文件等都应该放在这里</span><br><span class="hljs-string">|</span>   <span class="hljs-string">├──</span> <span class="hljs-string">_drafts</span>   <span class="hljs-comment"># 草稿</span><br><span class="hljs-string">|</span>   <span class="hljs-string">└──</span> <span class="hljs-string">_posts</span>    <span class="hljs-comment"># 文章</span><br><span class="hljs-string">├──</span> <span class="hljs-string">themes</span>        <span class="hljs-comment"># 主题</span><br><span class="hljs-string">├──</span> <span class="hljs-string">_config.yml</span>   <span class="hljs-comment"># 全局配置文件</span><br><span class="hljs-string">└──</span> <span class="hljs-string">package.json</span>  <span class="hljs-comment"># 项目依赖信息</span><br><br></code></pre></td></tr></table></figure><h1 id="md文件头部内容"><a href="#md文件头部内容" class="headerlink" title="md文件头部内容"></a>md文件头部内容</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章名称</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020-07-30 16:46:07</span><span class="hljs-string">(创建时间)</span><br><span class="hljs-attr">tags:</span> <span class="hljs-string">文章标签</span><br><span class="hljs-attr">categories:</span> <span class="hljs-string">文章分类</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h2 id="（1）文章顶置，排序"><a href="#（1）文章顶置，排序" class="headerlink" title="（1）文章顶置，排序"></a>（1）文章顶置，排序</h2><p><code>sticky</code> 数值越大，该文章越靠前，达到类似于置顶的效果，其他未设置的文章依然按默认排序。</p><p>当文章设置了 <code>sticky</code> 后，主题会默认在首页文章标题前增加一个图标，来标识这是一个置顶文章，你可以通过<strong>主题配置</strong>去关闭或修改这个功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">post_sticky:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-top&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="（2）文章隐藏"><a href="#（2）文章隐藏" class="headerlink" title="（2）文章隐藏"></a>（2）文章隐藏</h2><p> <code>hide: true</code> 属性</p><p>隐藏后依然可以通过文章链接访问，所以可以用于一些需要链接跳转的特殊文章。</p><p>如果只是想让文章在首页隐藏，但仍<strong>需要在归档分类页里展示</strong>，可以在文章开头 <code>front-matter </code>中配置 <code>archive: true</code> 属性。</p><h2 id="（3）分类和标签"><a href="#（3）分类和标签" class="headerlink" title="（3）分类和标签"></a>（3）分类和标签</h2><p>只有文章支持分类和标签，在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Diary</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">PS3</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Games</span><br></code></pre></td></tr></table></figure><blockquote><p>分类方法的分歧</p><p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">categories:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Diary</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Life</span><br></code></pre></td></tr></table></figure><p>会使分类 <code>Life</code> 成为 <code>Diary</code> 的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> [<span class="hljs-string">Diary</span>, <span class="hljs-string">PlayStation</span>]<br><span class="hljs-bullet">-</span> [<span class="hljs-string">Diary</span>, <span class="hljs-string">Games</span>]<br><span class="hljs-bullet">-</span> [<span class="hljs-string">Life</span>]<br></code></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p></blockquote><h2 id="（4）其他属性"><a href="#（4）其他属性" class="headerlink" title="（4）其他属性"></a>（4）其他属性</h2><table><thead><tr><th align="center"><code>comments</code></th><th align="center">开启文章的评论功能</th><th align="center"><code>true</code></th></tr></thead><tbody><tr><td align="center"><code>tags</code></td><td align="center">标签（不适用于分页）</td><td align="center"></td></tr><tr><td align="center"><code>categories</code></td><td align="center">分类（不适用于分页）</td><td align="center"></td></tr><tr><td align="center"><code>math</code></td><td align="center">对本页面是否启用数学公式解析（需要手动开启）</td><td align="center">true</td></tr></tbody></table><h1 id="更新博客"><a href="#更新博客" class="headerlink" title="更新博客"></a>更新博客</h1><p>使用命令即可推送更新</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 1.清除 hexo 的缓存</span><br><span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><br><span class="hljs-comment"># 2.生成静态网站文件</span><br><span class="hljs-string">hexo</span> <span class="hljs-string">g</span>  <br><span class="hljs-comment"># 3.上传到远程仓库</span><br><span class="hljs-string">hexo</span> <span class="hljs-string">d</span>  <br><span class="hljs-comment"># 4.采用一键部署</span><br><span class="hljs-string">hexo</span> <span class="hljs-string">g</span> <span class="hljs-string">--d</span><br></code></pre></td></tr></table></figure><p><strong>执行2、3就不用执行4，执行2可以在本地先看看，然后再推送</strong></p><h1 id="注意安装插件"><a href="#注意安装插件" class="headerlink" title="注意安装插件"></a>注意安装插件</h1><p>在站点目录下安装插件才可以使用<code>hexo d</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">hexo-deployer-git</span> <span class="hljs-string">--save</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
